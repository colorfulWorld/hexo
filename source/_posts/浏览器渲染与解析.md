---
title: 浏览器渲染与解析
date: 2018-05-17 09:47:28
categories: Web
---

以前在项目中遇到过‘监听浏览器的前进后退重新执行 JS’的需求的场景，所以现在综合一些资料和自己的测试进行总结一下。

<!--more-->

## 客户端渲染机制

浏览器的渲染机制一般分为以下几个步骤

1. 处理 HTML 并构建 DOM 树
2. 处理CSS标记并构建CSSOM树
3. 将DOM与CSSOM合成一颗渲染树
4. 根据渲染树布局，以计算每个节点的几何信息
5. 将各个节点绘制到屏幕上

## 浏览器的线程

浏览器是多线程的，他们在内核控制下相互配合以保持同步，一个浏览器至少实现三个常驻线程：javascript引擎线程、GUI渲染线程、浏览器事件触发线程
- GUI渲染线程：负责渲染浏览器界面的HTML元素，当界面需要重绘或者回流时，该线程就会执行，在javascript引擎运行脚本期间，GUI渲染线程都是出于挂起转态的，也就是说被冻结了
- javascript引擎线程：主要负责处理javascript脚本程序
- 定时器触发线程：浏览器定时器并不是由javascript引擎计数的，javascript引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确，因此浏览器通过单独线程来计时并触发定时
- 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。这些事件包含当前执行的代码，例如定时任务，流量亲耐内核的其他线程如鼠标点击、ajax异步请求等。由于JS的单线程关系所有这些世间都得排队等待JS引擎处理。定时块任何和ajax请求等这些异步队列，事件触发线程只是在到达定时事件或者ajax请求成功后，把回调函数放到事件队列当中
- 异步HTTP请求线程：在XMLHttpRequests在链接后通过浏览器新开一个线程请求，将检测到状态变更时，如果设置有回调函数，异步线程就产生个状态变成事件放到javascript引擎处理队列中等待处理，在发起一个异步请求时，http请求线程负责去请求服务器，有了响应后，事件触发线程再把回调函数放到事件队列当中

## 构建DOM树与CSSOM树
浏览器凶网络或硬盘中获得HTML字节数据后会经过一个流程讲直接解析成DOM树

- 编码：先将HTML的原始字节数据转换为文件指定编码的字符
- 令牌化：然后浏览器会根据HTML规范来将字符串转换成各种令牌（如`<html>、<body>`这样的标签以及标签中的字符串和属性等都会转化为令牌，每个令牌具有特殊含义和一组规则）。令牌记录了标签的开始与结束，通过这个特性可以轻松判断一个标签是否为子标签（假设有<html>与<body>两个标签，当<html>标签的令牌还未遇到它的结束令牌</html>就遇见了<body>标签令牌，那么<body>就是<html>的子标签）。
- 生成对象：接下来每个令牌都会被转换成定义其属性和规则对象（这个对象就是节点对象）
- 构建完毕：DOM树构建完成，整个对象集合就像是一颗属性结构。

## 构建渲染树
在构建了DOM树和CSSOM树之后，浏览器只是拥有了两个互相独立的对象集合，DOM树描述了文档的结构和内容，CSSOM树则描述了对文档应用的样式规则，想要渲染页面，就需要将DOM树与CSSOM树结合在一起
![network](/images/common/render.png)


## 布局与绘制
css采用一种叫做盒子思维模型的思维模型来表示每个节点与其他元素之间的距离，盒子模型包括外边距（margin），内边距（padding），边框（border），内容（content），页面中的每一个标签都是一个个的盒子

![network](/images/common/box.png)
布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕捉每个元素在屏幕内的确切位置与大小，所有相对的测量值也都会被转换成屏幕内的绝对像素值

当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比
## 浏览器前进、后退使用机制

用户点击浏览器工具栏中的后退按钮，或者是移动设备上的返回键的时候，或者是 JS 执行`history.go(-1)`的时候，浏览器会在当前窗口“打开”历史记录中的前一个页面。不同的浏览器在“打开”前一个页面的表现并不同意，这和浏览器的实现以及页面本身的设置都有关系。在浏览器中，“后退到前一个页面”意味着：前一个页面的 html/js/css 等等的静态资源的请求（甚至是 ajax 动态接口请求）根本不会重新发送，直接使用缓存的响应，而不管这些金泰资源响应的缓存策略是否被设置了禁用状态。


## history 中的操作

1.  `window.history.back()`:后退
2.  `window.history.dorward()`:前进
3.  `window.history.go(num)`:前进或后退指定数量历史记录
4.  `window.history.pushState(state,title,url)`:在页面中创建一个 histor 实体，直接天剑到历史记录。
    - state:存储一个对象，可以添加相关信息，可以使用 history.state 读取其中的内容。
    - title:历史记录的标题。
    - url:创建的历史记录的链接，进行历史记录操作时会跳转到改链接。
5.  `window.history.replaceState()`:修改当前的 history 实体。
6.  `popstate`事件:history 实体改变时触发的事件。
7.  `window.history.state`:会获得 history 实体中的 state 对象。

## popstate

popstate 只会在浏览器某些行为下触发，比如点击后退、前进按钮。

在微信浏览器中，从一个 HTML 跳到另一个 HTML 页面后，点击浏览器返回按钮，或者在第二个页面中调用`history.back()`等返回上一页的方法，在安卓中会直接返回上一页(相当于重新加载上一页的所有内容，js 会重新执行一遍)，但苹果手机中，范湖上一页是，浏览器会读取缓存中的页面内容，js 不会重新执行，在此进入这个页面不会触发 onload 事件。

```javascript
//强制刷新：
window.addEventListener(
  'popstate',
  function(e) {
    //检测到用户点击浏览器返回按钮，进行操作
    console.log(document.referrer);

    //使用href的形式去用跳转的形式，跳转到上一页
    document.location.href = document.referrer;
  },
  false
);
var state = {
  title: '',
  url: ''
};
window.history.pushState(state, '', '');
```

## pageshow

onpageshow 事件在页面显示时触发，如果页面不在“往返缓存”中，改时间会在 onload 后触发，在 onpageshow 事件中，可以利用 event.persisted

```javascript
    window.addEventListener('pageshow'.function(evernt){
        alert(event.persisted);
        if(event.persisted) location.reload();//如果检测到页面是从“往返缓存”中读取的，刷新页面。
    });
```

## unload

指定 unload 事件处理程序的页面会被自动排除在“往返缓存”之外，即使事件处理程序是空白的，原因在于，unload 最长用于撤销 load 中所执行的操作，而跳过 load 后再次显示页面很有可能会导致页面不正常。

## 从输入 URL 到 页面加载发生了什么

发生过程：

- 查看 web 缓存
- DNS 解析
- TCP 连接
- 发送 HTTP 请求
- 服务器处理请求并返回 HTTP 报文
- 浏览器解析渲染页面
- 连接结束

### 查看 web 缓存

浏览器获取了这个UR,就先去缓存当中查看，从浏览器缓存-系统缓存-路由缓存当中查。看到有个人的笔记是DNS 解析在前，但是不管是路由还是转发都应该是先从缓存中查看的

当浏览器再次访问一个已经访问过的资源时，它会：

1. 通过Cache-control 和 Expires 来检查是否命中强缓存，命中则直接取本地磁盘的html（状态码为200 from disk(or memory) cache,内存or磁盘）
2. 如果没有命中强缓存，就发送请求到服务器发起请求（先进性下一步的TCP链接），服务器通过Etag 和 Last-Modify来与服务器确认返回的响应是否被更改（协商缓存）。
3. 如果命中协商缓存，访问服务器，服务器返回 304 not modified 告诉浏览器使用本地缓存。
4. 否则，请求网络返回最新资源。

浏览器缓存的位置：

1. service worker :它可以让我们自由控制哪些文件、如何匹配缓存，如何读取缓存，并且缓存是持续性的。
2. memory cache:内存缓存，读取内存中的数据肯定比磁盘块，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放，一旦关闭了 tap 页，内存中的缓存也得到了释放。
3. disk cache：也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比如 memory cache 胜在容量和存储时效性上。

缓存实现：强缓存和协商缓存都是根据 HTTP Header 来实现的。

#### 浏览器缓存机制

![network](/images/problem/2.png)

##### 当前缓存是否过期。

如果浏览器通过某些条件 ( 条件之后再说 ) 判断出来，ok 现在这个缓存没有过期可以用，那么连请求都不会发的，直接是启用之前浏览器缓存下来的那份文件 (from memory cache). 浏览器直接通过缓存读取了出来，注意这个时候是不会向浏览器请求的！ 如果过期了就会向服务器重新发起请求，但是不一定就会重新拉取文件！

##### 服务器中的文件是否改动。

1. 缓存过期，文件有改动：如果服务器发现这个文件改变了那么你肯定不能再用以前浏览器的缓存了，那就返回个 200 并且带上新的文件。

2. 缓存过期，文件无改动：同时如果发现虽然那个缓存虽然过期了，可你在服务器端的文件没有变过，那么服务器只会给你返回一个头信息 (304)，让你继续用你那过期的缓存，这样就节省了很多传输文件的时间带宽啥的

过期了的缓存需要请求一次服务器，若服务器判断说这个文件没有改变还能用，那就返回 304。浏览器认识 304，它就会去读取过期缓存。否则就真的传一份新文件到浏览器。

### DNS 解析

浏览器查找域名对应的 IP 地址。互联网上每一台计算机的唯一识别是它的 IP 地址，DNS 解析就是讲网址转换为 IP 地址。

查找过程：

1. 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）
2. 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）
3. 搜索操作系统的 host 文件（Windows 环境下，维护一张域名与 IP 地址的对应表）
4. 操作系统间根域名发送至 LDNS（本地域名服务器），首先查找自己的缓存若是失败：
   - 向根域名服务器发起请求，此处根域名服务器返回 com 域的 sing 机域名服务器地址。
   - LDNS 向 com 域的顶级域名服务器发起请求，得到 www.baidu.com 的地址。
   - LONS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址。
5. LDNS 将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；
6. 操作系统将 IP 地址返回给浏览器，同时自己也缓存起来；

此时浏览器得到了域名对应的 IP 地址。

### TCP 连接

浏览器根据 IP 地址与服务器建立 socket 连接 。
TCP协议通过三次握手建立连接。
- 客户端通过SYN报文段发送连接请求，确定服务器端是否开启端口准备连接，状态设置为SYN_SEND
- 服务器如果有开着的端口并且决定结接受连接，就会返回一个SYN+ACK报文段给客户端，状态设置为SYN_RECV
- 客户端收到服务器的SYN+ACK报文段，向服务器发送ACK报文段表示确认。此时客户端和服务器端都设置为ESTABLISHED 状态。连接建立，可以开始数据传输了。


### 发送 HTTP 请求

1. 浏览器根据 URL 内容生成 HTTP 请求，请求中包含文件的位置，请求文件的方式等。
2. 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件。

#### http 状态码

1. 200 form memory cache 不访问服务器，直接读缓存 ，此时的缓存是缓存在内存中的，当 kill 进程之后数据就会不存在。这种方式只能缓存派生资源。
2. 200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存。
3. 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。200(from cache) 是速度最快的 , 因为不需要访问远程服务器 , 直接使用本地缓存 .304 的过程是 , 先请求服务器 , 然后服务器告诉我们这个资源没变 , 浏览器再使用本地缓存。
4. 200 from dist cache 不访问服务器，直接度缓存，当进程 kill 时，数据依旧存在。只能缓存派生资源。

![network](/images/problem/1.png)

### 浏览器解析渲染页面

现代浏览器渲染页面过程是：解码（字节流到字符流） ——> 分词（此法分析） ——> 解析（语法分析）——> 构建 DOM 树 ——> 构建渲染树 ——> 布局渲染树 ——> 绘制渲染树

### 连接结束

断开连接 --4 次挥手

- 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。

- 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。
