---
title: HTTP2
date: 2018-03-22 11:05:35
categories: 网络&安全
---

http/2 的前身是由 Google 与 2009 年发布的实验性协议 SPDY，其主要目标是**通过解决 HTTP/1.1 中广为人知的一些性能限制来减少页面的架子啊延迟**。

<!--more-->

HTTP 请求完就结束了，所以 HTTP 根本没有长连接说法，更没有短连接了，**HTTP 是应用层的协议**，而长连接与短连接说的是 TCP 链接，TCP 链接是一个双向通道，它可以保持一段时间不关闭，因为 TCP 链接才有真正的长连接和短连接。

一个形象的例子就是，拿你在网上购物来说，HTTP 协议是指的那个快递单，你寄件的时候填的单子就像是发了一个 HTTP 请求，等货物运到地方了，快递员会根据你发的请求把货物送给相应的收货人。而 TCP 协议就是中间运货的那个大货车，也可能是火车或者飞机，但不管是什么，它是负责运输的，因此必须要有路，不管是地上还是天上。那么这个路就是所谓的 TCP 连接，也就是一个双向的数据通道。

在 HTTP/1.1 起，默认都开启了 Keep-Alive，保持连接特性：在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如 Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。

HTTP/1.1 的主要性能问题：

- HTTTP/1.x 客户端需要使用多个连接才能实现并发和缩短延时。
- HTTP/1.x 不会压缩请求和响应标头，从而导致不必要的网络流量。
- HTTP/1.x 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。

这正是 HTTP/2 要致力于解决的：
HTTP/2 通过支持**标头字段压缩和在同一连接上进行多个并发连接**，让应用更有效低利用网络资源，减少感知的延时时间。具体来说，它可以对同一链接上的请求和响应消息进行交错发送并未 HTTP 标头字段有效编码。**HTTP/2 还允许为请求设置优先级，让更重要的请求更快速地完成**，从而进一步提升性能。

## 多路复用的单一长连接

### 单一长连接

在 HTTP/2 中，客户端向某个域名的服务器请求页面的过程中，**只会创建一条 TCP 连接**，即使这页面可能包含上百个资源。而之前的 HTTP/1.x 一般会创建 6-8 条 TCP 连接来请求这 100 多个资源。单一的连接应该是 HTTP2 的主要优势，单一的连接能减少 TCP 握手带来的延时（如果是建立在 SSL、TLS 上面，HTTP2 能减少很多不必要的 SSL 握手。）

TCP 协议有一个滑动窗口，有慢启动这件事，就是说每次建立连接后，数据先是慢慢的传，然后滑动窗口慢慢变大，才能较高效的传，但是 http/1.x 会创建新连接受数据，因此像公交车一样走走停停（向大神致敬）。

### 多路复用

![network](/images/common/http2_1.jpg)

在 http1.x 中，在一条 TCP 连接上，多个请求只能串行执行。HTTP2 把要传输的信息分割成一个个二进制帧，首部信息会被封装到 HWADER Frame，相应的 request body 就会放到 DATA Frame，这样就讲请求和响应区分开来了。进一步 HTTP2 还能对这些流（车道）制定优先级，优先级能动态的被改变。优先级能动态的被改变，例如把 CSS 和 JavaScript 文件设置得比图片的优先级要高，这样代码文件能更快的下载下来并得到执行。

## 头部压缩和二进制格式

因为一些重复东西在每个 http 请求里面都有，例如 method: GET。当一个客户端从同一服务器请求一些资源（例如页面的图片）的时候，这些请求看起来几乎是一致的。而这些大量一致的东西正好值得被压缩。HTTP2 使用 HPACK 要锁头部，减少报头的大小

## 服务端推送 server push

这个功能通常被称为“缓存推送”。主要思想是：当用户请求资源 X，而服务器知道它可能也需要资源 Z 的情况下，服务器可以在客户端发送请求之前，主动将资源 Z 推送给客户端。

这个功能帮组客户端将 Z 放进缓存以备将来只需。**服务端推送需要客户端显示的允许服务器提供该功能**，但即使如此，客户端依然能自主选择是否需要终端推送的流。如果不需要的话。客户端可以通过发送一个 RST_STREAM 帧来中止。
