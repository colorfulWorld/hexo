---
title: 一篇弄懂继承
date: 2018-01-18 10:17:34
categories: JavaScript
---

继承的串联及扩展

<!--more-->

## 继承

很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在 ECMScript 中是不可能的，因为函数没有签名。实现继承是 ECMScript 唯一支持的集成方法，而这主要是通过原型链实现。

其基本思想就是通过原型继承多个引用类型的属性和方法

常用继承：组合继承，寄生组合继承

javascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。
有两种继承方式：

1. 寄生函数继承（构造函数继承 (call/apply)），利用 call 继承父类上的属性，用子类的原型等于父类实例去继承父类的方法。缺点：调用父类两次，造成性能浪费。
2. 原型链继承 ( 挂载到 prototype 属性上面 )。

### 关系判断

- instanceof 判断是否为另一个对象的实例
- isPrototypeOf() 判断对象是否存在另一个对象原型链上 Chtild.isPrototypeOf(Parent)
- Object.getPrototypeOf() ES6 中新增的方法，用于获取子类的父类 Object.getPrototypeOf(child)==Parent //true

## 寄生函数继承

```javascript
function Person(name, age, sex) {
  this.name = name

  this.age = age

  this.sex = sex
}

function Student(name, age, sex, score) {
  Person.call(this, name, age, sex)

  this.score = score
}

Student.prototype = new Person() // 这里改变了原型指向，实现继承

var stu = new Student('小明', 20, '男', 99) //创建了学生对象stu

console.log(stu instanceof Student) // true

console.log(stu instanceof Person) // true

console.log(stu instanceof Object) // true
```

寄生函数继承：利用 call 继承父类上的属性，用一个干净的函数的原型去等于父类原型，再用子类的原型的等于干净函数的实例。

## 原型链继承

实例出来的是共用的

```javascript
function Parent() {
  this.name = 'Parent1'
  this.arr = [1, 2, 3, 4, 5]
}

Parent.prototype.say = function () {
  console.log(this.name)
}

function Child() {
  this.m = [1, 2, 3]
  this.type = 'Child1'
}

Child.prototype = new Parent()

var s1 = new Child()
var s2 = new Child()
s1.m.push(4) //[1,2,3,4]
s2.m.push(6) //[1,2,3,6]
s1.arr.push(6)
console.log(s1.arr) //[1,2,3,4,5,6]
console.log(s2.arr) //[1,2,3,4,5,6]
//他们俩是公用的
console.log(s1.__proto__ === s2.__proto__) //true
```

## 构造函数继承

```javascript
function Parent(name) {
  this.name = name
  this.friends = ['A', 'B']
}
Parent.prototype.say = function () {
  log(this.name, this.friends)
}
function Person() {
  Parent.apply(this, arguments)
  // parent.say.bind(child, arguments)(); //child world
  this.age = 23
}
var p1 = new Person('nameA')
var p2 = new Person('nameB')
log(p1.name) //nameA
log(p2.name) //nameB
p1.friends.push('C')
p2.friends.push('D')
log(p1.friends) //["A", "B", "C"]
log(p2.friends) //["A", "B", "D"]
log(p1.say()) // Uncaught TypeError: p1.say is not a function
```

- 优点：子类可以向父类的构造函数中传参，子类实例中的引用类型属性互不干扰
- 缺点：子类实例无法访问父类的原型（无法复用父类原型中的方法）

## Object.create

(Object.create MDN)[https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create]

```javascript
//polyfill
if (typeof Object.create !== "function") {
    Object.create = function (proto, propertiesObject) {
        if (typeof proto !== 'object' && typeof proto !== 'function') {
            throw new TypeError('Object prototype may only be an Object: ' + proto);
        } else if (proto === null) {
            throw new Error("This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.");
        }

        if (typeof propertiesObject !== 'undefined') throw new Error("This browser's implementation of Object.create is a shim and doesn't support a second argument.");

        function F() {}
        F.prototype = proto; //intanceof 的核心判断也是用的这句

        return new F();
    };
}
```
