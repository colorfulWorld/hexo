{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/prototype/1.png","path":"images/prototype/1.png","modified":1,"renderable":0},{"_id":"source/images/prototype/2.png","path":"images/prototype/2.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/uploads/avatar.png","path":"uploads/avatar.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1515999726077},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1515999726078},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1515999726078},{"_id":"themes/next/.gitignore","hash":"a6ab82e5d773974b48ebbe562abbdd891345b238","modified":1516068950627},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1515999726080},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1515999726082},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1515999726081},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1515999726081},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1515999726082},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1515999726082},{"_id":"themes/next/README.cn.md","hash":"87950c415dd162ff78e98b41f1148b85462103e2","modified":1515999726083},{"_id":"themes/next/_config.yml","hash":"607da9323aee03b3b27d5aa1923efa7a782fc7c5","modified":1516069437783},{"_id":"themes/next/README.md","hash":"927f82cfeb5969a89b815b5ec3a3f2881e3b1bb4","modified":1515999726083},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1515999726084},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1515999726084},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1515999726120},{"_id":"source/_posts/HTTPS.md","hash":"f6d0f8b1ece42304d08dd852e59c46972b68e2ba","modified":1514531209288},{"_id":"source/_posts/JS代码片段.md","hash":"d91f9a4a36af945cafa39874cc17867100931fca","modified":1516008916021},{"_id":"source/_posts/JS基础-ES5.md","hash":"477a79995b70a5619fa6da3d210e7f1134a3fae0","modified":1516676509373},{"_id":"source/_posts/Object-defineProperty.md","hash":"e8c2de6eea5be0e46ebd8df4e38796c77cd162f5","modified":1516179696022},{"_id":"source/_posts/Observable.md","hash":"9c45b8497590282b3cad3b76d9d8e06b13f3b1c5","modified":1514531209289},{"_id":"source/_posts/PWA-offline.md","hash":"e81e6e645998f23c44ec5865c9a0a655f33f5b9e","modified":1514531209289},{"_id":"source/_posts/PWA-pushMessage.md","hash":"24c336349d4d728dba1b9971f4c0ae7aa596a40e","modified":1514531209290},{"_id":"source/_posts/angular-form.md","hash":"416bd221b7ddfefb73a8248ccae0373e31d42c01","modified":1514531209291},{"_id":"source/_posts/angular-数据绑定.md","hash":"daf4ac6fa4cc7a7254f802c9184653c16035300d","modified":1516239905477},{"_id":"source/_posts/angular-线上商城学习.md","hash":"2d4f00011565f755171b780f23d13d088f71a2b9","modified":1516180412242},{"_id":"source/_posts/angular基础.md","hash":"c7f8a45d69e60f9e2b27a7b2f9013f7a54bd3525","modified":1514531209292},{"_id":"source/_posts/css-小技巧.md","hash":"4c4967587264266b532925bda6e2d299cbed58ca","modified":1514531209293},{"_id":"source/_posts/localstorage.md","hash":"5c439e28f9e9778af04407e9ef5acecf78206882","modified":1514531209293},{"_id":"source/_posts/react-native-入门.md","hash":"a5de40d4a886d922f590508011192d514e26402f","modified":1516065046820},{"_id":"source/_posts/this指向.md","hash":"b278f69077f86e242c88f21f9fd5602b328e5042","modified":1516679019712},{"_id":"source/_posts/作用域.md","hash":"61a5e1bc1e497447cd6c59d1dbb16d0a4a2b4215","modified":1516678551418},{"_id":"source/_posts/你不知道的JavaScript-中.md","hash":"1519e6216f697e341c64ab35465c79c67d4e53f0","modified":1516009902238},{"_id":"source/_posts/字符串操作方法.md","hash":"5a5003b736ab8f26eccbb682eaea69b20e3cb4d4","modified":1516183910315},{"_id":"source/_posts/如何实现双向数据绑定-mvvm.md","hash":"14a83953a82f66ef8cc93fe403e1baf717e058fe","modified":1516180464319},{"_id":"source/_posts/疑难杂问整理（原生JS）.md","hash":"a2e9a87a20a1e3bb533386c408b798228165a4dc","modified":1516358935553},{"_id":"source/_posts/数组操作方法.md","hash":"e7b7abab1baf4cadf1db6ad348d515669c642172","modified":1516004391758},{"_id":"source/categories/index.md","hash":"d7ef72b21495ca2a07db024bf0d6d471da51ddc2","modified":1516004161410},{"_id":"source/tags/index.md","hash":"ee5a6eae9b3cd761c5f5b0ed4ea89199ca36f423","modified":1516003766202},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1515999726091},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1515999726118},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1515999726119},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1515999726119},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1515999726119},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1515999726120},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1515999726120},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1516066418491},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1515999726085},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1515999726085},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1515999726085},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1515999726086},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1515999726086},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1515999726086},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1515999726087},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1515999726087},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1516068977817},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1515999726088},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1515999726088},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1515999726089},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1515999726089},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1515999726089},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1515999726090},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1515999726090},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1515999726121},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1515999726122},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1515999726526},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1515999726526},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1515999726526},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726363},{"_id":"source/images/prototype/1.png","hash":"b56d7ed5068f6f314ba1d48a694f3917111fa659","modified":1516588178814},{"_id":"source/images/prototype/2.png","hash":"fc3a6c80a4d80fb8b5889c506e2ad7592b544134","modified":1516589725289},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1515999726091},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1515999726090},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1515999726094},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1515999726094},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1515999726095},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1515999726096},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1515999726096},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1515999726096},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1515999726097},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1515999726091},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1515999726092},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1515999726092},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1515999726092},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1515999726093},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1515999726093},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1515999726100},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1515999726100},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1515999726102},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1515999726111},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1515999726112},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1515999726112},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1515999726113},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1515999726113},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1515999726113},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1515999726115},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1515999726156},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1515999726122},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1515999726122},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1515999726157},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1515999726158},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1515999726162},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1515999726160},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1515999726163},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1515999726164},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1515999726362},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1515999726365},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1515999726368},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1515999726369},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1515999726366},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1515999726370},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1515999726372},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1515999726374},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1515999726375},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1515999726376},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1515999726383},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1515999726384},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1515999726385},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1515999726388},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1515999726386},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1515999726389},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1515999726390},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1515999726391},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1515999726392},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726101},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726101},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726274},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726274},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726275},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726358},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1515999726361},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1515999726095},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1515999726095},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1515999726097},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1515999726098},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1515999726098},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1515999726098},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1515999726099},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1515999726099},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1515999726099},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1515999726101},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1515999726101},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1515999726102},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1515999726103},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1515999726103},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1515999726103},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1515999726104},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1515999726104},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1515999726105},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1515999726105},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1515999726105},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1515999726106},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1515999726106},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1515999726106},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1515999726107},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1515999726107},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1515999726108},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1515999726108},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1515999726108},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1515999726109},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1515999726109},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1515999726110},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1515999726109},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1515999726111},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1515999726111},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1515999726117},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1515999726117},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1515999726117},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1515999726118},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1515999726273},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1515999726274},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1515999726275},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1515999726275},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1515999726357},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1515999726358},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1515999726359},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1515999726361},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1515999726436},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1515999726449},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1515999726447},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1515999726451},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1515999726451},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1515999726469},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1515999726468},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1515999726469},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1515999726471},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1515999726471},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1515999726464},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1515999726464},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1515999726465},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1515999726466},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1515999726495},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1515999726498},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1515999726498},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1515999726500},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1515999726499},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1515999726500},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1515999726502},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1515999726504},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1515999726504},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1515999726505},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1515999726506},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1515999726507},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1515999726507},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1515999726508},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1515999726509},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1515999726510},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1515999726510},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1515999726511},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1515999726512},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1515999726512},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1515999726512},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1515999726513},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1515999726513},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1515999726514},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1515999726515},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1515999726515},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1515999726516},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1515999726522},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1515999726522},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1515999726524},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1515999726525},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1515999726525},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1515999726394},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1515999726396},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1515999726395},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1515999726398},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1515999726401},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1515999726399},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1515999726403},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1515999726404},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1515999726407},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1515999726408},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1515999726409},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1515999726496},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1515999726116},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1515999726116},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1515999726168},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1515999726169},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1515999726171},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1515999726172},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1515999726173},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1515999726192},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1515999726215},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1515999726230},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1515999726231},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1515999726233},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1515999726233},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1515999726234},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1515999726234},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1515999726272},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1515999726276},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1515999726277},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1515999726277},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1515999726278},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1515999726278},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1515999726278},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1515999726279},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1515999726315},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1515999726320},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1515999726321},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1515999726322},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1515999726323},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1515999726324},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1515999726327},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1515999726328},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1515999726329},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1515999726330},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1515999726331},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1515999726332},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1515999726426},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1515999726432},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1515999726435},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1515999726452},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1515999726453},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1515999726454},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1515999726454},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1515999726455},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1515999726456},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1515999726461},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1515999726462},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1515999726463},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1515999726472},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1515999726473},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1515999726474},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1515999726467},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1515999726467},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1515999726521},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1515999726520},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1515999726406},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1515999726430},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1515999726492},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1515999726494},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1515999726524},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1515999726176},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1515999726179},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1515999726178},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1515999726181},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1515999726182},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1515999726183},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1515999726184},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1515999726186},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1515999726185},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1515999726187},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1515999726188},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1515999726189},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1515999726190},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1515999726191},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1515999726193},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1515999726194},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1515999726195},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1515999726196},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1515999726198},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1515999726199},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1515999726200},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1515999726201},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1515999726202},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1515999726203},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1515999726204},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1515999726204},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1515999726205},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1515999726206},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1515999726207},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1515999726209},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1515999726209},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1515999726210},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1515999726211},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1515999726211},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1515999726212},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1515999726213},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1515999726213},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1515999726214},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1515999726214},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1515999726215},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1515999726216},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1515999726216},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1515999726217},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1515999726217},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1515999726218},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1515999726218},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1515999726219},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1515999726219},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1515999726220},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1515999726221},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1515999726222},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1515999726223},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1515999726224},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1515999726225},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1515999726226},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1515999726227},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1515999726227},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1515999726228},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1515999726316},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1515999726318},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1515999726325},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1515999726419},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1515999726420},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1515999726422},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1515999726423},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1515999726424},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1515999726457},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1515999726457},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1515999726459},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1515999726459},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1515999726458},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1515999726460},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1515999726477},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1515999726491},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1515999726481},{"_id":"themes/next/source/uploads/avatar.png","hash":"c75f6661eb5fe538f4f51f0a3acdb7be77d5db87","modified":1516002141207},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1515999726445},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1515999726519},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1515999726487}],"Category":[{"name":"http","_id":"cjcr3j7d90003j8vrrlgvv355"},{"name":"原生JS","_id":"cjcr3j7do0007j8vrqrp16wan"},{"name":"数据劫持基石","_id":"cjcr3j7dt000bj8vrzkoypzvp"},{"name":"PWA","_id":"cjcr3j7dx000fj8vr4b6n6dzz"},{"name":"rx.js","_id":"cjcr3j7e6000jj8vrsxxryaqm"},{"name":"angular","_id":"cjcr3j7ej000rj8vrob2r68b7"},{"name":"css","_id":"cjcr3j7et0015j8vr3vct96jr"},{"name":"react-native","_id":"cjcr3j7eu0018j8vryrl4f269"},{"name":"webAPI","_id":"cjcr3j7eu001aj8vrywlysagn"},{"name":"vue","_id":"cjcr3j7eu001cj8vrdlyk30qi"}],"Data":[],"Page":[{"title":"分类","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\ncomments: false\n---\n","date":"2018-01-15T08:16:01.410Z","updated":"2018-01-15T08:16:01.410Z","path":"categories/index.html","layout":"page","_id":"cjcr3j7le001gj8vr94omqrt7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","tags":"Testing","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntags: Testing\n---\n","date":"2018-01-15T08:09:26.202Z","updated":"2018-01-15T08:09:26.202Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjcr3j7lg001hj8vr2dtplwog","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"JS代码片段","date":"2018-01-15T08:27:23.000Z","_content":"\n搬砖时的 JS 代码片段整理\n\n<!--more-->\n\n## 将 bytes 格式化\n\n```javascript\nlet total = this.fileSizeFormat(spaceSize, 2, true, false)\n\n fileSizeFormat(bytes, fixedDigits, unitFlag, floorFlag) {\n      bytes = parseFloat(bytes)\n      let absBytes = Math.abs(bytes)\n      let humanSize, unit\n\n      if (fixedDigits === undefined) {\n        fixedDigits = 2\n      }\n      if (unitFlag === undefined) {\n        unitFlag = true\n      }\n\n      if (absBytes < 1024) {\n        fixedDigits = 0\n        humanSize = bytes\n        unit = 'B'\n      } else {\n        if (absBytes < 900 * 1024) {\n          humanSize = bytes / 1024\n          unit = 'K'\n        } else {\n          if (absBytes < 900 * 1048576) {\n            humanSize = bytes / 1048576\n            unit = 'M'\n          } else {\n            if (absBytes < 900 * 1073741824 || (fixedDigits === 0 && absBytes < 1048576 * 1048576)) {\n              humanSize = bytes / 1073741824\n              unit = 'G'\n            } else {\n              humanSize = bytes / (1048576 * 1048576)\n              unit = 'T'\n            }\n          }\n        }\n        humanSize = Math.round(humanSize * Math.pow(10, fixedDigits)) / parseFloat(Math.pow(10, fixedDigits))\n        humanSize = humanSize.toFixed(fixedDigits)\n\n        let result\n        if (floorFlag && fixedDigits > 0) {\n          if (humanSize !== Math.floor(humanSize)) {\n            result = humanSize\n          } else {\n            result = parseInt(Math.floor(humanSize), 10)\n          }\n        } else {\n          result = humanSize\n        }\n        if (unitFlag) {\n          result = result + unit\n        }\n\n        return result\n      }\n    }\n```\n","source":"_posts/JS代码片段.md","raw":"---\ntitle: JS代码片段\ndate: 2018-01-15 16:27:23\ntags:\n---\n\n搬砖时的 JS 代码片段整理\n\n<!--more-->\n\n## 将 bytes 格式化\n\n```javascript\nlet total = this.fileSizeFormat(spaceSize, 2, true, false)\n\n fileSizeFormat(bytes, fixedDigits, unitFlag, floorFlag) {\n      bytes = parseFloat(bytes)\n      let absBytes = Math.abs(bytes)\n      let humanSize, unit\n\n      if (fixedDigits === undefined) {\n        fixedDigits = 2\n      }\n      if (unitFlag === undefined) {\n        unitFlag = true\n      }\n\n      if (absBytes < 1024) {\n        fixedDigits = 0\n        humanSize = bytes\n        unit = 'B'\n      } else {\n        if (absBytes < 900 * 1024) {\n          humanSize = bytes / 1024\n          unit = 'K'\n        } else {\n          if (absBytes < 900 * 1048576) {\n            humanSize = bytes / 1048576\n            unit = 'M'\n          } else {\n            if (absBytes < 900 * 1073741824 || (fixedDigits === 0 && absBytes < 1048576 * 1048576)) {\n              humanSize = bytes / 1073741824\n              unit = 'G'\n            } else {\n              humanSize = bytes / (1048576 * 1048576)\n              unit = 'T'\n            }\n          }\n        }\n        humanSize = Math.round(humanSize * Math.pow(10, fixedDigits)) / parseFloat(Math.pow(10, fixedDigits))\n        humanSize = humanSize.toFixed(fixedDigits)\n\n        let result\n        if (floorFlag && fixedDigits > 0) {\n          if (humanSize !== Math.floor(humanSize)) {\n            result = humanSize\n          } else {\n            result = parseInt(Math.floor(humanSize), 10)\n          }\n        } else {\n          result = humanSize\n        }\n        if (unitFlag) {\n          result = result + unit\n        }\n\n        return result\n      }\n    }\n```\n","slug":"JS代码片段","published":1,"updated":"2018-01-15T09:35:16.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7ct0000j8vrtsn1stag","content":"<p>搬砖时的 JS 代码片段整理</p>\n<a id=\"more\"></a>\n<h2 id=\"将-bytes-格式化\"><a href=\"#将-bytes-格式化\" class=\"headerlink\" title=\"将 bytes 格式化\"></a>将 bytes 格式化</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"keyword\">this</span>.fileSizeFormat(spaceSize, <span class=\"number\">2</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> fileSizeFormat(bytes, fixedDigits, unitFlag, floorFlag) &#123;</span><br><span class=\"line\">      bytes = <span class=\"built_in\">parseFloat</span>(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> absBytes = <span class=\"built_in\">Math</span>.abs(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> humanSize, unit</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fixedDigits === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        fixedDigits = <span class=\"number\">2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unitFlag === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        unitFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">        fixedDigits = <span class=\"number\">0</span></span><br><span class=\"line\">        humanSize = bytes</span><br><span class=\"line\">        unit = <span class=\"string\">'B'</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">          humanSize = bytes / <span class=\"number\">1024</span></span><br><span class=\"line\">          unit = <span class=\"string\">'K'</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1048576</span>) &#123;</span><br><span class=\"line\">            humanSize = bytes / <span class=\"number\">1048576</span></span><br><span class=\"line\">            unit = <span class=\"string\">'M'</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1073741824</span> || (fixedDigits === <span class=\"number\">0</span> &amp;&amp; absBytes &lt; <span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)) &#123;</span><br><span class=\"line\">              humanSize = bytes / <span class=\"number\">1073741824</span></span><br><span class=\"line\">              unit = <span class=\"string\">'G'</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              humanSize = bytes / (<span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)</span><br><span class=\"line\">              unit = <span class=\"string\">'T'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        humanSize = <span class=\"built_in\">Math</span>.round(humanSize * <span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, fixedDigits)) / <span class=\"built_in\">parseFloat</span>(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, fixedDigits))</span><br><span class=\"line\">        humanSize = humanSize.toFixed(fixedDigits)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (floorFlag &amp;&amp; fixedDigits &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (humanSize !== <span class=\"built_in\">Math</span>.floor(humanSize)) &#123;</span><br><span class=\"line\">            result = humanSize</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.floor(humanSize), <span class=\"number\">10</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          result = humanSize</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unitFlag) &#123;</span><br><span class=\"line\">          result = result + unit</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>搬砖时的 JS 代码片段整理</p>","more":"<h2 id=\"将-bytes-格式化\"><a href=\"#将-bytes-格式化\" class=\"headerlink\" title=\"将 bytes 格式化\"></a>将 bytes 格式化</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"keyword\">this</span>.fileSizeFormat(spaceSize, <span class=\"number\">2</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> fileSizeFormat(bytes, fixedDigits, unitFlag, floorFlag) &#123;</span><br><span class=\"line\">      bytes = <span class=\"built_in\">parseFloat</span>(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> absBytes = <span class=\"built_in\">Math</span>.abs(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> humanSize, unit</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fixedDigits === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        fixedDigits = <span class=\"number\">2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unitFlag === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        unitFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">        fixedDigits = <span class=\"number\">0</span></span><br><span class=\"line\">        humanSize = bytes</span><br><span class=\"line\">        unit = <span class=\"string\">'B'</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">          humanSize = bytes / <span class=\"number\">1024</span></span><br><span class=\"line\">          unit = <span class=\"string\">'K'</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1048576</span>) &#123;</span><br><span class=\"line\">            humanSize = bytes / <span class=\"number\">1048576</span></span><br><span class=\"line\">            unit = <span class=\"string\">'M'</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1073741824</span> || (fixedDigits === <span class=\"number\">0</span> &amp;&amp; absBytes &lt; <span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)) &#123;</span><br><span class=\"line\">              humanSize = bytes / <span class=\"number\">1073741824</span></span><br><span class=\"line\">              unit = <span class=\"string\">'G'</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              humanSize = bytes / (<span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)</span><br><span class=\"line\">              unit = <span class=\"string\">'T'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        humanSize = <span class=\"built_in\">Math</span>.round(humanSize * <span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, fixedDigits)) / <span class=\"built_in\">parseFloat</span>(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, fixedDigits))</span><br><span class=\"line\">        humanSize = humanSize.toFixed(fixedDigits)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (floorFlag &amp;&amp; fixedDigits &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (humanSize !== <span class=\"built_in\">Math</span>.floor(humanSize)) &#123;</span><br><span class=\"line\">            result = humanSize</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.floor(humanSize), <span class=\"number\">10</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          result = humanSize</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unitFlag) &#123;</span><br><span class=\"line\">          result = result + unit</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>"},{"title":"HTTPS","comments":1,"_content":" https 可以理解为HTTP+TLS，TLS是传输层加密协议，是HTTPS安全的核心，其前身是SSL。TLS主要有五部分:应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS协议本身又是由record协议传输的。\n\n### 为什么要实现HTTPS？\n为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。\n\n<!--more-->\n\n### 全站HTTPS 必须解决的问题\n---\n**性能**\n\n* HTTPS需要多次握手，因此网络耗时变长，用户从HTTP跳转到HTTPS需要一些时间。但是如果使用SPDY，HTTPS的速度甚至比HTTP快。HTTPS对速度的影响主要来自两方面:\n    1. 协议交换所增加的网络RTT。\n    2. 加解密相关的计算耗时。\n* HTTPS要做RSA校验，这会影响到设备性能。\n* 所有CDN节点要支持HTTPS，而且需要有极其复杂的解决方案来面对DDoS的挑战。\n** 其次，兼容性及周边:**\n* 页面中所有嵌入的资源（图片、附件、js、视频等）都要改为HTTPS的，否者就会报警。\n\n\n### 基于协议和配置的优化\n\n1.HTTPS 访问速度优化\n2.Tcp fast open\n\n#### HTTPS:\n网站通常的做法是对HTTP的访问服务器端做302 跳转，跳转到HTTPS。但是这个302跳转存在两个问题:\n1.使用不安全的HTTP协议进行通信。\n2.增加一个Round-Trip Time。\n\n而HSTS 是HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用HTTPS与服务器创建链接。其实HSTS的最大作用是防止302HTTP劫持（中间人）HSTS的缺点是浏览器支持率不高，另外配置HTST后HTTPS很难实时降级为HTTP。\n\n采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。\n\n在https://xxx 的响应头中含有Strict-Transport-Security:max-age=31536000;includeSubDomains这就意味着两点：\n   1. 在一年的时间里（31536000秒）中，浏览器只要向XXX或者其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如用户在地址栏输入http://xxx 或者点击超链接，浏览器应当自动将http转写成https,然后直接向https://xxx/ 发起请求。\n   2. 在接下来的一年中，如果xxx服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。\n\n##### 作用\nHTST 可以用来抵御SSL剥离攻击。攻击者在用户访问HTTP页面时替换所有https开头的连接为http。达到阻止HTTPS的目的。但是如果使用了HTST，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。\n\n##### 不足\n用户首次访问网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能明文HTTP访问。HTST会在一段时间后失效（由max-age指定)。所以浏览器是否强制 HSTS取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。\n\n一旦浏览器接受到HSTS Header(假如有效期是1年），但是网站的证书出现问题，那么在有效都无法访问网站。\n\n#### Session resume 复用session\n1. 减少 CPU 消耗，因为不需要非对称秘钥交换的计算。\n2. 提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。\n\n##### Session cache\nSession cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。\n\nSession cache 有两个缺点：\n\n1.    需要消耗服务端内存来存储 session 内容。\n\n2.    目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。\n\nSession cache 也有一个非常大的优点：\n\n1.   session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。\n\n百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。\n\n####  使用 SPDY 或者 HTTP2\n\nSPDY 是 google 推出的优化 HTTP 传输效率的协议（https://www.chromium.org/spdy） 它基本上沿用了 HTTP 协议的语义, 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。\n\nHTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。\n\n需要说明两点:\n\n1.    SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。\n\n2.    SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。\n\nGoogle 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。\n\n百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。\n\n\n","source":"_posts/HTTPS.md","raw":"---\ntitle: HTTPS\ncategories: http\ncomments: true\n---\n https 可以理解为HTTP+TLS，TLS是传输层加密协议，是HTTPS安全的核心，其前身是SSL。TLS主要有五部分:应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS协议本身又是由record协议传输的。\n\n### 为什么要实现HTTPS？\n为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。\n\n<!--more-->\n\n### 全站HTTPS 必须解决的问题\n---\n**性能**\n\n* HTTPS需要多次握手，因此网络耗时变长，用户从HTTP跳转到HTTPS需要一些时间。但是如果使用SPDY，HTTPS的速度甚至比HTTP快。HTTPS对速度的影响主要来自两方面:\n    1. 协议交换所增加的网络RTT。\n    2. 加解密相关的计算耗时。\n* HTTPS要做RSA校验，这会影响到设备性能。\n* 所有CDN节点要支持HTTPS，而且需要有极其复杂的解决方案来面对DDoS的挑战。\n** 其次，兼容性及周边:**\n* 页面中所有嵌入的资源（图片、附件、js、视频等）都要改为HTTPS的，否者就会报警。\n\n\n### 基于协议和配置的优化\n\n1.HTTPS 访问速度优化\n2.Tcp fast open\n\n#### HTTPS:\n网站通常的做法是对HTTP的访问服务器端做302 跳转，跳转到HTTPS。但是这个302跳转存在两个问题:\n1.使用不安全的HTTP协议进行通信。\n2.增加一个Round-Trip Time。\n\n而HSTS 是HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用HTTPS与服务器创建链接。其实HSTS的最大作用是防止302HTTP劫持（中间人）HSTS的缺点是浏览器支持率不高，另外配置HTST后HTTPS很难实时降级为HTTP。\n\n采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。\n\n在https://xxx 的响应头中含有Strict-Transport-Security:max-age=31536000;includeSubDomains这就意味着两点：\n   1. 在一年的时间里（31536000秒）中，浏览器只要向XXX或者其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如用户在地址栏输入http://xxx 或者点击超链接，浏览器应当自动将http转写成https,然后直接向https://xxx/ 发起请求。\n   2. 在接下来的一年中，如果xxx服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。\n\n##### 作用\nHTST 可以用来抵御SSL剥离攻击。攻击者在用户访问HTTP页面时替换所有https开头的连接为http。达到阻止HTTPS的目的。但是如果使用了HTST，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。\n\n##### 不足\n用户首次访问网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能明文HTTP访问。HTST会在一段时间后失效（由max-age指定)。所以浏览器是否强制 HSTS取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。\n\n一旦浏览器接受到HSTS Header(假如有效期是1年），但是网站的证书出现问题，那么在有效都无法访问网站。\n\n#### Session resume 复用session\n1. 减少 CPU 消耗，因为不需要非对称秘钥交换的计算。\n2. 提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。\n\n##### Session cache\nSession cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。\n\nSession cache 有两个缺点：\n\n1.    需要消耗服务端内存来存储 session 内容。\n\n2.    目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。\n\nSession cache 也有一个非常大的优点：\n\n1.   session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。\n\n百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。\n\n####  使用 SPDY 或者 HTTP2\n\nSPDY 是 google 推出的优化 HTTP 传输效率的协议（https://www.chromium.org/spdy） 它基本上沿用了 HTTP 协议的语义, 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。\n\nHTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。\n\n需要说明两点:\n\n1.    SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。\n\n2.    SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。\n\nGoogle 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。\n\n百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。\n\n\n","slug":"HTTPS","published":1,"date":"2018-01-15T08:18:09.882Z","updated":"2017-12-29T07:06:49.288Z","layout":"post","photos":[],"link":"","_id":"cjcr3j7d20001j8vruyxt0kwk","content":"<p> https 可以理解为HTTP+TLS，TLS是传输层加密协议，是HTTPS安全的核心，其前身是SSL。TLS主要有五部分:应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS协议本身又是由record协议传输的。</p>\n<h3 id=\"为什么要实现HTTPS？\"><a href=\"#为什么要实现HTTPS？\" class=\"headerlink\" title=\"为什么要实现HTTPS？\"></a>为什么要实现HTTPS？</h3><p>为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。</p>\n<a id=\"more\"></a>\n<h3 id=\"全站HTTPS-必须解决的问题\"><a href=\"#全站HTTPS-必须解决的问题\" class=\"headerlink\" title=\"全站HTTPS 必须解决的问题\"></a>全站HTTPS 必须解决的问题</h3><hr>\n<p><strong>性能</strong></p>\n<ul>\n<li>HTTPS需要多次握手，因此网络耗时变长，用户从HTTP跳转到HTTPS需要一些时间。但是如果使用SPDY，HTTPS的速度甚至比HTTP快。HTTPS对速度的影响主要来自两方面:<ol>\n<li>协议交换所增加的网络RTT。</li>\n<li>加解密相关的计算耗时。</li>\n</ol>\n</li>\n<li>HTTPS要做RSA校验，这会影响到设备性能。</li>\n<li>所有CDN节点要支持HTTPS，而且需要有极其复杂的解决方案来面对DDoS的挑战。<br><strong> 其次，兼容性及周边:</strong></li>\n<li>页面中所有嵌入的资源（图片、附件、js、视频等）都要改为HTTPS的，否者就会报警。</li>\n</ul>\n<h3 id=\"基于协议和配置的优化\"><a href=\"#基于协议和配置的优化\" class=\"headerlink\" title=\"基于协议和配置的优化\"></a>基于协议和配置的优化</h3><p>1.HTTPS 访问速度优化<br>2.Tcp fast open</p>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS:\"></a>HTTPS:</h4><p>网站通常的做法是对HTTP的访问服务器端做302 跳转，跳转到HTTPS。但是这个302跳转存在两个问题:<br>1.使用不安全的HTTP协议进行通信。<br>2.增加一个Round-Trip Time。</p>\n<p>而HSTS 是HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用HTTPS与服务器创建链接。其实HSTS的最大作用是防止302HTTP劫持（中间人）HSTS的缺点是浏览器支持率不高，另外配置HTST后HTTPS很难实时降级为HTTP。</p>\n<p>采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。</p>\n<p>在<a href=\"https://xxx\" target=\"_blank\" rel=\"noopener\">https://xxx</a> 的响应头中含有Strict-Transport-Security:max-age=31536000;includeSubDomains这就意味着两点：</p>\n<ol>\n<li>在一年的时间里（31536000秒）中，浏览器只要向XXX或者其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如用户在地址栏输入<a href=\"http://xxx\" target=\"_blank\" rel=\"noopener\">http://xxx</a> 或者点击超链接，浏览器应当自动将http转写成https,然后直接向<a href=\"https://xxx/\" target=\"_blank\" rel=\"noopener\">https://xxx/</a> 发起请求。</li>\n<li>在接下来的一年中，如果xxx服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。</li>\n</ol>\n<h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><p>HTST 可以用来抵御SSL剥离攻击。攻击者在用户访问HTTP页面时替换所有https开头的连接为http。达到阻止HTTPS的目的。但是如果使用了HTST，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。</p>\n<h5 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h5><p>用户首次访问网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能明文HTTP访问。HTST会在一段时间后失效（由max-age指定)。所以浏览器是否强制 HSTS取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。</p>\n<p>一旦浏览器接受到HSTS Header(假如有效期是1年），但是网站的证书出现问题，那么在有效都无法访问网站。</p>\n<h4 id=\"Session-resume-复用session\"><a href=\"#Session-resume-复用session\" class=\"headerlink\" title=\"Session resume 复用session\"></a>Session resume 复用session</h4><ol>\n<li>减少 CPU 消耗，因为不需要非对称秘钥交换的计算。</li>\n<li>提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。</li>\n</ol>\n<h5 id=\"Session-cache\"><a href=\"#Session-cache\" class=\"headerlink\" title=\"Session cache\"></a>Session cache</h5><p>Session cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。</p>\n<p>Session cache 有两个缺点：</p>\n<ol>\n<li><p>需要消耗服务端内存来存储 session 内容。</p>\n</li>\n<li><p>目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。</p>\n</li>\n</ol>\n<p>Session cache 也有一个非常大的优点：</p>\n<ol>\n<li>session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。</li>\n</ol>\n<p>百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。</p>\n<h4 id=\"使用-SPDY-或者-HTTP2\"><a href=\"#使用-SPDY-或者-HTTP2\" class=\"headerlink\" title=\"使用 SPDY 或者 HTTP2\"></a>使用 SPDY 或者 HTTP2</h4><p>SPDY 是 google 推出的优化 HTTP 传输效率的协议（<a href=\"https://www.chromium.org/spdy）\" target=\"_blank\" rel=\"noopener\">https://www.chromium.org/spdy）</a> 它基本上沿用了 HTTP 协议的语义, 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。</p>\n<p>HTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。</p>\n<p>需要说明两点:</p>\n<ol>\n<li><p>SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。</p>\n</li>\n<li><p>SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。</p>\n</li>\n</ol>\n<p>Google 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。</p>\n<p>百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。</p>\n","site":{"data":{}},"excerpt":"<p> https 可以理解为HTTP+TLS，TLS是传输层加密协议，是HTTPS安全的核心，其前身是SSL。TLS主要有五部分:应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS协议本身又是由record协议传输的。</p>\n<h3 id=\"为什么要实现HTTPS？\"><a href=\"#为什么要实现HTTPS？\" class=\"headerlink\" title=\"为什么要实现HTTPS？\"></a>为什么要实现HTTPS？</h3><p>为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。</p>","more":"<h3 id=\"全站HTTPS-必须解决的问题\"><a href=\"#全站HTTPS-必须解决的问题\" class=\"headerlink\" title=\"全站HTTPS 必须解决的问题\"></a>全站HTTPS 必须解决的问题</h3><hr>\n<p><strong>性能</strong></p>\n<ul>\n<li>HTTPS需要多次握手，因此网络耗时变长，用户从HTTP跳转到HTTPS需要一些时间。但是如果使用SPDY，HTTPS的速度甚至比HTTP快。HTTPS对速度的影响主要来自两方面:<ol>\n<li>协议交换所增加的网络RTT。</li>\n<li>加解密相关的计算耗时。</li>\n</ol>\n</li>\n<li>HTTPS要做RSA校验，这会影响到设备性能。</li>\n<li>所有CDN节点要支持HTTPS，而且需要有极其复杂的解决方案来面对DDoS的挑战。<br><strong> 其次，兼容性及周边:</strong></li>\n<li>页面中所有嵌入的资源（图片、附件、js、视频等）都要改为HTTPS的，否者就会报警。</li>\n</ul>\n<h3 id=\"基于协议和配置的优化\"><a href=\"#基于协议和配置的优化\" class=\"headerlink\" title=\"基于协议和配置的优化\"></a>基于协议和配置的优化</h3><p>1.HTTPS 访问速度优化<br>2.Tcp fast open</p>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS:\"></a>HTTPS:</h4><p>网站通常的做法是对HTTP的访问服务器端做302 跳转，跳转到HTTPS。但是这个302跳转存在两个问题:<br>1.使用不安全的HTTP协议进行通信。<br>2.增加一个Round-Trip Time。</p>\n<p>而HSTS 是HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用HTTPS与服务器创建链接。其实HSTS的最大作用是防止302HTTP劫持（中间人）HSTS的缺点是浏览器支持率不高，另外配置HTST后HTTPS很难实时降级为HTTP。</p>\n<p>采用HSTS协议的网站将保证浏览器始终连接到该网站的HTTPS加密版本，不需要用户手动在URL地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。</p>\n<p>在<a href=\"https://xxx\" target=\"_blank\" rel=\"noopener\">https://xxx</a> 的响应头中含有Strict-Transport-Security:max-age=31536000;includeSubDomains这就意味着两点：</p>\n<ol>\n<li>在一年的时间里（31536000秒）中，浏览器只要向XXX或者其子域名发送HTTP请求时，必须采用HTTPS来发起连接。比如用户在地址栏输入<a href=\"http://xxx\" target=\"_blank\" rel=\"noopener\">http://xxx</a> 或者点击超链接，浏览器应当自动将http转写成https,然后直接向<a href=\"https://xxx/\" target=\"_blank\" rel=\"noopener\">https://xxx/</a> 发起请求。</li>\n<li>在接下来的一年中，如果xxx服务器发送的TLS证书无效，用户不能忽略浏览器警告继续访问网站。</li>\n</ol>\n<h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><p>HTST 可以用来抵御SSL剥离攻击。攻击者在用户访问HTTP页面时替换所有https开头的连接为http。达到阻止HTTPS的目的。但是如果使用了HTST，一旦服务器发送了HSTS字段，用户将不再允许忽略警告。</p>\n<h5 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h5><p>用户首次访问网站是不受HSTS保护的。这是因为首次访问时，浏览器还未收到HSTS，所以仍有可能明文HTTP访问。HTST会在一段时间后失效（由max-age指定)。所以浏览器是否强制 HSTS取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。</p>\n<p>一旦浏览器接受到HSTS Header(假如有效期是1年），但是网站的证书出现问题，那么在有效都无法访问网站。</p>\n<h4 id=\"Session-resume-复用session\"><a href=\"#Session-resume-复用session\" class=\"headerlink\" title=\"Session resume 复用session\"></a>Session resume 复用session</h4><ol>\n<li>减少 CPU 消耗，因为不需要非对称秘钥交换的计算。</li>\n<li>提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。</li>\n</ol>\n<h5 id=\"Session-cache\"><a href=\"#Session-cache\" class=\"headerlink\" title=\"Session cache\"></a>Session cache</h5><p>Session cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。</p>\n<p>Session cache 有两个缺点：</p>\n<ol>\n<li><p>需要消耗服务端内存来存储 session 内容。</p>\n</li>\n<li><p>目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。</p>\n</li>\n</ol>\n<p>Session cache 也有一个非常大的优点：</p>\n<ol>\n<li>session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。</li>\n</ol>\n<p>百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。</p>\n<h4 id=\"使用-SPDY-或者-HTTP2\"><a href=\"#使用-SPDY-或者-HTTP2\" class=\"headerlink\" title=\"使用 SPDY 或者 HTTP2\"></a>使用 SPDY 或者 HTTP2</h4><p>SPDY 是 google 推出的优化 HTTP 传输效率的协议（<a href=\"https://www.chromium.org/spdy）\" target=\"_blank\" rel=\"noopener\">https://www.chromium.org/spdy）</a> 它基本上沿用了 HTTP 协议的语义, 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。</p>\n<p>HTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。</p>\n<p>需要说明两点:</p>\n<ol>\n<li><p>SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。</p>\n</li>\n<li><p>SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。</p>\n</li>\n</ol>\n<p>Google 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。</p>\n<p>百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。</p>"},{"title":"JS基础(ES5)","date":"2018-01-18T02:12:34.000Z","_content":"\n感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。\n\n<!--more-->\n\n## 对象\n\n创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可\n分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。\n\n### 对象直接量\n\n对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。\n每次计算对象直接量的时候。也会计算它的每个属性值，**也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每\n次创建的对象的属性值也有可能不同。**\n\n### 通过 new 创建对象\n\nvar obj=new MyClass(); new 运算符创建并初始化一个**新对象** 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向\nMyClass.prototype\n\n#### object.creat()\n\n## 原型\n\n原型：每一个对象都从原型继承属性。**每个对象都有 _proto_ 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性**,\n但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否\n是 o 的原型。\n\n### 原型模式\n\n原型模式是 js 对继承的一种实现\n\n* prototype：构造函数中的属性，指向该构造函数的原型对象。\n\n* constructor ：原型对象中的属性，指向该原型对象的构造函数\n\n* *proto*：实例中的属性，指向 new 这个实例的构造函数的原型对象\n\n### prototype 属性的引入\n\n每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个\nprototype 属性。\n\n这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享\n的属性及方法，就放在构造函数里面。\n\n实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是\n引用的。\n\n```javascript\nfunction DOG(name) {\n  this.name = name\n}\nDOG.prototype = { species: '犬科' }\n\nvar dogA = new DOG('大毛')\nvar dogB = new DOG('二毛')\n\nalert(dogA.species)\n// 其实是通过dogA._proto_.species 来访问DOG.prototype.species\nalert(dogB.species)\n// 犬科\nDOG.prototype\n//{species:''犬科',constructor:fDOG(name),_proto_:Object}\nDOG.prototype.constructor === DOG\n//true\n```\n\n现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。\n\n![img](/images/prototype/1.png)\n\n以上就是一个简单的 DOG 类完整的原型链。\n\n#### 原型链的作用：对象属性的访问修改和删除。\n\n* 访问。优先在对象本身查找，没有则顺着原型链向上查找\n* 修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。\n\n### _proto_ （原型指针）\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nperson1.__proto__ == Person.prototype\n//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person\nPerson.__proto__\n//Person.constructor = Function => Person.__proto__  = Function.prototype\nPerson.prototype.__proto__\n// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object => Person.prototype.__proto__ =  Object.prototype\nObject.__proto__\n//普通对象 同上\nObject.prototype.__proto__\n//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端\n```\n\nJS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _proto_ 的内置属性，**用于指向创建它的构造函数的原型对\n象** ，原型链继承是通过 _proto_ 这个原型指针来完成的\n\n### 原型链图\n\n褐色的线为原型链 ![img](/images/prototype/2.png)\n\n够造函数、原型和实例的关系：\n\n1. 每个构造函数都有一个原型对象（x.prototype)\n2. 原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)\n3. 实例都包含一个指向原型对象的内部指针（a._proto_ ）\n\n** 所有函数的默认原型都是 Object 的实例**\n\n### 继承\n\njavascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型\n链继承 ( 挂载到 prototype 属性上面 )。\n\n## 闭包\n\n创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在\n创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。\n\n```jacascript\nfunction test () {\n  for (var i = 0; i < 4; i++) {\n     console.log(\"i:\"+i);\n    (function (e) {\n      setTimeout(function () {\n        console.log(e);\n      }, 0)\n    })(i)\n  }\n}\ntest(); //i:0 => i:1 => i:2=> i:3=>  0 => 1=> 2 => 3\n```\n\n循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的\n引用，它是不会被循环改变的。\n\n```javascript\nfunction makeAdder(x) {\n  console.log('x:' + x)\n  return function(y) {\n    console.log('y:' + y)\n    return x + y\n  }\n}\n\nvar add5 = makeAdder(5)\n//x:5 undefined\nadd5\n//f(y){  console.log('y:' + y) return x + y}\nvar add10 = makeAdder(10)\n\nconsole.log(add5(2)) // y:2 => 7\nconsole.log(add10(2)) // 12\n\n// 释放对闭包的引用\nadd5 = null\nadd10 = null\n```\n\nadd5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后\n通过 null 释放对闭包的引用。\n\n在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引\n用，那么这两个互相引用的对象也会被回收。\n\n**闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是摸个特殊的变量**\n\n```javascript\nfunction test() {\n  var arr = []\n  for (var i = 0; i < 10; i++) {\n    //作用域1\n    arr[i] = function() {\n      //作用域2 声明arr[]()\n      return i\n    }\n  }\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest()\n// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明\n//1.执行完for之后，在for作用域中i的值为10\n```\n\n改动一下\n\n```javascript\nfunction test() {\n  var arr = []\n  //块1作用域\n  for (let i = 0; i < 10; i++) {\n    //块2作用域\n    arr[i] = function() {\n      //块3作用域\n      return i\n    }\n  }\n  //块1作用域\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest() // 连续打印 0 到 9\n```\n\n**实现原因 :**\n\n* 当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr[a]()) 时 i 已经循环完毕，因此\n  i 全为 10。\n\n- 当使用 let 时，每次迭代 i 都被**重新声明**，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。\n- var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。\n\n### 闭包中的 this 对象\n\n```javascript\nvar name = 'The Window'\n\nvar obj = {\n  name: 'My Object',\n\n  getName: function() {\n    return function() {\n      return this.name\n    }\n  }\n}\n\nconsole.log(obj.getName()()) // The Window\n```\n\nobj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分\n割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。\n\n### 闭包的应用\n\n**应用闭包的主要场合是：设计私有的方法和变量。** \n闭包的作用：\n* 访问函数的内部变量\n* 让被引用的变量值始终保存在内存中\n\n```javascript\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\n\nvar a = fun(0) // undefined\na.fun(1) // 0\na.fun(2) // 0\na.fun(3) // 0\n\nvar b = fun(0)\n  .fun(1)\n  .fun(2)\n  .fun(3) // undefined,0,1,2\n\nvar c = fun(0).fun(1) // undefined,0\nc.fun(2) // 1\nc.fun(3) // 1\n```\n\n```javascript\nfunction fn1() {\n  var a = 1\n  return function() {\n    console.log(++a)\n  }\n}\n\nvar fn2 = fn1()\n\nfn2() //输出2\n\nfn2() //输出3\n```\n","source":"_posts/JS基础-ES5.md","raw":"---\ntitle: JS基础(ES5)\ndate: 2018-01-18 10:12:34\ncategories: 原生JS\n---\n\n感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。\n\n<!--more-->\n\n## 对象\n\n创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可\n分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。\n\n### 对象直接量\n\n对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。\n每次计算对象直接量的时候。也会计算它的每个属性值，**也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每\n次创建的对象的属性值也有可能不同。**\n\n### 通过 new 创建对象\n\nvar obj=new MyClass(); new 运算符创建并初始化一个**新对象** 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向\nMyClass.prototype\n\n#### object.creat()\n\n## 原型\n\n原型：每一个对象都从原型继承属性。**每个对象都有 _proto_ 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性**,\n但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否\n是 o 的原型。\n\n### 原型模式\n\n原型模式是 js 对继承的一种实现\n\n* prototype：构造函数中的属性，指向该构造函数的原型对象。\n\n* constructor ：原型对象中的属性，指向该原型对象的构造函数\n\n* *proto*：实例中的属性，指向 new 这个实例的构造函数的原型对象\n\n### prototype 属性的引入\n\n每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个\nprototype 属性。\n\n这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享\n的属性及方法，就放在构造函数里面。\n\n实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是\n引用的。\n\n```javascript\nfunction DOG(name) {\n  this.name = name\n}\nDOG.prototype = { species: '犬科' }\n\nvar dogA = new DOG('大毛')\nvar dogB = new DOG('二毛')\n\nalert(dogA.species)\n// 其实是通过dogA._proto_.species 来访问DOG.prototype.species\nalert(dogB.species)\n// 犬科\nDOG.prototype\n//{species:''犬科',constructor:fDOG(name),_proto_:Object}\nDOG.prototype.constructor === DOG\n//true\n```\n\n现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。\n\n![img](/images/prototype/1.png)\n\n以上就是一个简单的 DOG 类完整的原型链。\n\n#### 原型链的作用：对象属性的访问修改和删除。\n\n* 访问。优先在对象本身查找，没有则顺着原型链向上查找\n* 修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。\n\n### _proto_ （原型指针）\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nperson1.__proto__ == Person.prototype\n//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person\nPerson.__proto__\n//Person.constructor = Function => Person.__proto__  = Function.prototype\nPerson.prototype.__proto__\n// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object => Person.prototype.__proto__ =  Object.prototype\nObject.__proto__\n//普通对象 同上\nObject.prototype.__proto__\n//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端\n```\n\nJS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _proto_ 的内置属性，**用于指向创建它的构造函数的原型对\n象** ，原型链继承是通过 _proto_ 这个原型指针来完成的\n\n### 原型链图\n\n褐色的线为原型链 ![img](/images/prototype/2.png)\n\n够造函数、原型和实例的关系：\n\n1. 每个构造函数都有一个原型对象（x.prototype)\n2. 原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)\n3. 实例都包含一个指向原型对象的内部指针（a._proto_ ）\n\n** 所有函数的默认原型都是 Object 的实例**\n\n### 继承\n\njavascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型\n链继承 ( 挂载到 prototype 属性上面 )。\n\n## 闭包\n\n创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在\n创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。\n\n```jacascript\nfunction test () {\n  for (var i = 0; i < 4; i++) {\n     console.log(\"i:\"+i);\n    (function (e) {\n      setTimeout(function () {\n        console.log(e);\n      }, 0)\n    })(i)\n  }\n}\ntest(); //i:0 => i:1 => i:2=> i:3=>  0 => 1=> 2 => 3\n```\n\n循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的\n引用，它是不会被循环改变的。\n\n```javascript\nfunction makeAdder(x) {\n  console.log('x:' + x)\n  return function(y) {\n    console.log('y:' + y)\n    return x + y\n  }\n}\n\nvar add5 = makeAdder(5)\n//x:5 undefined\nadd5\n//f(y){  console.log('y:' + y) return x + y}\nvar add10 = makeAdder(10)\n\nconsole.log(add5(2)) // y:2 => 7\nconsole.log(add10(2)) // 12\n\n// 释放对闭包的引用\nadd5 = null\nadd10 = null\n```\n\nadd5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后\n通过 null 释放对闭包的引用。\n\n在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引\n用，那么这两个互相引用的对象也会被回收。\n\n**闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是摸个特殊的变量**\n\n```javascript\nfunction test() {\n  var arr = []\n  for (var i = 0; i < 10; i++) {\n    //作用域1\n    arr[i] = function() {\n      //作用域2 声明arr[]()\n      return i\n    }\n  }\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest()\n// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明\n//1.执行完for之后，在for作用域中i的值为10\n```\n\n改动一下\n\n```javascript\nfunction test() {\n  var arr = []\n  //块1作用域\n  for (let i = 0; i < 10; i++) {\n    //块2作用域\n    arr[i] = function() {\n      //块3作用域\n      return i\n    }\n  }\n  //块1作用域\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest() // 连续打印 0 到 9\n```\n\n**实现原因 :**\n\n* 当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr[a]()) 时 i 已经循环完毕，因此\n  i 全为 10。\n\n- 当使用 let 时，每次迭代 i 都被**重新声明**，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。\n- var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。\n\n### 闭包中的 this 对象\n\n```javascript\nvar name = 'The Window'\n\nvar obj = {\n  name: 'My Object',\n\n  getName: function() {\n    return function() {\n      return this.name\n    }\n  }\n}\n\nconsole.log(obj.getName()()) // The Window\n```\n\nobj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分\n割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。\n\n### 闭包的应用\n\n**应用闭包的主要场合是：设计私有的方法和变量。** \n闭包的作用：\n* 访问函数的内部变量\n* 让被引用的变量值始终保存在内存中\n\n```javascript\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\n\nvar a = fun(0) // undefined\na.fun(1) // 0\na.fun(2) // 0\na.fun(3) // 0\n\nvar b = fun(0)\n  .fun(1)\n  .fun(2)\n  .fun(3) // undefined,0,1,2\n\nvar c = fun(0).fun(1) // undefined,0\nc.fun(2) // 1\nc.fun(3) // 1\n```\n\n```javascript\nfunction fn1() {\n  var a = 1\n  return function() {\n    console.log(++a)\n  }\n}\n\nvar fn2 = fn1()\n\nfn2() //输出2\n\nfn2() //输出3\n```\n","slug":"JS基础-ES5","published":1,"updated":"2018-01-23T03:01:49.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7d70002j8vr9qt6e3a6","content":"<p>感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可<br>分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。</p>\n<h3 id=\"对象直接量\"><a href=\"#对象直接量\" class=\"headerlink\" title=\"对象直接量\"></a>对象直接量</h3><p>对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。<br>每次计算对象直接量的时候。也会计算它的每个属性值，<strong>也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每<br>次创建的对象的属性值也有可能不同。</strong></p>\n<h3 id=\"通过-new-创建对象\"><a href=\"#通过-new-创建对象\" class=\"headerlink\" title=\"通过 new 创建对象\"></a>通过 new 创建对象</h3><p>var obj=new MyClass(); new 运算符创建并初始化一个<strong>新对象</strong> 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向<br>MyClass.prototype</p>\n<h4 id=\"object-creat\"><a href=\"#object-creat\" class=\"headerlink\" title=\"object.creat()\"></a>object.creat()</h4><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><p>原型：每一个对象都从原型继承属性。<strong>每个对象都有 <em>proto</em> 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性</strong>,<br>但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否<br>是 o 的原型。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>原型模式是 js 对继承的一种实现</p>\n<ul>\n<li><p>prototype：构造函数中的属性，指向该构造函数的原型对象。</p>\n</li>\n<li><p>constructor ：原型对象中的属性，指向该原型对象的构造函数</p>\n</li>\n<li><p><em>proto</em>：实例中的属性，指向 new 这个实例的构造函数的原型对象</p>\n</li>\n</ul>\n<h3 id=\"prototype-属性的引入\"><a href=\"#prototype-属性的引入\" class=\"headerlink\" title=\"prototype 属性的引入\"></a>prototype 属性的引入</h3><p>每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个<br>prototype 属性。</p>\n<p>这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享<br>的属性及方法，就放在构造函数里面。</p>\n<p>实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是<br>引用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DOG</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">DOG.prototype = &#123; <span class=\"attr\">species</span>: <span class=\"string\">'犬科'</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dogA = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'大毛'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> dogB = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'二毛'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">alert(dogA.species)</span><br><span class=\"line\"><span class=\"comment\">// 其实是通过dogA._proto_.species 来访问DOG.prototype.species</span></span><br><span class=\"line\">alert(dogB.species)</span><br><span class=\"line\"><span class=\"comment\">// 犬科</span></span><br><span class=\"line\">DOG.prototype</span><br><span class=\"line\"><span class=\"comment\">//&#123;species:''犬科',constructor:fDOG(name),_proto_:Object&#125;</span></span><br><span class=\"line\">DOG.prototype.constructor === DOG</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。</p>\n<p><img src=\"/images/prototype/1.png\" alt=\"img\"></p>\n<p>以上就是一个简单的 DOG 类完整的原型链。</p>\n<h4 id=\"原型链的作用：对象属性的访问修改和删除。\"><a href=\"#原型链的作用：对象属性的访问修改和删除。\" class=\"headerlink\" title=\"原型链的作用：对象属性的访问修改和删除。\"></a>原型链的作用：对象属性的访问修改和删除。</h4><ul>\n<li>访问。优先在对象本身查找，没有则顺着原型链向上查找</li>\n<li>修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。</li>\n</ul>\n<h3 id=\"proto-（原型指针）\"><a href=\"#proto-（原型指针）\" class=\"headerlink\" title=\"proto （原型指针）\"></a><em>proto</em> （原型指针）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1.__proto__ == Person.prototype</span><br><span class=\"line\"><span class=\"comment\">//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person</span></span><br><span class=\"line\">Person.__proto__</span><br><span class=\"line\"><span class=\"comment\">//Person.constructor = Function =&gt; Person.__proto__  = Function.prototype</span></span><br><span class=\"line\">Person.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object =&gt; Person.prototype.__proto__ =  Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__</span><br><span class=\"line\"><span class=\"comment\">//普通对象 同上</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端</span></span><br></pre></td></tr></table></figure>\n<p>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 <em>proto</em> 的内置属性，<strong>用于指向创建它的构造函数的原型对<br>象</strong> ，原型链继承是通过 <em>proto</em> 这个原型指针来完成的</p>\n<h3 id=\"原型链图\"><a href=\"#原型链图\" class=\"headerlink\" title=\"原型链图\"></a>原型链图</h3><p>褐色的线为原型链 <img src=\"/images/prototype/2.png\" alt=\"img\"></p>\n<p>够造函数、原型和实例的关系：</p>\n<ol>\n<li>每个构造函数都有一个原型对象（x.prototype)</li>\n<li>原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)</li>\n<li>实例都包含一个指向原型对象的内部指针（a.<em>proto</em> ）</li>\n</ol>\n<p><strong> 所有函数的默认原型都是 Object 的实例</strong></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>javascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型<br>链继承 ( 挂载到 prototype 属性上面 )。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在<br>创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test () &#123;</span><br><span class=\"line\">  for (var i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">     console.log(&quot;i:&quot;+i);</span><br><span class=\"line\">    (function (e) &#123;</span><br><span class=\"line\">      setTimeout(function () &#123;</span><br><span class=\"line\">        console.log(e);</span><br><span class=\"line\">      &#125;, 0)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(); //i:0 =&gt; i:1 =&gt; i:2=&gt; i:3=&gt;  0 =&gt; 1=&gt; 2 =&gt; 3</span><br></pre></td></tr></table></figure>\n<p>循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的<br>引用，它是不会被循环改变的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'x:'</span> + x)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'y:'</span> + y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//x:5 undefined</span></span><br><span class=\"line\">add5</span><br><span class=\"line\"><span class=\"comment\">//f(y)&#123;  console.log('y:' + y) return x + y&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>)) <span class=\"comment\">// y:2 =&gt; 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)) <span class=\"comment\">// 12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放对闭包的引用</span></span><br><span class=\"line\">add5 = <span class=\"literal\">null</span></span><br><span class=\"line\">add10 = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>add5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后<br>通过 null 释放对闭包的引用。</p>\n<p>在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引<br>用，那么这两个互相引用的对象也会被回收。</p>\n<p><strong>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是摸个特殊的变量</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//作用域1</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//作用域2 声明arr[]()</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br><span class=\"line\"><span class=\"comment\">// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明</span></span><br><span class=\"line\"><span class=\"comment\">//1.执行完for之后，在for作用域中i的值为10</span></span><br></pre></td></tr></table></figure>\n<p>改动一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//块2作用域</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//块3作用域</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test() <span class=\"comment\">// 连续打印 0 到 9</span></span><br></pre></td></tr></table></figure>\n<p><strong>实现原因 :</strong></p>\n<ul>\n<li>当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr<a href=\"\">a</a>) 时 i 已经循环完毕，因此<br>i 全为 10。</li>\n</ul>\n<ul>\n<li>当使用 let 时，每次迭代 i 都被<strong>重新声明</strong>，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。</li>\n<li>var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。</li>\n</ul>\n<h3 id=\"闭包中的-this-对象\"><a href=\"#闭包中的-this-对象\" class=\"headerlink\" title=\"闭包中的 this 对象\"></a>闭包中的 this 对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'The Window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'My Object'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getName()()) <span class=\"comment\">// The Window</span></span><br></pre></td></tr></table></figure>\n<p>obj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分<br>割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><p><strong>应用闭包的主要场合是：设计私有的方法和变量。</strong><br>闭包的作用：</p>\n<ul>\n<li>访问函数的内部变量</li>\n<li>让被引用的变量值始终保存在内存中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">3</span>) <span class=\"comment\">// undefined,0,1,2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>) <span class=\"comment\">// undefined,0</span></span><br><span class=\"line\">c.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">c.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = fn1()</span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出2</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出3</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。</p>","more":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可<br>分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。</p>\n<h3 id=\"对象直接量\"><a href=\"#对象直接量\" class=\"headerlink\" title=\"对象直接量\"></a>对象直接量</h3><p>对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。<br>每次计算对象直接量的时候。也会计算它的每个属性值，<strong>也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每<br>次创建的对象的属性值也有可能不同。</strong></p>\n<h3 id=\"通过-new-创建对象\"><a href=\"#通过-new-创建对象\" class=\"headerlink\" title=\"通过 new 创建对象\"></a>通过 new 创建对象</h3><p>var obj=new MyClass(); new 运算符创建并初始化一个<strong>新对象</strong> 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向<br>MyClass.prototype</p>\n<h4 id=\"object-creat\"><a href=\"#object-creat\" class=\"headerlink\" title=\"object.creat()\"></a>object.creat()</h4><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><p>原型：每一个对象都从原型继承属性。<strong>每个对象都有 <em>proto</em> 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性</strong>,<br>但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否<br>是 o 的原型。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>原型模式是 js 对继承的一种实现</p>\n<ul>\n<li><p>prototype：构造函数中的属性，指向该构造函数的原型对象。</p>\n</li>\n<li><p>constructor ：原型对象中的属性，指向该原型对象的构造函数</p>\n</li>\n<li><p><em>proto</em>：实例中的属性，指向 new 这个实例的构造函数的原型对象</p>\n</li>\n</ul>\n<h3 id=\"prototype-属性的引入\"><a href=\"#prototype-属性的引入\" class=\"headerlink\" title=\"prototype 属性的引入\"></a>prototype 属性的引入</h3><p>每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个<br>prototype 属性。</p>\n<p>这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享<br>的属性及方法，就放在构造函数里面。</p>\n<p>实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是<br>引用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DOG</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">DOG.prototype = &#123; <span class=\"attr\">species</span>: <span class=\"string\">'犬科'</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dogA = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'大毛'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> dogB = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'二毛'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">alert(dogA.species)</span><br><span class=\"line\"><span class=\"comment\">// 其实是通过dogA._proto_.species 来访问DOG.prototype.species</span></span><br><span class=\"line\">alert(dogB.species)</span><br><span class=\"line\"><span class=\"comment\">// 犬科</span></span><br><span class=\"line\">DOG.prototype</span><br><span class=\"line\"><span class=\"comment\">//&#123;species:''犬科',constructor:fDOG(name),_proto_:Object&#125;</span></span><br><span class=\"line\">DOG.prototype.constructor === DOG</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。</p>\n<p><img src=\"/images/prototype/1.png\" alt=\"img\"></p>\n<p>以上就是一个简单的 DOG 类完整的原型链。</p>\n<h4 id=\"原型链的作用：对象属性的访问修改和删除。\"><a href=\"#原型链的作用：对象属性的访问修改和删除。\" class=\"headerlink\" title=\"原型链的作用：对象属性的访问修改和删除。\"></a>原型链的作用：对象属性的访问修改和删除。</h4><ul>\n<li>访问。优先在对象本身查找，没有则顺着原型链向上查找</li>\n<li>修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。</li>\n</ul>\n<h3 id=\"proto-（原型指针）\"><a href=\"#proto-（原型指针）\" class=\"headerlink\" title=\"proto （原型指针）\"></a><em>proto</em> （原型指针）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1.__proto__ == Person.prototype</span><br><span class=\"line\"><span class=\"comment\">//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person</span></span><br><span class=\"line\">Person.__proto__</span><br><span class=\"line\"><span class=\"comment\">//Person.constructor = Function =&gt; Person.__proto__  = Function.prototype</span></span><br><span class=\"line\">Person.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object =&gt; Person.prototype.__proto__ =  Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__</span><br><span class=\"line\"><span class=\"comment\">//普通对象 同上</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端</span></span><br></pre></td></tr></table></figure>\n<p>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 <em>proto</em> 的内置属性，<strong>用于指向创建它的构造函数的原型对<br>象</strong> ，原型链继承是通过 <em>proto</em> 这个原型指针来完成的</p>\n<h3 id=\"原型链图\"><a href=\"#原型链图\" class=\"headerlink\" title=\"原型链图\"></a>原型链图</h3><p>褐色的线为原型链 <img src=\"/images/prototype/2.png\" alt=\"img\"></p>\n<p>够造函数、原型和实例的关系：</p>\n<ol>\n<li>每个构造函数都有一个原型对象（x.prototype)</li>\n<li>原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)</li>\n<li>实例都包含一个指向原型对象的内部指针（a.<em>proto</em> ）</li>\n</ol>\n<p><strong> 所有函数的默认原型都是 Object 的实例</strong></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>javascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型<br>链继承 ( 挂载到 prototype 属性上面 )。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在<br>创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test () &#123;</span><br><span class=\"line\">  for (var i = 0; i &lt; 4; i++) &#123;</span><br><span class=\"line\">     console.log(&quot;i:&quot;+i);</span><br><span class=\"line\">    (function (e) &#123;</span><br><span class=\"line\">      setTimeout(function () &#123;</span><br><span class=\"line\">        console.log(e);</span><br><span class=\"line\">      &#125;, 0)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(); //i:0 =&gt; i:1 =&gt; i:2=&gt; i:3=&gt;  0 =&gt; 1=&gt; 2 =&gt; 3</span><br></pre></td></tr></table></figure>\n<p>循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的<br>引用，它是不会被循环改变的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'x:'</span> + x)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'y:'</span> + y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//x:5 undefined</span></span><br><span class=\"line\">add5</span><br><span class=\"line\"><span class=\"comment\">//f(y)&#123;  console.log('y:' + y) return x + y&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>)) <span class=\"comment\">// y:2 =&gt; 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)) <span class=\"comment\">// 12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放对闭包的引用</span></span><br><span class=\"line\">add5 = <span class=\"literal\">null</span></span><br><span class=\"line\">add10 = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>add5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后<br>通过 null 释放对闭包的引用。</p>\n<p>在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引<br>用，那么这两个互相引用的对象也会被回收。</p>\n<p><strong>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是摸个特殊的变量</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//作用域1</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//作用域2 声明arr[]()</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br><span class=\"line\"><span class=\"comment\">// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明</span></span><br><span class=\"line\"><span class=\"comment\">//1.执行完for之后，在for作用域中i的值为10</span></span><br></pre></td></tr></table></figure>\n<p>改动一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//块2作用域</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//块3作用域</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test() <span class=\"comment\">// 连续打印 0 到 9</span></span><br></pre></td></tr></table></figure>\n<p><strong>实现原因 :</strong></p>\n<ul>\n<li>当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr<a href=\"\">a</a>) 时 i 已经循环完毕，因此<br>i 全为 10。</li>\n</ul>\n<ul>\n<li>当使用 let 时，每次迭代 i 都被<strong>重新声明</strong>，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。</li>\n<li>var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。</li>\n</ul>\n<h3 id=\"闭包中的-this-对象\"><a href=\"#闭包中的-this-对象\" class=\"headerlink\" title=\"闭包中的 this 对象\"></a>闭包中的 this 对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'The Window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'My Object'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getName()()) <span class=\"comment\">// The Window</span></span><br></pre></td></tr></table></figure>\n<p>obj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分<br>割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><p><strong>应用闭包的主要场合是：设计私有的方法和变量。</strong><br>闭包的作用：</p>\n<ul>\n<li>访问函数的内部变量</li>\n<li>让被引用的变量值始终保存在内存中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">3</span>) <span class=\"comment\">// undefined,0,1,2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>) <span class=\"comment\">// undefined,0</span></span><br><span class=\"line\">c.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">c.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = fn1()</span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出2</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出3</span></span><br></pre></td></tr></table></figure>"},{"title":"Object.defineProperty","_content":"\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue是通过数据劫持来做数据绑定的，其中最核心的方法便是通过Ojbect.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。\n\n<!--more-->\n\n## Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\n\n在js 中我们可以通过下面几种方法定义属性:\n```javascript\n// (1) define someOne property name\nsomeOne.name = 'cover';\n//or use (2) \nsomeOne['name'] = 'cover';\n// or use (3) defineProperty\nObject.defineProperty(someOne, 'name', {\n    value : 'cover'\n})\n```\n### descriptor\n其中descriptor的参数值得我们关注下,该属性可设置的值有：value、writable、configurable、enumerable、set 和 get。\n\n####  【value】 \n该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。\n\n####  【writable】 \n\n该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n  ```javascript\n  var someOne = { };\n  Object.defineProperty(someOne, \"name\", {\n      value:\"coverguo\" , //由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化\n      writable: false \n  });  \n  console.log(someOne.name); // 输出 coverguo\n  someOne.name = \"linkzhu\";\n  console.log(someOne.name); // 输出coverguo\n  ```\n\n####  【configurable】\n仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。\n\n如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n\n#### 【enumerable】\n 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n```javascript\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  value:3445,\n  enumerable:true\n})\nconsole.log(Object.keys(a));// 打印[\"b\"]\n//改为false\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  value:3445,\n  enumerable:false //注意咯这里改了\n})\nconsole.log(Object.keys(a));// 打印[]\n```\n\n#### 注意：\n\n在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：\n  ```javascript\n  //调用Object.defineProperty()方法时，如果不指定\n  var someOne = { };\n  someOne.name = 'coverguo';\n  console.log(Object.getOwnPropertyDescriptor(someOne, 'name'));\n  //输出 Object {value: \"coverguo\", writable: true, enumerable: true, configurable: true}\n\n  //直接在对象上定义的属性，这个特性默认值为为 true\n  var otherOne = {};\n  Object.defineProperty(otherOne, \"name\", {\n      value:\"coverguo\" \n  });  \n  console.log(Object.getOwnPropertyDescriptor(otherOne, 'name'));\n  //输出 Object {value: \"coverguo\", writable: false, enumerable: false, configurable: false}\n  ```\n\n#### 【get】和【set】\n\n在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用(get 和 set)，就不能用（wriable 或 value中的任何一个）\n\n```javascript\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  set:function(newValue){\n    console.log(\"你要赋值给我,我的新值是\"＋newValue)\n    },\n  get:function(){\n    console.log(\"你取我的值\")\n    return 2 //注意这里，我硬编码返回2\n   }\n})\na.b =1 //打印 你要赋值给我,我的新值是1\nconsole.log(a.b)    //打印 你取我的值\n                    //打印 2    注意这里，和我的硬编码相同的\n```\n** 这个\"b\"赋值 或者取值的时候会分别触发set 和 get 对应的函数，这就是observe 的关键，是vue 实现 observe 的实现的基础，也是实现$watch的基础。\n\n##### 【get】\n一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。\n#####【set】 \n一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。\n\n## 兼容性\n在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。","source":"_posts/Object-defineProperty.md","raw":"---\ntitle: Object.defineProperty\ncategories: 数据劫持基石\ntags:\n---\n\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue是通过数据劫持来做数据绑定的，其中最核心的方法便是通过Ojbect.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。\n\n<!--more-->\n\n## Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\n\n在js 中我们可以通过下面几种方法定义属性:\n```javascript\n// (1) define someOne property name\nsomeOne.name = 'cover';\n//or use (2) \nsomeOne['name'] = 'cover';\n// or use (3) defineProperty\nObject.defineProperty(someOne, 'name', {\n    value : 'cover'\n})\n```\n### descriptor\n其中descriptor的参数值得我们关注下,该属性可设置的值有：value、writable、configurable、enumerable、set 和 get。\n\n####  【value】 \n该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。\n\n####  【writable】 \n\n该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n  ```javascript\n  var someOne = { };\n  Object.defineProperty(someOne, \"name\", {\n      value:\"coverguo\" , //由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化\n      writable: false \n  });  \n  console.log(someOne.name); // 输出 coverguo\n  someOne.name = \"linkzhu\";\n  console.log(someOne.name); // 输出coverguo\n  ```\n\n####  【configurable】\n仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。\n\n如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n\n#### 【enumerable】\n 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n```javascript\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  value:3445,\n  enumerable:true\n})\nconsole.log(Object.keys(a));// 打印[\"b\"]\n//改为false\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  value:3445,\n  enumerable:false //注意咯这里改了\n})\nconsole.log(Object.keys(a));// 打印[]\n```\n\n#### 注意：\n\n在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：\n  ```javascript\n  //调用Object.defineProperty()方法时，如果不指定\n  var someOne = { };\n  someOne.name = 'coverguo';\n  console.log(Object.getOwnPropertyDescriptor(someOne, 'name'));\n  //输出 Object {value: \"coverguo\", writable: true, enumerable: true, configurable: true}\n\n  //直接在对象上定义的属性，这个特性默认值为为 true\n  var otherOne = {};\n  Object.defineProperty(otherOne, \"name\", {\n      value:\"coverguo\" \n  });  \n  console.log(Object.getOwnPropertyDescriptor(otherOne, 'name'));\n  //输出 Object {value: \"coverguo\", writable: false, enumerable: false, configurable: false}\n  ```\n\n#### 【get】和【set】\n\n在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用(get 和 set)，就不能用（wriable 或 value中的任何一个）\n\n```javascript\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  set:function(newValue){\n    console.log(\"你要赋值给我,我的新值是\"＋newValue)\n    },\n  get:function(){\n    console.log(\"你取我的值\")\n    return 2 //注意这里，我硬编码返回2\n   }\n})\na.b =1 //打印 你要赋值给我,我的新值是1\nconsole.log(a.b)    //打印 你取我的值\n                    //打印 2    注意这里，和我的硬编码相同的\n```\n** 这个\"b\"赋值 或者取值的时候会分别触发set 和 get 对应的函数，这就是observe 的关键，是vue 实现 observe 的实现的基础，也是实现$watch的基础。\n\n##### 【get】\n一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。\n#####【set】 \n一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。\n\n## 兼容性\n在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。","slug":"Object-defineProperty","published":1,"date":"2018-01-15T08:18:09.885Z","updated":"2018-01-17T09:01:36.022Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7dh0004j8vrknithycp","content":"<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue是通过数据劫持来做数据绑定的，其中最核心的方法便是通过Ojbect.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。</p>\n<a id=\"more\"></a>\n<h2 id=\"Object-defineProperty-object-propertyname-descriptor-为对象定义属性\"><a href=\"#Object-defineProperty-object-propertyname-descriptor-为对象定义属性\" class=\"headerlink\" title=\"Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\"></a>Object.defineProperty(object, propertyname, descriptor) 为对象定义属性</h2><p>在js 中我们可以通过下面几种方法定义属性:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) define someOne property name</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">'cover'</span>;</span><br><span class=\"line\"><span class=\"comment\">//or use (2) </span></span><br><span class=\"line\">someOne[<span class=\"string\">'name'</span>] = <span class=\"string\">'cover'</span>;</span><br><span class=\"line\"><span class=\"comment\">// or use (3) defineProperty</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">    value : <span class=\"string\">'cover'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"descriptor\"><a href=\"#descriptor\" class=\"headerlink\" title=\"descriptor\"></a>descriptor</h3><p>其中descriptor的参数值得我们关注下,该属性可设置的值有：value、writable、configurable、enumerable、set 和 get。</p>\n<h4 id=\"【value】\"><a href=\"#【value】\" class=\"headerlink\" title=\"【value】\"></a>【value】</h4><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。</p>\n<h4 id=\"【writable】\"><a href=\"#【writable】\" class=\"headerlink\" title=\"【writable】\"></a>【writable】</h4><p>该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">    value:<span class=\"string\">\"coverguo\"</span> , <span class=\"comment\">//由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化</span></span><br><span class=\"line\">    writable: <span class=\"literal\">false</span> </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name); <span class=\"comment\">// 输出 coverguo</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">\"linkzhu\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name); <span class=\"comment\">// 输出coverguo</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"【configurable】\"><a href=\"#【configurable】\" class=\"headerlink\" title=\"【configurable】\"></a>【configurable】</h4><p>仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。</p>\n<p>如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<h4 id=\"【enumerable】\"><a href=\"#【enumerable】\" class=\"headerlink\" title=\"【enumerable】\"></a>【enumerable】</h4><p> 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  value:<span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a));<span class=\"comment\">// 打印[\"b\"]</span></span><br><span class=\"line\"><span class=\"comment\">//改为false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  value:<span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable:<span class=\"literal\">false</span> <span class=\"comment\">//注意咯这里改了</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a));<span class=\"comment\">// 打印[]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用Object.defineProperty()方法时，如果不指定</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123; &#125;;</span><br><span class=\"line\">someOne.name = <span class=\"string\">'coverguo'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(someOne, <span class=\"string\">'name'</span>));</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接在对象上定义的属性，这个特性默认值为为 true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherOne = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(otherOne, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">    value:<span class=\"string\">\"coverguo\"</span> </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(otherOne, <span class=\"string\">'name'</span>));</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"【get】和【set】\"><a href=\"#【get】和【set】\" class=\"headerlink\" title=\"【get】和【set】\"></a>【get】和【set】</h4><p>在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用(get 和 set)，就不能用（wriable 或 value中的任何一个）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  set:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你要赋值给我,我的新值是\"</span>＋newValue)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  get:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你取我的值\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">//注意这里，我硬编码返回2</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">a.b =<span class=\"number\">1</span> <span class=\"comment\">//打印 你要赋值给我,我的新值是1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.b)    <span class=\"comment\">//打印 你取我的值</span></span><br><span class=\"line\">                    <span class=\"comment\">//打印 2    注意这里，和我的硬编码相同的</span></span><br></pre></td></tr></table></figure>\n<p>** 这个”b”赋值 或者取值的时候会分别触发set 和 get 对应的函数，这就是observe 的关键，是vue 实现 observe 的实现的基础，也是实现$watch的基础。</p>\n<h5 id=\"【get】\"><a href=\"#【get】\" class=\"headerlink\" title=\"【get】\"></a>【get】</h5><p>一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。</p>\n<p>#####【set】<br>一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。</p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。</p>\n","site":{"data":{}},"excerpt":"<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue是通过数据劫持来做数据绑定的，其中最核心的方法便是通过Ojbect.defineProperty()来实现对属性的劫持，达到监听数据变动的目的。</p>","more":"<h2 id=\"Object-defineProperty-object-propertyname-descriptor-为对象定义属性\"><a href=\"#Object-defineProperty-object-propertyname-descriptor-为对象定义属性\" class=\"headerlink\" title=\"Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\"></a>Object.defineProperty(object, propertyname, descriptor) 为对象定义属性</h2><p>在js 中我们可以通过下面几种方法定义属性:<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) define someOne property name</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">'cover'</span>;</span><br><span class=\"line\"><span class=\"comment\">//or use (2) </span></span><br><span class=\"line\">someOne[<span class=\"string\">'name'</span>] = <span class=\"string\">'cover'</span>;</span><br><span class=\"line\"><span class=\"comment\">// or use (3) defineProperty</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">    value : <span class=\"string\">'cover'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"descriptor\"><a href=\"#descriptor\" class=\"headerlink\" title=\"descriptor\"></a>descriptor</h3><p>其中descriptor的参数值得我们关注下,该属性可设置的值有：value、writable、configurable、enumerable、set 和 get。</p>\n<h4 id=\"【value】\"><a href=\"#【value】\" class=\"headerlink\" title=\"【value】\"></a>【value】</h4><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。</p>\n<h4 id=\"【writable】\"><a href=\"#【writable】\" class=\"headerlink\" title=\"【writable】\"></a>【writable】</h4><p>该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123; &#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">    value:<span class=\"string\">\"coverguo\"</span> , <span class=\"comment\">//由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化</span></span><br><span class=\"line\">    writable: <span class=\"literal\">false</span> </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name); <span class=\"comment\">// 输出 coverguo</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">\"linkzhu\"</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name); <span class=\"comment\">// 输出coverguo</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"【configurable】\"><a href=\"#【configurable】\" class=\"headerlink\" title=\"【configurable】\"></a>【configurable】</h4><p>仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。</p>\n<p>如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<h4 id=\"【enumerable】\"><a href=\"#【enumerable】\" class=\"headerlink\" title=\"【enumerable】\"></a>【enumerable】</h4><p> 是否能在for-in循环中遍历出来或在Object.keys中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  value:<span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable:<span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a));<span class=\"comment\">// 打印[\"b\"]</span></span><br><span class=\"line\"><span class=\"comment\">//改为false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  value:<span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable:<span class=\"literal\">false</span> <span class=\"comment\">//注意咯这里改了</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a));<span class=\"comment\">// 打印[]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>在调用Object.defineProperty()方法时，如果不指定， configurable， enumerable， writable特性的默认值都是false,这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：<br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用Object.defineProperty()方法时，如果不指定</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123; &#125;;</span><br><span class=\"line\">someOne.name = <span class=\"string\">'coverguo'</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(someOne, <span class=\"string\">'name'</span>));</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接在对象上定义的属性，这个特性默认值为为 true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherOne = &#123;&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(otherOne, <span class=\"string\">\"name\"</span>, &#123;</span><br><span class=\"line\">    value:<span class=\"string\">\"coverguo\"</span> </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(otherOne, <span class=\"string\">'name'</span>));</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"【get】和【set】\"><a href=\"#【get】和【set】\" class=\"headerlink\" title=\"【get】和【set】\"></a>【get】和【set】</h4><p>在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用(get 和 set)，就不能用（wriable 或 value中的任何一个）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  set:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你要赋值给我,我的新值是\"</span>＋newValue)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  get:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你取我的值\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">//注意这里，我硬编码返回2</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">a.b =<span class=\"number\">1</span> <span class=\"comment\">//打印 你要赋值给我,我的新值是1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.b)    <span class=\"comment\">//打印 你取我的值</span></span><br><span class=\"line\">                    <span class=\"comment\">//打印 2    注意这里，和我的硬编码相同的</span></span><br></pre></td></tr></table></figure>\n<p>** 这个”b”赋值 或者取值的时候会分别触发set 和 get 对应的函数，这就是observe 的关键，是vue 实现 observe 的实现的基础，也是实现$watch的基础。</p>\n<h5 id=\"【get】\"><a href=\"#【get】\" class=\"headerlink\" title=\"【get】\"></a>【get】</h5><p>一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。</p>\n<p>#####【set】<br>一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。</p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>在ie8下只能在DOM对象上使用，尝试在原生的对象使用 Object.defineProperty()会报错。</p>"},{"title":"PWA 离线缓存","_content":"## PWA (Progressive Web App) 特点\n1. installability(可安装性)，可被添加自主屏与全屏运行。\n2. app shell:第一次渲染个壳，等异步数据来了在填充。\n3. offline(离线能力)：离线和弱网环境也能秒开，server worker给了web一个可以跑后台的线程，它可以搭配非常靠谱的cache Api做缓存、可以拦截所有Http请求并使用Fetch API进行response ，一个非常完备哦的proxy就这么诞生了\n4. re-engageable：推送通知的能力，依赖service Worker 与http push，不过默认支持的可是GCM\n5. 推送是指服务器向服务工作线程提供信息的操作\n6. 通知是指服务工作线程或网页脚本向用户信息的操作。\n\n<!--more-->\n\n## service Worker 有以下功能和特性\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n- 一旦被 install，就永远存在，除非被 uninstall\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n- 离线内容开发者可控\n- 能向客户端推送消息\n- 不能直接操作 DOM\n- 出于安全的考虑，必须在 HTTPS 环境下才能工作\n- 异步实现，内部大都是通过 Promise 实现\n\n#### service Worker前提条件\n\n- 要求HTTPS的环境\n- 缓存机制是依赖cache API 实现的\n- 依赖HTML5 fetchAPI\n- 依赖Promise\n\n#### 注册\n```javascript\n      if ('serviceWorker' in navigator) {\n            navigator.serviceWorker\n                .register('./pwa/sw.js', {scope: '/pwa'})\n                /* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否\n                 已注册，并作出相应的处理*/\n                /* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受\n                 scope指定网域目录上所有事项的fetch事件。\n                 scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能\n                 捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/\n                .then(function (registration) {\n                    console.log('Service Worker 注册成功，域名: ', registration.scope);\n                })\n                .catch(function (err) {\n                    console.log('Service Worker 注册失败: ', err);\n                });\n\n        }\n        ```\n\n#### 安装\n\ninstall事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。**install事件一般是被用来填充你的浏览器的离线缓存能力。**为了达到这个目的，我们使用了service worker 新的标志性的存储**cache API** ——一个service worker上的全局对象，**它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key。**这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。\n\n```javascript\n    self.addEventListener('install', function (e) {\n        console.log('[ServiceWorker] Install');\n        /*ExtendableEvent.waitUntil():\n         延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。\n         当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，\n         直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/\n        e.waitUntil(\n            caches.open(chache_name).then(function (cache) {\n                console.log('[ServiceWorker] Caching app shell');\n                console.log(cache);\n                return cache.addAll(filesToCache);\n            })\n        );\n    });\n    /*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法\n      这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/\n    /*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,\n      当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，\n      这个数组就是你想缓存的资源的列表*/\n      ```\n\n#### 自定义请求响应\n``` javascript\n    self.addEventListener('fetch', function (e) {\n     console.log('[service worker] fetch',e.request.url);\n    /*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/\n        e.resondWith(\n            caches.match(e.request).then(function () {\n                //如果sw有自己的返回，就直接返回，减少一次http请求。\n               if (response) {\n                   return response;\n               }\n\n               //如果没有返回，就直接请求真实远程服务\n                var request = e.request.clone(); //拷贝原始请求\n                //clone()允许多次请求body()对象。\n                return fetch(request).then(function (httpRes) {\n                   //http请求的返回已经抓到，可以进行设置\n\n                    //请求失败，直接返回失败的结果\n                    if(!httpRes||httpRes.status!==200){\n                        return httpRes;\n                    }\n                    //  请求成功，将请求缓存\n                    var responseClone = httpRes.clone();\n                    caches.open(cache_name).then(function (cache) {\n                        cache.put(e.request,responseClone);\n                    });\n                    return httpRes;\n                });\n\n            })\n        );\n\n    });\n    /*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的\n      html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/\n      ```\n\n我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:\n\n- on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。\n- on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。\n\n#### Service Worker 生命周期 （也许翻译的不好，尽量去看原文）\n\n- installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.\n    - 用 **event.waitUntil()** 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。\n    - 用 **self.skipWaiting()** self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。\n- installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。\n- activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。\n- activated:现在可以处理方法事件。\n- message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。\n\n## manifest.json\npwa 添加至桌面的功能实现依赖于manifest.json。\n\n#### 基本功能\n- name:{string} 应用名称，用于安装横幅、启动画面显示\n- short_name:{string} 应用短名称，用于主屏幕显示\n- icon:img 应用图标列表，其中包括:\n    - src:{string}  图标URL\n    - type:图标的mime 类型\n    - size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。\n- start_url:{string=} 应用启动地址\n- background_color:{color} css色值\n- display: {string} 显示类型\n    - fullScreen: 应用的显示界面将占满整个屏幕\n    - standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏\n    - minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\n    - browser: 浏览器模式，与普通网页在浏览器中打开的显示一致\n- orientation: string 应用显示方向\n- theme_color: 主题颜色\n\n#### 设置作用域\n\n- 如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；\n- **start_url 必须在作用域范围之内**;\n- 如果start_url 为相对地址，其根路径收scope所影响;\n- 如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；\n\n#### 添加启动动画\n\n当PWA添加到主屏幕点击打开时，幕后执行了若干操作：\n1. 启动浏览器\n2. 启动显示页面的渲染器\n3. 加载资源\n\n在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。\n\n目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。\n\n\n\n\n\n","source":"_posts/PWA-offline.md","raw":"---\ntitle: PWA 离线缓存\ncategories: PWA\n---\n## PWA (Progressive Web App) 特点\n1. installability(可安装性)，可被添加自主屏与全屏运行。\n2. app shell:第一次渲染个壳，等异步数据来了在填充。\n3. offline(离线能力)：离线和弱网环境也能秒开，server worker给了web一个可以跑后台的线程，它可以搭配非常靠谱的cache Api做缓存、可以拦截所有Http请求并使用Fetch API进行response ，一个非常完备哦的proxy就这么诞生了\n4. re-engageable：推送通知的能力，依赖service Worker 与http push，不过默认支持的可是GCM\n5. 推送是指服务器向服务工作线程提供信息的操作\n6. 通知是指服务工作线程或网页脚本向用户信息的操作。\n\n<!--more-->\n\n## service Worker 有以下功能和特性\n- 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n- 一旦被 install，就永远存在，除非被 uninstall\n- 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n- 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n- 离线内容开发者可控\n- 能向客户端推送消息\n- 不能直接操作 DOM\n- 出于安全的考虑，必须在 HTTPS 环境下才能工作\n- 异步实现，内部大都是通过 Promise 实现\n\n#### service Worker前提条件\n\n- 要求HTTPS的环境\n- 缓存机制是依赖cache API 实现的\n- 依赖HTML5 fetchAPI\n- 依赖Promise\n\n#### 注册\n```javascript\n      if ('serviceWorker' in navigator) {\n            navigator.serviceWorker\n                .register('./pwa/sw.js', {scope: '/pwa'})\n                /* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否\n                 已注册，并作出相应的处理*/\n                /* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受\n                 scope指定网域目录上所有事项的fetch事件。\n                 scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能\n                 捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/\n                .then(function (registration) {\n                    console.log('Service Worker 注册成功，域名: ', registration.scope);\n                })\n                .catch(function (err) {\n                    console.log('Service Worker 注册失败: ', err);\n                });\n\n        }\n        ```\n\n#### 安装\n\ninstall事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。**install事件一般是被用来填充你的浏览器的离线缓存能力。**为了达到这个目的，我们使用了service worker 新的标志性的存储**cache API** ——一个service worker上的全局对象，**它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key。**这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。\n\n```javascript\n    self.addEventListener('install', function (e) {\n        console.log('[ServiceWorker] Install');\n        /*ExtendableEvent.waitUntil():\n         延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。\n         当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，\n         直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/\n        e.waitUntil(\n            caches.open(chache_name).then(function (cache) {\n                console.log('[ServiceWorker] Caching app shell');\n                console.log(cache);\n                return cache.addAll(filesToCache);\n            })\n        );\n    });\n    /*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法\n      这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/\n    /*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,\n      当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，\n      这个数组就是你想缓存的资源的列表*/\n      ```\n\n#### 自定义请求响应\n``` javascript\n    self.addEventListener('fetch', function (e) {\n     console.log('[service worker] fetch',e.request.url);\n    /*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/\n        e.resondWith(\n            caches.match(e.request).then(function () {\n                //如果sw有自己的返回，就直接返回，减少一次http请求。\n               if (response) {\n                   return response;\n               }\n\n               //如果没有返回，就直接请求真实远程服务\n                var request = e.request.clone(); //拷贝原始请求\n                //clone()允许多次请求body()对象。\n                return fetch(request).then(function (httpRes) {\n                   //http请求的返回已经抓到，可以进行设置\n\n                    //请求失败，直接返回失败的结果\n                    if(!httpRes||httpRes.status!==200){\n                        return httpRes;\n                    }\n                    //  请求成功，将请求缓存\n                    var responseClone = httpRes.clone();\n                    caches.open(cache_name).then(function (cache) {\n                        cache.put(e.request,responseClone);\n                    });\n                    return httpRes;\n                });\n\n            })\n        );\n\n    });\n    /*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的\n      html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/\n      ```\n\n我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:\n\n- on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。\n- on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。\n\n#### Service Worker 生命周期 （也许翻译的不好，尽量去看原文）\n\n- installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.\n    - 用 **event.waitUntil()** 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。\n    - 用 **self.skipWaiting()** self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。\n- installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。\n- activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。\n- activated:现在可以处理方法事件。\n- message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。\n\n## manifest.json\npwa 添加至桌面的功能实现依赖于manifest.json。\n\n#### 基本功能\n- name:{string} 应用名称，用于安装横幅、启动画面显示\n- short_name:{string} 应用短名称，用于主屏幕显示\n- icon:img 应用图标列表，其中包括:\n    - src:{string}  图标URL\n    - type:图标的mime 类型\n    - size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。\n- start_url:{string=} 应用启动地址\n- background_color:{color} css色值\n- display: {string} 显示类型\n    - fullScreen: 应用的显示界面将占满整个屏幕\n    - standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏\n    - minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\n    - browser: 浏览器模式，与普通网页在浏览器中打开的显示一致\n- orientation: string 应用显示方向\n- theme_color: 主题颜色\n\n#### 设置作用域\n\n- 如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；\n- **start_url 必须在作用域范围之内**;\n- 如果start_url 为相对地址，其根路径收scope所影响;\n- 如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；\n\n#### 添加启动动画\n\n当PWA添加到主屏幕点击打开时，幕后执行了若干操作：\n1. 启动浏览器\n2. 启动显示页面的渲染器\n3. 加载资源\n\n在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。\n\n目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。\n\n\n\n\n\n","slug":"PWA-offline","published":1,"date":"2018-01-15T08:18:09.889Z","updated":"2017-12-29T07:06:49.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7dk0005j8vrd5zbg16f","content":"<h2 id=\"PWA-Progressive-Web-App-特点\"><a href=\"#PWA-Progressive-Web-App-特点\" class=\"headerlink\" title=\"PWA (Progressive Web App) 特点\"></a>PWA (Progressive Web App) 特点</h2><ol>\n<li>installability(可安装性)，可被添加自主屏与全屏运行。</li>\n<li>app shell:第一次渲染个壳，等异步数据来了在填充。</li>\n<li>offline(离线能力)：离线和弱网环境也能秒开，server worker给了web一个可以跑后台的线程，它可以搭配非常靠谱的cache Api做缓存、可以拦截所有Http请求并使用Fetch API进行response ，一个非常完备哦的proxy就这么诞生了</li>\n<li>re-engageable：推送通知的能力，依赖service Worker 与http push，不过默认支持的可是GCM</li>\n<li>推送是指服务器向服务工作线程提供信息的操作</li>\n<li>通知是指服务工作线程或网页脚本向用户信息的操作。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"service-Worker-有以下功能和特性\"><a href=\"#service-Worker-有以下功能和特性\" class=\"headerlink\" title=\"service Worker 有以下功能和特性\"></a>service Worker 有以下功能和特性</h2><ul>\n<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>\n<li>一旦被 install，就永远存在，除非被 uninstall</li>\n<li>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</li>\n<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</li>\n<li>离线内容开发者可控</li>\n<li>能向客户端推送消息</li>\n<li>不能直接操作 DOM</li>\n<li>出于安全的考虑，必须在 HTTPS 环境下才能工作</li>\n<li>异步实现，内部大都是通过 Promise 实现</li>\n</ul>\n<h4 id=\"service-Worker前提条件\"><a href=\"#service-Worker前提条件\" class=\"headerlink\" title=\"service Worker前提条件\"></a>service Worker前提条件</h4><ul>\n<li>要求HTTPS的环境</li>\n<li>缓存机制是依赖cache API 实现的</li>\n<li>依赖HTML5 fetchAPI</li>\n<li>依赖Promise</li>\n</ul>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">      navigator.serviceWorker</span><br><span class=\"line\">          .register(<span class=\"string\">'./pwa/sw.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'/pwa'</span>&#125;)</span><br><span class=\"line\">          <span class=\"comment\">/* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否</span></span><br><span class=\"line\"><span class=\"comment\">           已注册，并作出相应的处理*/</span></span><br><span class=\"line\">          <span class=\"comment\">/* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受</span></span><br><span class=\"line\"><span class=\"comment\">           scope指定网域目录上所有事项的fetch事件。</span></span><br><span class=\"line\"><span class=\"comment\">           scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能</span></span><br><span class=\"line\"><span class=\"comment\">           捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/</span></span><br><span class=\"line\">          .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册成功，域名: '</span>, registration.scope);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册失败: '</span>, err);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>install事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。<strong>install事件一般是被用来填充你的浏览器的离线缓存能力。</strong>为了达到这个目的，我们使用了service worker 新的标志性的存储<strong>cache API</strong> ——一个service worker上的全局对象，<strong>它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key。</strong>这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Install'</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*ExtendableEvent.waitUntil():</span></span><br><span class=\"line\"><span class=\"comment\">     延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。</span></span><br><span class=\"line\"><span class=\"comment\">     当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，</span></span><br><span class=\"line\"><span class=\"comment\">     直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/</span></span><br><span class=\"line\">    e.waitUntil(</span><br><span class=\"line\">        caches.open(chache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Caching app shell'</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(cache);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.addAll(filesToCache);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法</span></span><br><span class=\"line\"><span class=\"comment\">  这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/</span></span><br><span class=\"line\"><span class=\"comment\">/*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,</span></span><br><span class=\"line\"><span class=\"comment\">  当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，</span></span><br><span class=\"line\"><span class=\"comment\">  这个数组就是你想缓存的资源的列表*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义请求响应\"><a href=\"#自定义请求响应\" class=\"headerlink\" title=\"自定义请求响应\"></a>自定义请求响应</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'[service worker] fetch'</span>,e.request.url);</span><br><span class=\"line\"><span class=\"comment\">/*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/</span></span><br><span class=\"line\">    e.resondWith(</span><br><span class=\"line\">        caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果sw有自己的返回，就直接返回，减少一次http请求。</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (response) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//如果没有返回，就直接请求真实远程服务</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> request = e.request.clone(); <span class=\"comment\">//拷贝原始请求</span></span><br><span class=\"line\">            <span class=\"comment\">//clone()允许多次请求body()对象。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fetch(request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">httpRes</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"comment\">//http请求的返回已经抓到，可以进行设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//请求失败，直接返回失败的结果</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!httpRes||httpRes.status!==<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//  请求成功，将请求缓存</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> responseClone = httpRes.clone();</span><br><span class=\"line\">                caches.open(cache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                    cache.put(e.request,responseClone);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的</span></span><br><span class=\"line\"><span class=\"comment\">  html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/</span></span><br></pre></td></tr></table></figure>\n<p>我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:</p>\n<ul>\n<li>on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。</li>\n<li>on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。</li>\n</ul>\n<h4 id=\"Service-Worker-生命周期-（也许翻译的不好，尽量去看原文）\"><a href=\"#Service-Worker-生命周期-（也许翻译的不好，尽量去看原文）\" class=\"headerlink\" title=\"Service Worker 生命周期 （也许翻译的不好，尽量去看原文）\"></a>Service Worker 生命周期 （也许翻译的不好，尽量去看原文）</h4><ul>\n<li>installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.<ul>\n<li>用 <strong>event.waitUntil()</strong> 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。</li>\n<li>用 <strong>self.skipWaiting()</strong> self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。</li>\n</ul>\n</li>\n<li>installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。</li>\n<li>activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。</li>\n<li>activated:现在可以处理方法事件。</li>\n<li>message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。</li>\n</ul>\n<h2 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h2><p>pwa 添加至桌面的功能实现依赖于manifest.json。</p>\n<h4 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h4><ul>\n<li>name:{string} 应用名称，用于安装横幅、启动画面显示</li>\n<li>short_name:{string} 应用短名称，用于主屏幕显示</li>\n<li>icon:img 应用图标列表，其中包括:<ul>\n<li>src:{string}  图标URL</li>\n<li>type:图标的mime 类型</li>\n<li>size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。</li>\n</ul>\n</li>\n<li>start_url:{string=} 应用启动地址</li>\n<li>background_color:{color} css色值</li>\n<li>display: {string} 显示类型<ul>\n<li>fullScreen: 应用的显示界面将占满整个屏幕</li>\n<li>standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏</li>\n<li>minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同</li>\n<li>browser: 浏览器模式，与普通网页在浏览器中打开的显示一致</li>\n</ul>\n</li>\n<li>orientation: string 应用显示方向</li>\n<li>theme_color: 主题颜色</li>\n</ul>\n<h4 id=\"设置作用域\"><a href=\"#设置作用域\" class=\"headerlink\" title=\"设置作用域\"></a>设置作用域</h4><ul>\n<li>如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；</li>\n<li><strong>start_url 必须在作用域范围之内</strong>;</li>\n<li>如果start_url 为相对地址，其根路径收scope所影响;</li>\n<li>如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；</li>\n</ul>\n<h4 id=\"添加启动动画\"><a href=\"#添加启动动画\" class=\"headerlink\" title=\"添加启动动画\"></a>添加启动动画</h4><p>当PWA添加到主屏幕点击打开时，幕后执行了若干操作：</p>\n<ol>\n<li>启动浏览器</li>\n<li>启动显示页面的渲染器</li>\n<li>加载资源</li>\n</ol>\n<p>在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。</p>\n<p>目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"PWA-Progressive-Web-App-特点\"><a href=\"#PWA-Progressive-Web-App-特点\" class=\"headerlink\" title=\"PWA (Progressive Web App) 特点\"></a>PWA (Progressive Web App) 特点</h2><ol>\n<li>installability(可安装性)，可被添加自主屏与全屏运行。</li>\n<li>app shell:第一次渲染个壳，等异步数据来了在填充。</li>\n<li>offline(离线能力)：离线和弱网环境也能秒开，server worker给了web一个可以跑后台的线程，它可以搭配非常靠谱的cache Api做缓存、可以拦截所有Http请求并使用Fetch API进行response ，一个非常完备哦的proxy就这么诞生了</li>\n<li>re-engageable：推送通知的能力，依赖service Worker 与http push，不过默认支持的可是GCM</li>\n<li>推送是指服务器向服务工作线程提供信息的操作</li>\n<li>通知是指服务工作线程或网页脚本向用户信息的操作。</li>\n</ol>","more":"<h2 id=\"service-Worker-有以下功能和特性\"><a href=\"#service-Worker-有以下功能和特性\" class=\"headerlink\" title=\"service Worker 有以下功能和特性\"></a>service Worker 有以下功能和特性</h2><ul>\n<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>\n<li>一旦被 install，就永远存在，除非被 uninstall</li>\n<li>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</li>\n<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</li>\n<li>离线内容开发者可控</li>\n<li>能向客户端推送消息</li>\n<li>不能直接操作 DOM</li>\n<li>出于安全的考虑，必须在 HTTPS 环境下才能工作</li>\n<li>异步实现，内部大都是通过 Promise 实现</li>\n</ul>\n<h4 id=\"service-Worker前提条件\"><a href=\"#service-Worker前提条件\" class=\"headerlink\" title=\"service Worker前提条件\"></a>service Worker前提条件</h4><ul>\n<li>要求HTTPS的环境</li>\n<li>缓存机制是依赖cache API 实现的</li>\n<li>依赖HTML5 fetchAPI</li>\n<li>依赖Promise</li>\n</ul>\n<h4 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">      navigator.serviceWorker</span><br><span class=\"line\">          .register(<span class=\"string\">'./pwa/sw.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'/pwa'</span>&#125;)</span><br><span class=\"line\">          <span class=\"comment\">/* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否</span></span><br><span class=\"line\"><span class=\"comment\">           已注册，并作出相应的处理*/</span></span><br><span class=\"line\">          <span class=\"comment\">/* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受</span></span><br><span class=\"line\"><span class=\"comment\">           scope指定网域目录上所有事项的fetch事件。</span></span><br><span class=\"line\"><span class=\"comment\">           scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能</span></span><br><span class=\"line\"><span class=\"comment\">           捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/</span></span><br><span class=\"line\">          .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册成功，域名: '</span>, registration.scope);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">          .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">              <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册失败: '</span>, err);</span><br><span class=\"line\">          &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>install事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。<strong>install事件一般是被用来填充你的浏览器的离线缓存能力。</strong>为了达到这个目的，我们使用了service worker 新的标志性的存储<strong>cache API</strong> ——一个service worker上的全局对象，<strong>它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key。</strong>这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Install'</span>);</span><br><span class=\"line\">    <span class=\"comment\">/*ExtendableEvent.waitUntil():</span></span><br><span class=\"line\"><span class=\"comment\">     延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。</span></span><br><span class=\"line\"><span class=\"comment\">     当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，</span></span><br><span class=\"line\"><span class=\"comment\">     直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/</span></span><br><span class=\"line\">    e.waitUntil(</span><br><span class=\"line\">        caches.open(chache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Caching app shell'</span>);</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(cache);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> cache.addAll(filesToCache);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法</span></span><br><span class=\"line\"><span class=\"comment\">  这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/</span></span><br><span class=\"line\"><span class=\"comment\">/*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,</span></span><br><span class=\"line\"><span class=\"comment\">  当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，</span></span><br><span class=\"line\"><span class=\"comment\">  这个数组就是你想缓存的资源的列表*/</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义请求响应\"><a href=\"#自定义请求响应\" class=\"headerlink\" title=\"自定义请求响应\"></a>自定义请求响应</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\"> <span class=\"built_in\">console</span>.log(<span class=\"string\">'[service worker] fetch'</span>,e.request.url);</span><br><span class=\"line\"><span class=\"comment\">/*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/</span></span><br><span class=\"line\">    e.resondWith(</span><br><span class=\"line\">        caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果sw有自己的返回，就直接返回，减少一次http请求。</span></span><br><span class=\"line\">           <span class=\"keyword\">if</span> (response) &#123;</span><br><span class=\"line\">               <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">           &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">           <span class=\"comment\">//如果没有返回，就直接请求真实远程服务</span></span><br><span class=\"line\">            <span class=\"keyword\">var</span> request = e.request.clone(); <span class=\"comment\">//拷贝原始请求</span></span><br><span class=\"line\">            <span class=\"comment\">//clone()允许多次请求body()对象。</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> fetch(request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">httpRes</span>) </span>&#123;</span><br><span class=\"line\">               <span class=\"comment\">//http请求的返回已经抓到，可以进行设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//请求失败，直接返回失败的结果</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!httpRes||httpRes.status!==<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//  请求成功，将请求缓存</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> responseClone = httpRes.clone();</span><br><span class=\"line\">                caches.open(cache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                    cache.put(e.request,responseClone);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    );</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">/*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的</span></span><br><span class=\"line\"><span class=\"comment\">  html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/</span></span><br></pre></td></tr></table></figure>\n<p>我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:</p>\n<ul>\n<li>on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。</li>\n<li>on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。</li>\n</ul>\n<h4 id=\"Service-Worker-生命周期-（也许翻译的不好，尽量去看原文）\"><a href=\"#Service-Worker-生命周期-（也许翻译的不好，尽量去看原文）\" class=\"headerlink\" title=\"Service Worker 生命周期 （也许翻译的不好，尽量去看原文）\"></a>Service Worker 生命周期 （也许翻译的不好，尽量去看原文）</h4><ul>\n<li>installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.<ul>\n<li>用 <strong>event.waitUntil()</strong> 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。</li>\n<li>用 <strong>self.skipWaiting()</strong> self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。</li>\n</ul>\n</li>\n<li>installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。</li>\n<li>activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。</li>\n<li>activated:现在可以处理方法事件。</li>\n<li>message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。</li>\n</ul>\n<h2 id=\"manifest-json\"><a href=\"#manifest-json\" class=\"headerlink\" title=\"manifest.json\"></a>manifest.json</h2><p>pwa 添加至桌面的功能实现依赖于manifest.json。</p>\n<h4 id=\"基本功能\"><a href=\"#基本功能\" class=\"headerlink\" title=\"基本功能\"></a>基本功能</h4><ul>\n<li>name:{string} 应用名称，用于安装横幅、启动画面显示</li>\n<li>short_name:{string} 应用短名称，用于主屏幕显示</li>\n<li>icon:img 应用图标列表，其中包括:<ul>\n<li>src:{string}  图标URL</li>\n<li>type:图标的mime 类型</li>\n<li>size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。</li>\n</ul>\n</li>\n<li>start_url:{string=} 应用启动地址</li>\n<li>background_color:{color} css色值</li>\n<li>display: {string} 显示类型<ul>\n<li>fullScreen: 应用的显示界面将占满整个屏幕</li>\n<li>standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏</li>\n<li>minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同</li>\n<li>browser: 浏览器模式，与普通网页在浏览器中打开的显示一致</li>\n</ul>\n</li>\n<li>orientation: string 应用显示方向</li>\n<li>theme_color: 主题颜色</li>\n</ul>\n<h4 id=\"设置作用域\"><a href=\"#设置作用域\" class=\"headerlink\" title=\"设置作用域\"></a>设置作用域</h4><ul>\n<li>如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；</li>\n<li><strong>start_url 必须在作用域范围之内</strong>;</li>\n<li>如果start_url 为相对地址，其根路径收scope所影响;</li>\n<li>如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；</li>\n</ul>\n<h4 id=\"添加启动动画\"><a href=\"#添加启动动画\" class=\"headerlink\" title=\"添加启动动画\"></a>添加启动动画</h4><p>当PWA添加到主屏幕点击打开时，幕后执行了若干操作：</p>\n<ol>\n<li>启动浏览器</li>\n<li>启动显示页面的渲染器</li>\n<li>加载资源</li>\n</ol>\n<p>在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。</p>\n<p>目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。</p>"},{"title":"Observable","_content":"\n观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer）完美的将观察者和被观察的对象分离开。\n\n\n\n<!--more-->\n\nObservable只是一个普通函数，要想让他有所作为，就需要跟observer一起使用；而这个observer（后面我们会介绍）只是一个带有 next、error、complete 的简单对象而已。最后，还需要通过 subscribe 订阅来\n**启动** Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在RxJS里叫 unsubscribe）。\n\n- Observer Pattern - (观察者模式/发布订阅模式)\n- Iterator Pattern - (迭代器模式)\n\n这两种模式是Observable的基础。\n\n\n\n## 观察者模式\n一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。\n\nObservables 与 Observer 之间的订阅发布关系(观察者模式) 如下：\n\n- 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。\n- 发布：Observable 通过回调 next 方法向 Observer 发布事件。\n\n\n当Observable设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是DOM中的 click 事件、input 事件、或者更加复杂的HTTP通信。\n\n```javascript\nimport { Component } from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-home',\n  template: `<input type=\"text\"> `\n})\nexport class HomeComponent {\n  ngOnInit() {\n    const node = document.querySelector('input[type=text]');\n\n    // 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入\n    const input$ = Observable.fromEvent(node, 'input');\n    input$.subscribe({\n      next: (event: any) => console.log(`You just typed ${event.target.value}!`),\n      error: (err) => console.log(`Oops... ${err}`),\n      complete: () => console.log(`Complete!`)\n    });\n  }\n}\n```\n**Observable.fromEvent() 会返回一个Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的observer观察者。**\n\n## 一、observer\n\n**subscribe订阅就是接收一个observer 方法。**\n\n```javascript\n    input$.subscribe((event: any) => {\n    });\n```\n\n从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当Observable产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。\n\n当Observable被订阅后，除非调用observer的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。\n\nObservable的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式operator来完成的，每一个operator都会产生一个新的Observable。而我们也称这一序列过程为：**流**。\n\n--------------------------------\n## 二、operator\nObservable可以链式写法，这意味着我们可以这样：\n\n```javascript\n    Observable.fromEvent(node, 'input')\n    .map((event: any) => event.target.value)\n    .filter(value => value.length >= 2)\n    .subscribe(value => { console.log(value); });\n```\n下面是顺序步骤：\n- 假设用户输入：a\n- Observable对触发 oninput 事件作出反应，将值以参数的形式传递给observer的 next()。\n- map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个observer。\n- filter() 如果值长度 >=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个observer。\n- 最后，将结果传递给 subscribe 订阅块。\n\n#### 取消订阅 \n\nObservable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在Angular里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在SPA世界里懂得擦屁股是一件必须的事。\n\n##### unsubscribe\n前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。\n\n```javascript\n    ngOnDestroy() {\n        this.inputSubscription.unsubscribe();\n    }\n```\n\n##### takeWhile\n\n如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：\n\n使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。\n\n```javascript\nprivate alive: boolean = true;\nngOnInit() {\n  const node = document.querySelector('input[type=text]');\n\n  this.s = Observable.fromEvent(node, 'input')\n    .takeWhile(() => this.alive)\n    .map((event: any) => event.target.value)\n    .filter(value => value.length >= 2)\n    .subscribe(value => { console.log(value) });\n}\n\nngOnDestroy() {\n  this.alive = false;\n}\n```\n\n## Subject\n\n我们在写一个Service用于数据传递时，总是使用 new Subject。\n```javascript\n@Injectable()\nexport class MessageService {\n    private subject = new Subject<any>();\n\n    send(message: any) {\n        this.subject.next(message);\n    }\n\n    get(): Observable<any> {\n        return this.subject.asObservable();\n    }\n}\n```\n当F组件需要向M组件传递数据时，我们可以在F组件中使用send()。\n\n```javascript\n\n    constructor(public srv: MessageService) { }\n\n    ngOnInit() {\n        this.srv.send('w s k f m?')\n    }\n```\n\n而M组件只需要订阅内容就行：\n\n```javascript\n    constructor(private srv: MessageService) {}\n\n    message: any;\n    ngOnInit() {\n        this.srv.get().subscribe((result) => {\n            this.message = result;\n        })\n    }\n```\n\n## EventEmitter\n\n其实EventEmitter跟RxJS没有直接关系，因为他是Angular的产物，而非RxJS的东西。或者我们压根没必要去谈，因为EventEmitter就是Subject。\n\n**EventEmitter的作用是使指令或组件能自定义事件。**\n\n```javascript\n@Output() changed = new EventEmitter<string>();\n\nclick() {\n    this.changed.emit('hi~');\n}\n```\n\n```javascript\n@Component({\n  template: `<comp (changed)=\"subscribe($event)\"></comp>`\n})\nexport class HomeComponent {\n  subscribe(message: string) {\n     // 接收：hi~\n  }\n}\n```\n\n上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。\n\n## 结论\n\n#### 创建数据流：\n\n- 单值：of, empty, never\n- 多值：from\n- 定时：interval, timer\n- 从事件创建：fromEvent\n- 从Promise创建：fromPromise\n- 自定义创建：create\n\n#### 转换操作：\n\n- 改变数据形态：map, mapTo, pluck\n- 过滤一些值：filter, skip, first, last, take\n- 时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime\n- 累加：reduce, scan\n- 异常处理：throw, catch, retry, finally\n- 条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn\n- 转接：switch\n\n#### 组合数据流：\n\n- concat，保持原来的序列顺序连接两个数据流\n- merge，合并序列\n- race，预设条件为其中一个数据流完成\n- forkJoin，预设条件为所有数据流都完成\n- zip，取各来源数据流最后一个值合并为对象\n- combineLatest，取各来源数据流最后一个值合并为数组\n另，最好使用 $ 结尾的命名方式来表示Observable，例：input$。\n\n\n","source":"_posts/Observable.md","raw":"---\ntitle: Observable\ncategories: rx.js\n---\n\n观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer）完美的将观察者和被观察的对象分离开。\n\n\n\n<!--more-->\n\nObservable只是一个普通函数，要想让他有所作为，就需要跟observer一起使用；而这个observer（后面我们会介绍）只是一个带有 next、error、complete 的简单对象而已。最后，还需要通过 subscribe 订阅来\n**启动** Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在RxJS里叫 unsubscribe）。\n\n- Observer Pattern - (观察者模式/发布订阅模式)\n- Iterator Pattern - (迭代器模式)\n\n这两种模式是Observable的基础。\n\n\n\n## 观察者模式\n一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。\n\nObservables 与 Observer 之间的订阅发布关系(观察者模式) 如下：\n\n- 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。\n- 发布：Observable 通过回调 next 方法向 Observer 发布事件。\n\n\n当Observable设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是DOM中的 click 事件、input 事件、或者更加复杂的HTTP通信。\n\n```javascript\nimport { Component } from '@angular/core';\nimport { Observable, Subscription } from 'rxjs';\n\n@Component({\n  selector: 'app-home',\n  template: `<input type=\"text\"> `\n})\nexport class HomeComponent {\n  ngOnInit() {\n    const node = document.querySelector('input[type=text]');\n\n    // 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入\n    const input$ = Observable.fromEvent(node, 'input');\n    input$.subscribe({\n      next: (event: any) => console.log(`You just typed ${event.target.value}!`),\n      error: (err) => console.log(`Oops... ${err}`),\n      complete: () => console.log(`Complete!`)\n    });\n  }\n}\n```\n**Observable.fromEvent() 会返回一个Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的observer观察者。**\n\n## 一、observer\n\n**subscribe订阅就是接收一个observer 方法。**\n\n```javascript\n    input$.subscribe((event: any) => {\n    });\n```\n\n从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当Observable产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。\n\n当Observable被订阅后，除非调用observer的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。\n\nObservable的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式operator来完成的，每一个operator都会产生一个新的Observable。而我们也称这一序列过程为：**流**。\n\n--------------------------------\n## 二、operator\nObservable可以链式写法，这意味着我们可以这样：\n\n```javascript\n    Observable.fromEvent(node, 'input')\n    .map((event: any) => event.target.value)\n    .filter(value => value.length >= 2)\n    .subscribe(value => { console.log(value); });\n```\n下面是顺序步骤：\n- 假设用户输入：a\n- Observable对触发 oninput 事件作出反应，将值以参数的形式传递给observer的 next()。\n- map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个observer。\n- filter() 如果值长度 >=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个observer。\n- 最后，将结果传递给 subscribe 订阅块。\n\n#### 取消订阅 \n\nObservable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在Angular里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在SPA世界里懂得擦屁股是一件必须的事。\n\n##### unsubscribe\n前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。\n\n```javascript\n    ngOnDestroy() {\n        this.inputSubscription.unsubscribe();\n    }\n```\n\n##### takeWhile\n\n如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：\n\n使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。\n\n```javascript\nprivate alive: boolean = true;\nngOnInit() {\n  const node = document.querySelector('input[type=text]');\n\n  this.s = Observable.fromEvent(node, 'input')\n    .takeWhile(() => this.alive)\n    .map((event: any) => event.target.value)\n    .filter(value => value.length >= 2)\n    .subscribe(value => { console.log(value) });\n}\n\nngOnDestroy() {\n  this.alive = false;\n}\n```\n\n## Subject\n\n我们在写一个Service用于数据传递时，总是使用 new Subject。\n```javascript\n@Injectable()\nexport class MessageService {\n    private subject = new Subject<any>();\n\n    send(message: any) {\n        this.subject.next(message);\n    }\n\n    get(): Observable<any> {\n        return this.subject.asObservable();\n    }\n}\n```\n当F组件需要向M组件传递数据时，我们可以在F组件中使用send()。\n\n```javascript\n\n    constructor(public srv: MessageService) { }\n\n    ngOnInit() {\n        this.srv.send('w s k f m?')\n    }\n```\n\n而M组件只需要订阅内容就行：\n\n```javascript\n    constructor(private srv: MessageService) {}\n\n    message: any;\n    ngOnInit() {\n        this.srv.get().subscribe((result) => {\n            this.message = result;\n        })\n    }\n```\n\n## EventEmitter\n\n其实EventEmitter跟RxJS没有直接关系，因为他是Angular的产物，而非RxJS的东西。或者我们压根没必要去谈，因为EventEmitter就是Subject。\n\n**EventEmitter的作用是使指令或组件能自定义事件。**\n\n```javascript\n@Output() changed = new EventEmitter<string>();\n\nclick() {\n    this.changed.emit('hi~');\n}\n```\n\n```javascript\n@Component({\n  template: `<comp (changed)=\"subscribe($event)\"></comp>`\n})\nexport class HomeComponent {\n  subscribe(message: string) {\n     // 接收：hi~\n  }\n}\n```\n\n上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。\n\n## 结论\n\n#### 创建数据流：\n\n- 单值：of, empty, never\n- 多值：from\n- 定时：interval, timer\n- 从事件创建：fromEvent\n- 从Promise创建：fromPromise\n- 自定义创建：create\n\n#### 转换操作：\n\n- 改变数据形态：map, mapTo, pluck\n- 过滤一些值：filter, skip, first, last, take\n- 时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime\n- 累加：reduce, scan\n- 异常处理：throw, catch, retry, finally\n- 条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn\n- 转接：switch\n\n#### 组合数据流：\n\n- concat，保持原来的序列顺序连接两个数据流\n- merge，合并序列\n- race，预设条件为其中一个数据流完成\n- forkJoin，预设条件为所有数据流都完成\n- zip，取各来源数据流最后一个值合并为对象\n- combineLatest，取各来源数据流最后一个值合并为数组\n另，最好使用 $ 结尾的命名方式来表示Observable，例：input$。\n\n\n","slug":"Observable","published":1,"date":"2018-01-15T08:18:09.887Z","updated":"2017-12-29T07:06:49.289Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7dm0006j8vr7nb93o9f","content":"<p>观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer）完美的将观察者和被观察的对象分离开。</p>\n<a id=\"more\"></a>\n<p>Observable只是一个普通函数，要想让他有所作为，就需要跟observer一起使用；而这个observer（后面我们会介绍）只是一个带有 next、error、complete 的简单对象而已。最后，还需要通过 subscribe 订阅来<br><strong>启动</strong> Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在RxJS里叫 unsubscribe）。</p>\n<ul>\n<li>Observer Pattern - (观察者模式/发布订阅模式)</li>\n<li>Iterator Pattern - (迭代器模式)</li>\n</ul>\n<p>这两种模式是Observable的基础。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>\n<p>Observables 与 Observer 之间的订阅发布关系(观察者模式) 如下：</p>\n<ul>\n<li>订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。</li>\n<li>发布：Observable 通过回调 next 方法向 Observer 发布事件。</li>\n</ul>\n<p>当Observable设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是DOM中的 click 事件、input 事件、或者更加复杂的HTTP通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable, Subscription &#125; <span class=\"keyword\">from</span> <span class=\"string\">'rxjs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'app-home'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;input type=\"text\"&gt; `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> input$ = Observable.fromEvent(node, <span class=\"string\">'input'</span>);</span><br><span class=\"line\">    input$.subscribe(&#123;</span><br><span class=\"line\">      next: <span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`You just typed <span class=\"subst\">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class=\"line\">      error: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Oops... <span class=\"subst\">$&#123;err&#125;</span>`</span>),</span><br><span class=\"line\">      complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Complete!`</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Observable.fromEvent() 会返回一个Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的observer观察者。</strong></p>\n<h2 id=\"一、observer\"><a href=\"#一、observer\" class=\"headerlink\" title=\"一、observer\"></a>一、observer</h2><p><strong>subscribe订阅就是接收一个observer 方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input$.subscribe(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当Observable产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。</p>\n<p>当Observable被订阅后，除非调用observer的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。</p>\n<p>Observable的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式operator来完成的，每一个operator都会产生一个新的Observable。而我们也称这一序列过程为：<strong>流</strong>。</p>\n<hr>\n<h2 id=\"二、operator\"><a href=\"#二、operator\" class=\"headerlink\" title=\"二、operator\"></a>二、operator</h2><p>Observable可以链式写法，这意味着我们可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">.map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">.subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(value); &#125;);</span><br></pre></td></tr></table></figure>\n<p>下面是顺序步骤：</p>\n<ul>\n<li>假设用户输入：a</li>\n<li>Observable对触发 oninput 事件作出反应，将值以参数的形式传递给observer的 next()。</li>\n<li>map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个observer。</li>\n<li>filter() 如果值长度 &gt;=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个observer。</li>\n<li>最后，将结果传递给 subscribe 订阅块。</li>\n</ul>\n<h4 id=\"取消订阅\"><a href=\"#取消订阅\" class=\"headerlink\" title=\"取消订阅\"></a>取消订阅</h4><p>Observable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在Angular里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在SPA世界里懂得擦屁股是一件必须的事。</p>\n<h5 id=\"unsubscribe\"><a href=\"#unsubscribe\" class=\"headerlink\" title=\"unsubscribe\"></a>unsubscribe</h5><p>前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.inputSubscription.unsubscribe();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"takeWhile\"><a href=\"#takeWhile\" class=\"headerlink\" title=\"takeWhile\"></a>takeWhile</h5><p>如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：</p>\n<p>使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private alive: boolean = <span class=\"literal\">true</span>;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.s = Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">    .takeWhile(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.alive)</span><br><span class=\"line\">    .map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    .subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(value) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>我们在写一个Service用于数据传递时，总是使用 new Subject。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageService</span> </span>&#123;</span><br><span class=\"line\">    private subject = <span class=\"keyword\">new</span> Subject&lt;any&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    send(message: any) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject.next(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    get(): Observable&lt;any&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subject.asObservable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当F组件需要向M组件传递数据时，我们可以在F组件中使用send()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>(public srv: MessageService) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.send(<span class=\"string\">'w s k f m?'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而M组件只需要订阅内容就行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(private srv: MessageService) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message: any;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.get().subscribe(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = result;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"EventEmitter\"><a href=\"#EventEmitter\" class=\"headerlink\" title=\"EventEmitter\"></a>EventEmitter</h2><p>其实EventEmitter跟RxJS没有直接关系，因为他是Angular的产物，而非RxJS的东西。或者我们压根没必要去谈，因为EventEmitter就是Subject。</p>\n<p><strong>EventEmitter的作用是使指令或组件能自定义事件。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Output() changed = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.changed.emit(<span class=\"string\">'hi~'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;comp (changed)=\"subscribe($event)\"&gt;&lt;/comp&gt;`</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  subscribe(message: string) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 接收：hi~</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><h4 id=\"创建数据流：\"><a href=\"#创建数据流：\" class=\"headerlink\" title=\"创建数据流：\"></a>创建数据流：</h4><ul>\n<li>单值：of, empty, never</li>\n<li>多值：from</li>\n<li>定时：interval, timer</li>\n<li>从事件创建：fromEvent</li>\n<li>从Promise创建：fromPromise</li>\n<li>自定义创建：create</li>\n</ul>\n<h4 id=\"转换操作：\"><a href=\"#转换操作：\" class=\"headerlink\" title=\"转换操作：\"></a>转换操作：</h4><ul>\n<li>改变数据形态：map, mapTo, pluck</li>\n<li>过滤一些值：filter, skip, first, last, take</li>\n<li>时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime</li>\n<li>累加：reduce, scan</li>\n<li>异常处理：throw, catch, retry, finally</li>\n<li>条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn</li>\n<li>转接：switch</li>\n</ul>\n<h4 id=\"组合数据流：\"><a href=\"#组合数据流：\" class=\"headerlink\" title=\"组合数据流：\"></a>组合数据流：</h4><ul>\n<li>concat，保持原来的序列顺序连接两个数据流</li>\n<li>merge，合并序列</li>\n<li>race，预设条件为其中一个数据流完成</li>\n<li>forkJoin，预设条件为所有数据流都完成</li>\n<li>zip，取各来源数据流最后一个值合并为对象</li>\n<li>combineLatest，取各来源数据流最后一个值合并为数组<br>另，最好使用 $ 结尾的命名方式来表示Observable，例：input$。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer）完美的将观察者和被观察的对象分离开。</p>","more":"<p>Observable只是一个普通函数，要想让他有所作为，就需要跟observer一起使用；而这个observer（后面我们会介绍）只是一个带有 next、error、complete 的简单对象而已。最后，还需要通过 subscribe 订阅来<br><strong>启动</strong> Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在RxJS里叫 unsubscribe）。</p>\n<ul>\n<li>Observer Pattern - (观察者模式/发布订阅模式)</li>\n<li>Iterator Pattern - (迭代器模式)</li>\n</ul>\n<p>这两种模式是Observable的基础。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>\n<p>Observables 与 Observer 之间的订阅发布关系(观察者模式) 如下：</p>\n<ul>\n<li>订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。</li>\n<li>发布：Observable 通过回调 next 方法向 Observer 发布事件。</li>\n</ul>\n<p>当Observable设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是DOM中的 click 事件、input 事件、或者更加复杂的HTTP通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable, Subscription &#125; <span class=\"keyword\">from</span> <span class=\"string\">'rxjs'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'app-home'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;input type=\"text\"&gt; `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> input$ = Observable.fromEvent(node, <span class=\"string\">'input'</span>);</span><br><span class=\"line\">    input$.subscribe(&#123;</span><br><span class=\"line\">      next: <span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`You just typed <span class=\"subst\">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class=\"line\">      error: <span class=\"function\">(<span class=\"params\">err</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Oops... <span class=\"subst\">$&#123;err&#125;</span>`</span>),</span><br><span class=\"line\">      complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Complete!`</span>)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Observable.fromEvent() 会返回一个Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的observer观察者。</strong></p>\n<h2 id=\"一、observer\"><a href=\"#一、observer\" class=\"headerlink\" title=\"一、observer\"></a>一、observer</h2><p><strong>subscribe订阅就是接收一个observer 方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input$.subscribe(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> &#123;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当Observable产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。</p>\n<p>当Observable被订阅后，除非调用observer的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。</p>\n<p>Observable的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式operator来完成的，每一个operator都会产生一个新的Observable。而我们也称这一序列过程为：<strong>流</strong>。</p>\n<hr>\n<h2 id=\"二、operator\"><a href=\"#二、operator\" class=\"headerlink\" title=\"二、operator\"></a>二、operator</h2><p>Observable可以链式写法，这意味着我们可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">.map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">.filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">.subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(value); &#125;);</span><br></pre></td></tr></table></figure>\n<p>下面是顺序步骤：</p>\n<ul>\n<li>假设用户输入：a</li>\n<li>Observable对触发 oninput 事件作出反应，将值以参数的形式传递给observer的 next()。</li>\n<li>map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个observer。</li>\n<li>filter() 如果值长度 &gt;=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个observer。</li>\n<li>最后，将结果传递给 subscribe 订阅块。</li>\n</ul>\n<h4 id=\"取消订阅\"><a href=\"#取消订阅\" class=\"headerlink\" title=\"取消订阅\"></a>取消订阅</h4><p>Observable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在Angular里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在SPA世界里懂得擦屁股是一件必须的事。</p>\n<h5 id=\"unsubscribe\"><a href=\"#unsubscribe\" class=\"headerlink\" title=\"unsubscribe\"></a>unsubscribe</h5><p>前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.inputSubscription.unsubscribe();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"takeWhile\"><a href=\"#takeWhile\" class=\"headerlink\" title=\"takeWhile\"></a>takeWhile</h5><p>如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：</p>\n<p>使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private alive: boolean = <span class=\"literal\">true</span>;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.s = Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">    .takeWhile(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.alive)</span><br><span class=\"line\">    .map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    .subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(value) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>我们在写一个Service用于数据传递时，总是使用 new Subject。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageService</span> </span>&#123;</span><br><span class=\"line\">    private subject = <span class=\"keyword\">new</span> Subject&lt;any&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    send(message: any) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject.next(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    get(): Observable&lt;any&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subject.asObservable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当F组件需要向M组件传递数据时，我们可以在F组件中使用send()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>(public srv: MessageService) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.send(<span class=\"string\">'w s k f m?'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而M组件只需要订阅内容就行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(private srv: MessageService) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message: any;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.get().subscribe(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = result;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"EventEmitter\"><a href=\"#EventEmitter\" class=\"headerlink\" title=\"EventEmitter\"></a>EventEmitter</h2><p>其实EventEmitter跟RxJS没有直接关系，因为他是Angular的产物，而非RxJS的东西。或者我们压根没必要去谈，因为EventEmitter就是Subject。</p>\n<p><strong>EventEmitter的作用是使指令或组件能自定义事件。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Output() changed = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.changed.emit(<span class=\"string\">'hi~'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;comp (changed)=\"subscribe($event)\"&gt;&lt;/comp&gt;`</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  subscribe(message: string) &#123;</span><br><span class=\"line\">     <span class=\"comment\">// 接收：hi~</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><h4 id=\"创建数据流：\"><a href=\"#创建数据流：\" class=\"headerlink\" title=\"创建数据流：\"></a>创建数据流：</h4><ul>\n<li>单值：of, empty, never</li>\n<li>多值：from</li>\n<li>定时：interval, timer</li>\n<li>从事件创建：fromEvent</li>\n<li>从Promise创建：fromPromise</li>\n<li>自定义创建：create</li>\n</ul>\n<h4 id=\"转换操作：\"><a href=\"#转换操作：\" class=\"headerlink\" title=\"转换操作：\"></a>转换操作：</h4><ul>\n<li>改变数据形态：map, mapTo, pluck</li>\n<li>过滤一些值：filter, skip, first, last, take</li>\n<li>时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime</li>\n<li>累加：reduce, scan</li>\n<li>异常处理：throw, catch, retry, finally</li>\n<li>条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn</li>\n<li>转接：switch</li>\n</ul>\n<h4 id=\"组合数据流：\"><a href=\"#组合数据流：\" class=\"headerlink\" title=\"组合数据流：\"></a>组合数据流：</h4><ul>\n<li>concat，保持原来的序列顺序连接两个数据流</li>\n<li>merge，合并序列</li>\n<li>race，预设条件为其中一个数据流完成</li>\n<li>forkJoin，预设条件为所有数据流都完成</li>\n<li>zip，取各来源数据流最后一个值合并为对象</li>\n<li>combineLatest，取各来源数据流最后一个值合并为数组<br>另，最好使用 $ 结尾的命名方式来表示Observable，例：input$。</li>\n</ul>"},{"title":"PWA-pushMessage","comments":1,"_content":"## 消息推送介绍\n消息推送通知目前整体支持度并不高，在手机端更只有安卓chrome57支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。\n\n<!--more-->\n\n## 获取授权\n- 在订阅之前先获取用户授权，** 使用Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。\n- 如果不选择1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。\n- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。\n- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\">push API</a> 允许web 应用程序接受从服务器推送到它们的消息的能力，无论WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。\n\n## 订阅消息的具体实现\n- 在订阅之前先获取用户授权\n- 使用pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。\n    - userVisibleOnly,不允许静默的推出，所有推出都对用户可见，所以值为true\n    - applicationServerKey,服务器生成的公钥\n- 得到推送服务成功响应后，浏览器将推送服务返回的endpoint加入推送订阅对象，向服务器发送这个对象供其存储。\n\n消息推送的安全性:\n- 推送服务确保调用来自可靠的服务端。\n- 推送消息内容只有浏览器能够解密，就算是推送服务也不行\n\n## 使用web-push 发送信息\n服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用web-push可以解决大部分问题。\n- 使用web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的applicationServerKey吗，我们需要公钥publicKey传递到订阅脚本所在的页面中。。\n- 调用 setVapidDetails 为web-push设置生成的公私钥。\n- 之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。\n- 调用sendNotification向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。\n- 所有推送服务都遵循同意的调用标准，**所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。**\n\n## 推送服务的响应\n- 429 too many requests\n- 400 invalid request\n- 404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。\n- 410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的unsubscribe()方法\n- 413 Payload size too large\n\n","source":"_posts/PWA-pushMessage.md","raw":"---\ntitle: PWA-pushMessage\ncategories: PWA\ncomments: true\n---\n## 消息推送介绍\n消息推送通知目前整体支持度并不高，在手机端更只有安卓chrome57支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。\n\n<!--more-->\n\n## 获取授权\n- 在订阅之前先获取用户授权，** 使用Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。\n- 如果不选择1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。\n- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。\n- <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\">push API</a> 允许web 应用程序接受从服务器推送到它们的消息的能力，无论WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。\n\n## 订阅消息的具体实现\n- 在订阅之前先获取用户授权\n- 使用pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。\n    - userVisibleOnly,不允许静默的推出，所有推出都对用户可见，所以值为true\n    - applicationServerKey,服务器生成的公钥\n- 得到推送服务成功响应后，浏览器将推送服务返回的endpoint加入推送订阅对象，向服务器发送这个对象供其存储。\n\n消息推送的安全性:\n- 推送服务确保调用来自可靠的服务端。\n- 推送消息内容只有浏览器能够解密，就算是推送服务也不行\n\n## 使用web-push 发送信息\n服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用web-push可以解决大部分问题。\n- 使用web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的applicationServerKey吗，我们需要公钥publicKey传递到订阅脚本所在的页面中。。\n- 调用 setVapidDetails 为web-push设置生成的公私钥。\n- 之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。\n- 调用sendNotification向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。\n- 所有推送服务都遵循同意的调用标准，**所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。**\n\n## 推送服务的响应\n- 429 too many requests\n- 400 invalid request\n- 404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。\n- 410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的unsubscribe()方法\n- 413 Payload size too large\n\n","slug":"PWA-pushMessage","published":1,"date":"2018-01-15T08:18:09.890Z","updated":"2017-12-29T07:06:49.290Z","layout":"post","photos":[],"link":"","_id":"cjcr3j7do0008j8vrsqu90k7m","content":"<h2 id=\"消息推送介绍\"><a href=\"#消息推送介绍\" class=\"headerlink\" title=\"消息推送介绍\"></a>消息推送介绍</h2><p>消息推送通知目前整体支持度并不高，在手机端更只有安卓chrome57支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。</p>\n<a id=\"more\"></a>\n<h2 id=\"获取授权\"><a href=\"#获取授权\" class=\"headerlink\" title=\"获取授权\"></a>获取授权</h2><ul>\n<li>在订阅之前先获取用户授权，** 使用Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。</li>\n<li>如果不选择1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\" target=\"_blank\" rel=\"noopener\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\" target=\"_blank\" rel=\"noopener\">push API</a> 允许web 应用程序接受从服务器推送到它们的消息的能力，无论WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。</li>\n</ul>\n<h2 id=\"订阅消息的具体实现\"><a href=\"#订阅消息的具体实现\" class=\"headerlink\" title=\"订阅消息的具体实现\"></a>订阅消息的具体实现</h2><ul>\n<li>在订阅之前先获取用户授权</li>\n<li>使用pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。<ul>\n<li>userVisibleOnly,不允许静默的推出，所有推出都对用户可见，所以值为true</li>\n<li>applicationServerKey,服务器生成的公钥</li>\n</ul>\n</li>\n<li>得到推送服务成功响应后，浏览器将推送服务返回的endpoint加入推送订阅对象，向服务器发送这个对象供其存储。</li>\n</ul>\n<p>消息推送的安全性:</p>\n<ul>\n<li>推送服务确保调用来自可靠的服务端。</li>\n<li>推送消息内容只有浏览器能够解密，就算是推送服务也不行</li>\n</ul>\n<h2 id=\"使用web-push-发送信息\"><a href=\"#使用web-push-发送信息\" class=\"headerlink\" title=\"使用web-push 发送信息\"></a>使用web-push 发送信息</h2><p>服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用web-push可以解决大部分问题。</p>\n<ul>\n<li>使用web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的applicationServerKey吗，我们需要公钥publicKey传递到订阅脚本所在的页面中。。</li>\n<li>调用 setVapidDetails 为web-push设置生成的公私钥。</li>\n<li>之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。</li>\n<li>调用sendNotification向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。</li>\n<li>所有推送服务都遵循同意的调用标准，<strong>所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。</strong></li>\n</ul>\n<h2 id=\"推送服务的响应\"><a href=\"#推送服务的响应\" class=\"headerlink\" title=\"推送服务的响应\"></a>推送服务的响应</h2><ul>\n<li>429 too many requests</li>\n<li>400 invalid request</li>\n<li>404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。</li>\n<li>410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的unsubscribe()方法</li>\n<li>413 Payload size too large</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"消息推送介绍\"><a href=\"#消息推送介绍\" class=\"headerlink\" title=\"消息推送介绍\"></a>消息推送介绍</h2><p>消息推送通知目前整体支持度并不高，在手机端更只有安卓chrome57支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。</p>","more":"<h2 id=\"获取授权\"><a href=\"#获取授权\" class=\"headerlink\" title=\"获取授权\"></a>获取授权</h2><ul>\n<li>在订阅之前先获取用户授权，** 使用Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。</li>\n<li>如果不选择1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\" target=\"_blank\" rel=\"noopener\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\" target=\"_blank\" rel=\"noopener\">push API</a> 允许web 应用程序接受从服务器推送到它们的消息的能力，无论WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。</li>\n</ul>\n<h2 id=\"订阅消息的具体实现\"><a href=\"#订阅消息的具体实现\" class=\"headerlink\" title=\"订阅消息的具体实现\"></a>订阅消息的具体实现</h2><ul>\n<li>在订阅之前先获取用户授权</li>\n<li>使用pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。<ul>\n<li>userVisibleOnly,不允许静默的推出，所有推出都对用户可见，所以值为true</li>\n<li>applicationServerKey,服务器生成的公钥</li>\n</ul>\n</li>\n<li>得到推送服务成功响应后，浏览器将推送服务返回的endpoint加入推送订阅对象，向服务器发送这个对象供其存储。</li>\n</ul>\n<p>消息推送的安全性:</p>\n<ul>\n<li>推送服务确保调用来自可靠的服务端。</li>\n<li>推送消息内容只有浏览器能够解密，就算是推送服务也不行</li>\n</ul>\n<h2 id=\"使用web-push-发送信息\"><a href=\"#使用web-push-发送信息\" class=\"headerlink\" title=\"使用web-push 发送信息\"></a>使用web-push 发送信息</h2><p>服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用web-push可以解决大部分问题。</p>\n<ul>\n<li>使用web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的applicationServerKey吗，我们需要公钥publicKey传递到订阅脚本所在的页面中。。</li>\n<li>调用 setVapidDetails 为web-push设置生成的公私钥。</li>\n<li>之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。</li>\n<li>调用sendNotification向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。</li>\n<li>所有推送服务都遵循同意的调用标准，<strong>所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。</strong></li>\n</ul>\n<h2 id=\"推送服务的响应\"><a href=\"#推送服务的响应\" class=\"headerlink\" title=\"推送服务的响应\"></a>推送服务的响应</h2><ul>\n<li>429 too many requests</li>\n<li>400 invalid request</li>\n<li>404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。</li>\n<li>410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的unsubscribe()方法</li>\n<li>413 Payload size too large</li>\n</ul>"},{"title":"angular 数据绑定详解","comments":1,"_content":"## 绑定\n1. 绑定表达式的指令ngBind\n```html\n    <div ng-Bind = \"vm.info\"></div>\n\n```\n这样就把控制器中额vm.info的值绑定在div标签中，这样页面在网速不好的时候就不会出现angular 中&#123;&#123;&#125;&#125;的解析符，它隐藏了angular解析表达式的过程\n2. ngBindTemplate\nngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式\n        ``` html\n        <div ng-bind-template=\"{{vm.info}}{{vm.msg}}\"></div>\n        ```\n\n<!--more-->\n\n## 数据绑定\n 数据绑定可以分为3种：\n 1. 属性绑定和插值表达式 组件类 -> 模板\n 2. 事件绑定：模板 -> 组件类\n 3. 双向绑定： 模板 <-> 组件类\n\n#### 事件绑定\n```html\n    <a (click)=\"test()\"></a>\n     (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法\n````\n#### 属性绑定和插值表达式\n属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定,例如下面的两种写法是一样的\n\n    ```javascript\n    <img src=\"{{ingURL}}\" />\n    <img [src]=\"imgUrl\">\n    ```\n\n属性绑定又分为HTML属性绑定和DOM绑定， 例如：\n\n   ``` javascript\n   <input type =\"text\" value = \"hello\" (input) = \"doInput($event)\" >\n    doInput(event:any){\n        console.log(event.target.value);\n        console.log(event.target.getAttribute('value'));\n    }\n\n```\n其中event.target.value 是获取的DOM 属性，是可变的，表示当前元素的状态。\n而 event.target.getAttribute(\"value\")获取的是HTML属性，是不可变的。只负责初始化HTML元素，不可改变。\n\n<strong>注意：</strong>\n1. 有的DOM属性没有映射的HTML属性，同样有些HTML属性也没有映射的DOM属性。\n2. 模板绑定的是DOM属性。\n\n##### HTML属性绑定\n1. 基本HTML属性绑定\n\n```javascript\n    <td [attr.colspan]=\"表达式\"></td>\n```\n\n2. css绑定\n\n```html\n    <div class =\"a\" [class]=\"b\"></div> //b会完全替代a\n    <div [class.a]=\"fn()\"></div>//fn()返回true、false,如果true则添加.a\n    <div [ngClass]=\"{a:isA,b:isB}\"></div>// b会完全替代a\n```\n\n3. 样式绑定\n\n    ```javascript\n        <button [style.color]=\"a?red:green\">button</button>\n        <button [ngStyle] = \"{'font-style':a?'red':'green'}\">button</button>\n    ```\n4. 双向绑定\n双向绑定可以从组件类->模板，也可以模板->组件类，利用[(ngModel)]可以实现双向数据绑定","source":"_posts/angular-数据绑定.md","raw":"---\ntitle: angular 数据绑定详解\ncategories: angular\ncomments: true\n---\n## 绑定\n1. 绑定表达式的指令ngBind\n```html\n    <div ng-Bind = \"vm.info\"></div>\n\n```\n这样就把控制器中额vm.info的值绑定在div标签中，这样页面在网速不好的时候就不会出现angular 中&#123;&#123;&#125;&#125;的解析符，它隐藏了angular解析表达式的过程\n2. ngBindTemplate\nngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式\n        ``` html\n        <div ng-bind-template=\"{{vm.info}}{{vm.msg}}\"></div>\n        ```\n\n<!--more-->\n\n## 数据绑定\n 数据绑定可以分为3种：\n 1. 属性绑定和插值表达式 组件类 -> 模板\n 2. 事件绑定：模板 -> 组件类\n 3. 双向绑定： 模板 <-> 组件类\n\n#### 事件绑定\n```html\n    <a (click)=\"test()\"></a>\n     (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法\n````\n#### 属性绑定和插值表达式\n属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定,例如下面的两种写法是一样的\n\n    ```javascript\n    <img src=\"{{ingURL}}\" />\n    <img [src]=\"imgUrl\">\n    ```\n\n属性绑定又分为HTML属性绑定和DOM绑定， 例如：\n\n   ``` javascript\n   <input type =\"text\" value = \"hello\" (input) = \"doInput($event)\" >\n    doInput(event:any){\n        console.log(event.target.value);\n        console.log(event.target.getAttribute('value'));\n    }\n\n```\n其中event.target.value 是获取的DOM 属性，是可变的，表示当前元素的状态。\n而 event.target.getAttribute(\"value\")获取的是HTML属性，是不可变的。只负责初始化HTML元素，不可改变。\n\n<strong>注意：</strong>\n1. 有的DOM属性没有映射的HTML属性，同样有些HTML属性也没有映射的DOM属性。\n2. 模板绑定的是DOM属性。\n\n##### HTML属性绑定\n1. 基本HTML属性绑定\n\n```javascript\n    <td [attr.colspan]=\"表达式\"></td>\n```\n\n2. css绑定\n\n```html\n    <div class =\"a\" [class]=\"b\"></div> //b会完全替代a\n    <div [class.a]=\"fn()\"></div>//fn()返回true、false,如果true则添加.a\n    <div [ngClass]=\"{a:isA,b:isB}\"></div>// b会完全替代a\n```\n\n3. 样式绑定\n\n    ```javascript\n        <button [style.color]=\"a?red:green\">button</button>\n        <button [ngStyle] = \"{'font-style':a?'red':'green'}\">button</button>\n    ```\n4. 双向绑定\n双向绑定可以从组件类->模板，也可以模板->组件类，利用[(ngModel)]可以实现双向数据绑定","slug":"angular-数据绑定","published":1,"date":"2018-01-15T08:18:09.877Z","updated":"2018-01-18T01:45:05.477Z","layout":"post","photos":[],"link":"","_id":"cjcr3j7dq0009j8vrmkvumxl8","content":"<h2 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h2><ol>\n<li>绑定表达式的指令ngBind<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-Bind</span> = <span class=\"string\">\"vm.info\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样就把控制器中额vm.info的值绑定在div标签中，这样页面在网速不好的时候就不会出现angular 中&#123;&#123;&#125;&#125;的解析符，它隐藏了angular解析表达式的过程</p>\n<ol>\n<li>ngBindTemplate<br>ngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式<pre><code><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-bind-template</span>=<span class=\"string\">\"&#123;&#123;vm.info&#125;&#125;&#123;&#123;vm.msg&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><p> 数据绑定可以分为3种：</p>\n<ol>\n<li>属性绑定和插值表达式 组件类 -&gt; 模板</li>\n<li>事件绑定：模板 -&gt; 组件类</li>\n<li>双向绑定： 模板 &lt;-&gt; 组件类</li>\n</ol>\n<h4 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"test()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">     (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性绑定和插值表达式\"><a href=\"#属性绑定和插值表达式\" class=\"headerlink\" title=\"属性绑定和插值表达式\"></a>属性绑定和插值表达式</h4><p>属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定,例如下面的两种写法是一样的</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">\"&#123;&#123;ingURL&#125;&#125;\"</span> /&gt;</span><br><span class=\"line\">&lt;img [src]=<span class=\"string\">\"imgUrl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><p>属性绑定又分为HTML属性绑定和DOM绑定， 例如：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type =<span class=\"string\">\"text\"</span> value = <span class=\"string\">\"hello\"</span> (input) = <span class=\"string\">\"doInput($event)\"</span> &gt;</span><br><span class=\"line\"> doInput(event:any)&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.value);</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.getAttribute(<span class=\"string\">'value'</span>));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其中event.target.value 是获取的DOM 属性，是可变的，表示当前元素的状态。<br>而 event.target.getAttribute(“value”)获取的是HTML属性，是不可变的。只负责初始化HTML元素，不可改变。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>有的DOM属性没有映射的HTML属性，同样有些HTML属性也没有映射的DOM属性。</li>\n<li>模板绑定的是DOM属性。</li>\n</ol>\n<h5 id=\"HTML属性绑定\"><a href=\"#HTML属性绑定\" class=\"headerlink\" title=\"HTML属性绑定\"></a>HTML属性绑定</h5><ol>\n<li>基本HTML属性绑定</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td [attr.colspan]=<span class=\"string\">\"表达式\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>css绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> =<span class=\"string\">\"a\"</span> [<span class=\"attr\">class</span>]=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> //b会完全替代a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">class.a</span>]=<span class=\"string\">\"fn()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>//fn()返回true、false,如果true则添加.a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">ngClass</span>]=<span class=\"string\">\"&#123;a:isA,b:isB&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// b会完全替代a</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>样式绑定</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button [style.color]=<span class=\"string\">\"a?red:green\"</span>&gt;button&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;button [ngStyle] = \"&#123;'font-style':a?'red':'green'&#125;\"&gt;button&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>双向绑定<br>双向绑定可以从组件类-&gt;模板，也可以模板-&gt;组件类，利用[(ngModel)]可以实现双向数据绑定</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h2><ol>\n<li>绑定表达式的指令ngBind<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-Bind</span> = <span class=\"string\">\"vm.info\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这样就把控制器中额vm.info的值绑定在div标签中，这样页面在网速不好的时候就不会出现angular 中&#123;&#123;&#125;&#125;的解析符，它隐藏了angular解析表达式的过程</p>\n<ol>\n<li>ngBindTemplate<br>ngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式<pre><code><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-bind-template</span>=<span class=\"string\">\"&#123;&#123;vm.info&#125;&#125;&#123;&#123;vm.msg&#125;&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</code></pre></li>\n</ol>","more":"<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><p> 数据绑定可以分为3种：</p>\n<ol>\n<li>属性绑定和插值表达式 组件类 -&gt; 模板</li>\n<li>事件绑定：模板 -&gt; 组件类</li>\n<li>双向绑定： 模板 &lt;-&gt; 组件类</li>\n</ol>\n<h4 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">a</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"test()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\">     (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法</span><br><span class=\"line\">`</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性绑定和插值表达式\"><a href=\"#属性绑定和插值表达式\" class=\"headerlink\" title=\"属性绑定和插值表达式\"></a>属性绑定和插值表达式</h4><p>属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定,例如下面的两种写法是一样的</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">\"&#123;&#123;ingURL&#125;&#125;\"</span> /&gt;</span><br><span class=\"line\">&lt;img [src]=<span class=\"string\">\"imgUrl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><p>属性绑定又分为HTML属性绑定和DOM绑定， 例如：</p>\n   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type =<span class=\"string\">\"text\"</span> value = <span class=\"string\">\"hello\"</span> (input) = <span class=\"string\">\"doInput($event)\"</span> &gt;</span><br><span class=\"line\"> doInput(event:any)&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.value);</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.getAttribute(<span class=\"string\">'value'</span>));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其中event.target.value 是获取的DOM 属性，是可变的，表示当前元素的状态。<br>而 event.target.getAttribute(“value”)获取的是HTML属性，是不可变的。只负责初始化HTML元素，不可改变。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>有的DOM属性没有映射的HTML属性，同样有些HTML属性也没有映射的DOM属性。</li>\n<li>模板绑定的是DOM属性。</li>\n</ol>\n<h5 id=\"HTML属性绑定\"><a href=\"#HTML属性绑定\" class=\"headerlink\" title=\"HTML属性绑定\"></a>HTML属性绑定</h5><ol>\n<li>基本HTML属性绑定</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td [attr.colspan]=<span class=\"string\">\"表达式\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>css绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> =<span class=\"string\">\"a\"</span> [<span class=\"attr\">class</span>]=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> //b会完全替代a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">class.a</span>]=<span class=\"string\">\"fn()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>//fn()返回true、false,如果true则添加.a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">ngClass</span>]=<span class=\"string\">\"&#123;a:isA,b:isB&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// b会完全替代a</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>样式绑定</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button [style.color]=<span class=\"string\">\"a?red:green\"</span>&gt;button&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;button [ngStyle] = \"&#123;'font-style':a?'red':'green'&#125;\"&gt;button&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>双向绑定<br>双向绑定可以从组件类-&gt;模板，也可以模板-&gt;组件类，利用[(ngModel)]可以实现双向数据绑定</p>\n</li>\n</ol>"},{"title":"angular form 表单","comments":1,"_content":"## checkbox\n\nmodule：import &#123;CheckboxControlValueAccessor &#125; from '@abgular/forms';\n\n- input[type=checkbox][formCtontrolName]\n- input[type=checkbox][formControl]\n- input[type=checkbox][ngModel]\n\n用于写入值并在复选框输入元素上监听更改的访问器\n\n```html\n<input type=\"checkbox\" name = \"rememberLogin\" ngModel>\n```\n<!--more-->\n### 数据驱动\n响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName \n\n- formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据\n- formBuilder :表单数据构建工具[构建初始表单]\n- formContlName :同步与formGrop 构建表单内相同字段的值\n\n### 响应式表单验证\n响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。\n响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。\n\nreactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和\ninternalFormSharedModule模板里的指令。\n- formControlDirective 描述表单的一个字段\n- formGroupDirective 描述表单分组\n- formControlName 描述变淡字段名\n- formArrayaName 描述同类型的一组数据的名称，与表单分组无关","source":"_posts/angular-form.md","raw":"---\ntitle: angular form 表单\ncategories: angular\ncomments: true\n---\n## checkbox\n\nmodule：import &#123;CheckboxControlValueAccessor &#125; from '@abgular/forms';\n\n- input[type=checkbox][formCtontrolName]\n- input[type=checkbox][formControl]\n- input[type=checkbox][ngModel]\n\n用于写入值并在复选框输入元素上监听更改的访问器\n\n```html\n<input type=\"checkbox\" name = \"rememberLogin\" ngModel>\n```\n<!--more-->\n### 数据驱动\n响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName \n\n- formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据\n- formBuilder :表单数据构建工具[构建初始表单]\n- formContlName :同步与formGrop 构建表单内相同字段的值\n\n### 响应式表单验证\n响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。\n响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。\n\nreactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和\ninternalFormSharedModule模板里的指令。\n- formControlDirective 描述表单的一个字段\n- formGroupDirective 描述表单分组\n- formControlName 描述变淡字段名\n- formArrayaName 描述同类型的一组数据的名称，与表单分组无关","slug":"angular-form","published":1,"date":"2018-01-15T08:18:09.868Z","updated":"2017-12-29T07:06:49.291Z","layout":"post","photos":[],"link":"","_id":"cjcr3j7dt000cj8vr94jlbvnx","content":"<h2 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h2><p>module：import &#123;CheckboxControlValueAccessor &#125; from ‘@abgular/forms’;</p>\n<ul>\n<li>input[type=checkbox][formCtontrolName]</li>\n<li>input[type=checkbox][formControl]</li>\n<li>input[type=checkbox][ngModel]</li>\n</ul>\n<p>用于写入值并在复选框输入元素上监听更改的访问器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">name</span> = <span class=\"string\">\"rememberLogin\"</span> <span class=\"attr\">ngModel</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"数据驱动\"><a href=\"#数据驱动\" class=\"headerlink\" title=\"数据驱动\"></a>数据驱动</h3><p>响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName </p>\n<ul>\n<li>formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据</li>\n<li>formBuilder :表单数据构建工具[构建初始表单]</li>\n<li>formContlName :同步与formGrop 构建表单内相同字段的值</li>\n</ul>\n<h3 id=\"响应式表单验证\"><a href=\"#响应式表单验证\" class=\"headerlink\" title=\"响应式表单验证\"></a>响应式表单验证</h3><p>响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。<br>响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。</p>\n<p>reactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和<br>internalFormSharedModule模板里的指令。</p>\n<ul>\n<li>formControlDirective 描述表单的一个字段</li>\n<li>formGroupDirective 描述表单分组</li>\n<li>formControlName 描述变淡字段名</li>\n<li>formArrayaName 描述同类型的一组数据的名称，与表单分组无关</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h2><p>module：import &#123;CheckboxControlValueAccessor &#125; from ‘@abgular/forms’;</p>\n<ul>\n<li>input[type=checkbox][formCtontrolName]</li>\n<li>input[type=checkbox][formControl]</li>\n<li>input[type=checkbox][ngModel]</li>\n</ul>\n<p>用于写入值并在复选框输入元素上监听更改的访问器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">name</span> = <span class=\"string\">\"rememberLogin\"</span> <span class=\"attr\">ngModel</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"数据驱动\"><a href=\"#数据驱动\" class=\"headerlink\" title=\"数据驱动\"></a>数据驱动</h3><p>响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName </p>\n<ul>\n<li>formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据</li>\n<li>formBuilder :表单数据构建工具[构建初始表单]</li>\n<li>formContlName :同步与formGrop 构建表单内相同字段的值</li>\n</ul>\n<h3 id=\"响应式表单验证\"><a href=\"#响应式表单验证\" class=\"headerlink\" title=\"响应式表单验证\"></a>响应式表单验证</h3><p>响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。<br>响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。</p>\n<p>reactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和<br>internalFormSharedModule模板里的指令。</p>\n<ul>\n<li>formControlDirective 描述表单的一个字段</li>\n<li>formGroupDirective 描述表单分组</li>\n<li>formControlName 描述变淡字段名</li>\n<li>formArrayaName 描述同类型的一组数据的名称，与表单分组无关</li>\n</ul>"},{"title":"angular 线上商城学习","_content":"\n使用 angular 开发线上商城\n\n<!--more-->\n\n## 创建 angular 工程\n\n1. ng new action\n2. 引入第三方的包是通过更改 angular-cli 来实现的。\n3. e2e: 是存放端到端的测试目录，是用来做自动化测试\n4. protractor.conf.js 自动化测试文件\n5. tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。\n6. assets 是用来存放静态资源的。\n7. environments 开发、测试、生产环境的配置，多环境的开发。\n8. main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。\n9. polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。\n10. styles.css 用来编写全局使用的 css。\n\n## 组件\n\n* component 是整个应用的基础。\n* @Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做\n  元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。\n* Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。\n* Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。\n* 所有组件都必须使用 @Component() 装饰器进行注解。\n\n```angular\n@Component{\n  selector:'app-root',//元数据\n  templateUrl:'./app.component.html',\n  styleUrls:['./app.component.css'],\n}\n\nexport class AppComponent{ //暴露为一个组件 ，TypeScript 类，为控制器\n  title = 'app worker'\n}\n```\n\n* @input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。\n* providers 是用来完成依赖注入的。\n* @Outputs 输出属性\n\n## 模块\n\n* 使用 @ngModule 声明一个模块。\n* 使用 declarations 说明了模块中包含了的组件，**这个元数据里面只能用于声明组件、指令、管道**。\n* providers 用于声明模块的服务。\n* bootstrap 用于声明模块的主组件。\n\n<!-- 2-3 -->\n","source":"_posts/angular-线上商城学习.md","raw":"---\ntitle: angular 线上商城学习\ncategories: angular\n---\n\n使用 angular 开发线上商城\n\n<!--more-->\n\n## 创建 angular 工程\n\n1. ng new action\n2. 引入第三方的包是通过更改 angular-cli 来实现的。\n3. e2e: 是存放端到端的测试目录，是用来做自动化测试\n4. protractor.conf.js 自动化测试文件\n5. tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。\n6. assets 是用来存放静态资源的。\n7. environments 开发、测试、生产环境的配置，多环境的开发。\n8. main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。\n9. polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。\n10. styles.css 用来编写全局使用的 css。\n\n## 组件\n\n* component 是整个应用的基础。\n* @Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做\n  元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。\n* Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。\n* Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。\n* 所有组件都必须使用 @Component() 装饰器进行注解。\n\n```angular\n@Component{\n  selector:'app-root',//元数据\n  templateUrl:'./app.component.html',\n  styleUrls:['./app.component.css'],\n}\n\nexport class AppComponent{ //暴露为一个组件 ，TypeScript 类，为控制器\n  title = 'app worker'\n}\n```\n\n* @input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。\n* providers 是用来完成依赖注入的。\n* @Outputs 输出属性\n\n## 模块\n\n* 使用 @ngModule 声明一个模块。\n* 使用 declarations 说明了模块中包含了的组件，**这个元数据里面只能用于声明组件、指令、管道**。\n* providers 用于声明模块的服务。\n* bootstrap 用于声明模块的主组件。\n\n<!-- 2-3 -->\n","slug":"angular-线上商城学习","published":1,"date":"2018-01-15T08:18:09.879Z","updated":"2018-01-17T09:13:32.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7dv000dj8vrf5rrd5sz","content":"<p>使用 angular 开发线上商城</p>\n<a id=\"more\"></a>\n<h2 id=\"创建-angular-工程\"><a href=\"#创建-angular-工程\" class=\"headerlink\" title=\"创建 angular 工程\"></a>创建 angular 工程</h2><ol>\n<li>ng new action</li>\n<li>引入第三方的包是通过更改 angular-cli 来实现的。</li>\n<li>e2e: 是存放端到端的测试目录，是用来做自动化测试</li>\n<li>protractor.conf.js 自动化测试文件</li>\n<li>tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。</li>\n<li>assets 是用来存放静态资源的。</li>\n<li>environments 开发、测试、生产环境的配置，多环境的开发。</li>\n<li>main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。</li>\n<li>polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。</li>\n<li>styles.css 用来编写全局使用的 css。</li>\n</ol>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><ul>\n<li>component 是整个应用的基础。</li>\n<li>@Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做<br>元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。</li>\n<li>Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。</li>\n<li>Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。</li>\n<li>所有组件都必须使用 @Component() 装饰器进行注解。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component&#123;</span><br><span class=\"line\">  selector:&apos;app-root&apos;,//元数据</span><br><span class=\"line\">  templateUrl:&apos;./app.component.html&apos;,</span><br><span class=\"line\">  styleUrls:[&apos;./app.component.css&apos;],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export class AppComponent&#123; //暴露为一个组件 ，TypeScript 类，为控制器</span><br><span class=\"line\">  title = &apos;app worker&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。</li>\n<li>providers 是用来完成依赖注入的。</li>\n<li>@Outputs 输出属性</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><ul>\n<li>使用 @ngModule 声明一个模块。</li>\n<li>使用 declarations 说明了模块中包含了的组件，<strong>这个元数据里面只能用于声明组件、指令、管道</strong>。</li>\n<li>providers 用于声明模块的服务。</li>\n<li>bootstrap 用于声明模块的主组件。</li>\n</ul>\n<!-- 2-3 -->\n","site":{"data":{}},"excerpt":"<p>使用 angular 开发线上商城</p>","more":"<h2 id=\"创建-angular-工程\"><a href=\"#创建-angular-工程\" class=\"headerlink\" title=\"创建 angular 工程\"></a>创建 angular 工程</h2><ol>\n<li>ng new action</li>\n<li>引入第三方的包是通过更改 angular-cli 来实现的。</li>\n<li>e2e: 是存放端到端的测试目录，是用来做自动化测试</li>\n<li>protractor.conf.js 自动化测试文件</li>\n<li>tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。</li>\n<li>assets 是用来存放静态资源的。</li>\n<li>environments 开发、测试、生产环境的配置，多环境的开发。</li>\n<li>main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。</li>\n<li>polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。</li>\n<li>styles.css 用来编写全局使用的 css。</li>\n</ol>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><ul>\n<li>component 是整个应用的基础。</li>\n<li>@Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做<br>元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。</li>\n<li>Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。</li>\n<li>Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。</li>\n<li>所有组件都必须使用 @Component() 装饰器进行注解。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component&#123;</span><br><span class=\"line\">  selector:&apos;app-root&apos;,//元数据</span><br><span class=\"line\">  templateUrl:&apos;./app.component.html&apos;,</span><br><span class=\"line\">  styleUrls:[&apos;./app.component.css&apos;],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export class AppComponent&#123; //暴露为一个组件 ，TypeScript 类，为控制器</span><br><span class=\"line\">  title = &apos;app worker&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。</li>\n<li>providers 是用来完成依赖注入的。</li>\n<li>@Outputs 输出属性</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><ul>\n<li>使用 @ngModule 声明一个模块。</li>\n<li>使用 declarations 说明了模块中包含了的组件，<strong>这个元数据里面只能用于声明组件、指令、管道</strong>。</li>\n<li>providers 用于声明模块的服务。</li>\n<li>bootstrap 用于声明模块的主组件。</li>\n</ul>\n<!-- 2-3 -->"},{"title":"angular 基础","comments":1,"_content":"## angular 与 vue 的区别\n- angular2全部采用TypeScript编写，TypeScript（编译工具），它为JS带来了类似于Java 和C# 的静态类型，\n- vue 的双向绑定基于ES5 的getter/setter 来实现的，而angular是由自己实现一套模板编译规则们需要进行“脏”检查，而vue不需要，因此vue在性能上更高效。\n- angular 中，当watcher 越来越多时会越来越慢，因为作用域的每一次变化\n\n<!--more-->\n\n## angular \n- 组件化，数据的单向中心。es6的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：\n- DOM事件，譬如用户输入文本，点击按钮等。( ng-click )\n- XHR响应事件 ( $http )\n- 浏览器Location变更事件 ( $location )\n- Timer事件( $timeout , $interval )\n- 执行 $digest() 或 $apply()\n\n##  react \n- 速度很快：来源于虚拟DOM，只有在调用get 和 set 的时候才会更新DOM，而且是先更新虚拟DOM再更新实际的DOM，由此更新DOM 的次数少内容也会少很多。\n- FLUX 架构，react 更关注UI 的组件化和数据的单向更新。可以直接有es6的一些语法。\n- 服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是web的执行。\n- 目标是UI。\n- 本身是一个MVC 中的V。\n----------------------------\n## Angular 为表单内置了4种css样式\n\n- ng-valid 校验合法状态\n- ng-invalid 校验非法状态\n- ng-pristine 如果要使用原生的form，需要设置这个值\n- ng-dirty 表单处于脏数据状态\n-----------------------------\n## @Component\n- @Component 是Angular 提供的装饰函数，用来描述Component的元数据\n- selector 指这个组件在HTML模板中的标签是什么\n- template是嵌入（inline）的HTML模板，如果使用单独文件可用templateUrl。\n- styles是嵌入（inline）的CSS样式，如果使用单独文件可用styleUrls。\n- providers 列出会在此模块中“注入”的服务(service)-依赖注入\n- bootstrap指明哪个组件为引导组件(比如AppComponent),当angular引导应用时，它会在Dom中渲染这个引导性组件，并把结果放进index.html的该组件的标签中。\n\n## @NgModule\n@NgModule装饰器用来为模块定义元数据。declarations列出了应用中的顶层组件，在module里面声明的组件在module范围内都可以直接使用，也就是说在同一module里面的任何Component都可以在其模板文件中直接使用声明的组件，就想我们在AppComponent的模板末尾加上 <app-login></app-login> 一样。\n\n```javascript\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\nimport { LoginComponent } from './login/login.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    LoginComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\nNgModule装饰器用来为模块定义元数据。\n- declarations列出了应用中的顶层组件。\n- BrowerModule 提供了运行在浏览器中的应用所需要的关键服务(service)和指令(Directive),这个模块所在需要在浏览器中跑的应用都应用引用。\n- FormsModule 提供了表单处理和双向绑定等服务和指令。\n- HttpModule 提供Htpp请求和响应的服务。\n- providers 列出会在此模版中“注入”的服务（service）。\n- bootstrap 指明哪个组件为引导性组件，并把结果放到index.html 的该组件的元素标签中。\n-  静态引导AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n-------------------------------------\n\n## 依赖注入\n如果不使用依赖注入，则需要\n    //声明成员变量，其类型为service 里面自定义的方法\n\n    ```javascript\n    //第一种：\n    service:AuthService;\n\n    constructor(){\n        this.service = new AuthService();//在构造中初始化service\n    }\n    //第二种：\n\n    providers: [\n    {provide: 'auth',  useClass: AuthService}\n    ]\n    ```\n\n- 第一种：由于实例化是在组件中进行的，意味着我们如果更改service的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量service。当import 相关的服务后，这是import将类型引入进来，而provider 里面会配置这个类型的实例。\n- provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。\n ```javascript\n        onstructor(@Inject('auth') private service) {\n    }\n ```\n\n- @inject('auth'),这个修饰符的意思是请到系统配置中找到名称为auth 的那个依赖注入到我修饰的变量中。\n\n## 双向数据绑定\n- [(ngModel)]=\"username\" ,[]的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉[]就是将ngModel赋值成username这个字符串。[] 的含义是单向绑定，就是将组件中给model 赋的值会设置到HTML的input控件中。[()]是双向绑定。ngModel 是FormModule中提供的指令，它负责从Domain Model中创建一个FormControl的实例，并将这个实例和表单控件绑定.\n- @Input()是输入型绑定的修饰符，用于从数据从父组件传到子组件。\n\n---------------------------------------------\n\n## 表单验证\n```html\n    <div>\n        <input required type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            />\n            {{usernameRef.valid}}\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            {{passwordRef.valid}}\n        <button (click)=\"onClick()\">Login</button>\n        </div>\n        <div>\n        <input #usernameRef type=\"text\">\n        <button (click)=\"onClick(usernameRef.value)\">Login</button>\n        </div>\n```\n\n1. 通过#usernameRef = 'ngModel'重新加入了引用，这个引用指向了ngModel,这个引用是要在模板中使用的所以加入这个引用。\n2. 在输入框中加入#usernameRef，这个叫引用，引用的是input对象，如果想要传递input 的值，可以用usernameRef.value.\n```html\n    <div>\n        <input type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            {{ usernameRef.errors | json }}\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n        <button (click)=\"onClick()\">Login</button>\n    </div>\n```\n*ngIf = \"usernameRef.error?.required\" 的意思是当usernameRef.error.required 为true 的时候显示div 标签\n```html\n    <div>\n        <form #formRef=\"ngForm\" (ngSubmit)=\"onSubmit(formRef.value)\"> \n        <fieldset ngModelGroup=\"login\">\n            <input type=\"text\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n            <input type=\"password\"\n            name=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            required\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n            <button (click)=\"onClick()\">Login</button>\n            <button type=\"submit\">Submit</button>\n            </fieldset>\n        </form>\n        </div>\n```\n- ngModel 会注册成Form 的子控件，注册控件需要name ，这个要求我们显示的指定对应控件的name ，因此需要为input 增加name属性，在formREF.value中包含了表单所有填写项的值\n\n- 有时在表单相中表单项过多时，就使用HTML中的fieldset标签用来处理。<fieldset ngModelGroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。\n\n------------------------------------------------\n\n## 路由\n路径配置的顺序是非常重要的，angular2使用“先匹配优先”的原则。\n- redirectTo 重定向\n## service \n\n```javascript\n    //post /todos\n    addTodo(desc:string):Promise<Todo>{\n        let todo={\n            id:UUID.UUID(),\n            desc:desc,\n            completed:false\n        };\n        return this.http\n            .post(this.api_url,JSON.stringfy(todo),{header:this.headers})\n            .toPromise()\n            .then(res=>res.json().data as Todo)\n            .catch(this.handleError);\n    }\n\n```\n----------------------------------------\n\n```javascript\n    inputValue: string = '';\n    @Input() placeholder: string = 'What needs to be done?';\n    @Input() delay: number = 300;\n\n    //detect the input value and output this to parent\n    @Output() textChanges = new EventEmitter<string>();\n    //detect the enter keyup event and output this to parent\n    @Output() onEnterUp = new EventEmitter<boolean>();\n    ```\n- placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。\n- 由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。\n- export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.\n\n\n--------------------------\n## 验证用户帐户的流程\n- UserService:用于通过用户名查找用户并返回用户\n- AuthService:用于认证用户，其中需要利用UserService 的方法。\n- AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。\n- @SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,\nparentModule参数也就被赋值为空。\n\n----------------\n## 路由守卫\n应用场景如下:\n该用户可能无权导航到目标组件。导航前需要用户先登录。\n\n路由器支持多种守卫：\n\n- 用CanActivate来处理导航到某路由的情况。\n- 用CanActivateChild处理导航到子路由的情况。\n- 用CanDeactivate来处理从当前路由离开的情况。\n- 用Resolve在路由激活之前获取路由数据。\n- 用CanLoad来处理异步导航到某特性模块的情况。\n\n----------------------\n## 模块优化\n 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)\n\n```javascript\n    import { NgModule } from '@angular/core';\n    import { CommonModule } from '@angular/common';\n    import { FormsModule } from '@angular/forms';\n    import { MdlModule } from 'angular2-mdl';\n\n    @NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ],\n    exports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ]\n    })\n    export class SharedModule { }\n```\n这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可\n\n\n","source":"_posts/angular基础.md","raw":"---\ntitle: angular 基础\ncategories: angular\ncomments: true\n---\n## angular 与 vue 的区别\n- angular2全部采用TypeScript编写，TypeScript（编译工具），它为JS带来了类似于Java 和C# 的静态类型，\n- vue 的双向绑定基于ES5 的getter/setter 来实现的，而angular是由自己实现一套模板编译规则们需要进行“脏”检查，而vue不需要，因此vue在性能上更高效。\n- angular 中，当watcher 越来越多时会越来越慢，因为作用域的每一次变化\n\n<!--more-->\n\n## angular \n- 组件化，数据的单向中心。es6的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：\n- DOM事件，譬如用户输入文本，点击按钮等。( ng-click )\n- XHR响应事件 ( $http )\n- 浏览器Location变更事件 ( $location )\n- Timer事件( $timeout , $interval )\n- 执行 $digest() 或 $apply()\n\n##  react \n- 速度很快：来源于虚拟DOM，只有在调用get 和 set 的时候才会更新DOM，而且是先更新虚拟DOM再更新实际的DOM，由此更新DOM 的次数少内容也会少很多。\n- FLUX 架构，react 更关注UI 的组件化和数据的单向更新。可以直接有es6的一些语法。\n- 服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是web的执行。\n- 目标是UI。\n- 本身是一个MVC 中的V。\n----------------------------\n## Angular 为表单内置了4种css样式\n\n- ng-valid 校验合法状态\n- ng-invalid 校验非法状态\n- ng-pristine 如果要使用原生的form，需要设置这个值\n- ng-dirty 表单处于脏数据状态\n-----------------------------\n## @Component\n- @Component 是Angular 提供的装饰函数，用来描述Component的元数据\n- selector 指这个组件在HTML模板中的标签是什么\n- template是嵌入（inline）的HTML模板，如果使用单独文件可用templateUrl。\n- styles是嵌入（inline）的CSS样式，如果使用单独文件可用styleUrls。\n- providers 列出会在此模块中“注入”的服务(service)-依赖注入\n- bootstrap指明哪个组件为引导组件(比如AppComponent),当angular引导应用时，它会在Dom中渲染这个引导性组件，并把结果放进index.html的该组件的标签中。\n\n## @NgModule\n@NgModule装饰器用来为模块定义元数据。declarations列出了应用中的顶层组件，在module里面声明的组件在module范围内都可以直接使用，也就是说在同一module里面的任何Component都可以在其模板文件中直接使用声明的组件，就想我们在AppComponent的模板末尾加上 <app-login></app-login> 一样。\n\n```javascript\nimport { HttpModule } from '@angular/http';\n\nimport { AppComponent } from './app.component';\nimport { LoginComponent } from './login/login.component';\n\n@NgModule({\n  declarations: [\n    AppComponent,\n    LoginComponent\n  ],\n  imports: [\n    BrowserModule,\n    FormsModule,\n    HttpModule\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule { }\n```\nNgModule装饰器用来为模块定义元数据。\n- declarations列出了应用中的顶层组件。\n- BrowerModule 提供了运行在浏览器中的应用所需要的关键服务(service)和指令(Directive),这个模块所在需要在浏览器中跑的应用都应用引用。\n- FormsModule 提供了表单处理和双向绑定等服务和指令。\n- HttpModule 提供Htpp请求和响应的服务。\n- providers 列出会在此模版中“注入”的服务（service）。\n- bootstrap 指明哪个组件为引导性组件，并把结果放到index.html 的该组件的元素标签中。\n-  静态引导AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n-------------------------------------\n\n## 依赖注入\n如果不使用依赖注入，则需要\n    //声明成员变量，其类型为service 里面自定义的方法\n\n    ```javascript\n    //第一种：\n    service:AuthService;\n\n    constructor(){\n        this.service = new AuthService();//在构造中初始化service\n    }\n    //第二种：\n\n    providers: [\n    {provide: 'auth',  useClass: AuthService}\n    ]\n    ```\n\n- 第一种：由于实例化是在组件中进行的，意味着我们如果更改service的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量service。当import 相关的服务后，这是import将类型引入进来，而provider 里面会配置这个类型的实例。\n- provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。\n ```javascript\n        onstructor(@Inject('auth') private service) {\n    }\n ```\n\n- @inject('auth'),这个修饰符的意思是请到系统配置中找到名称为auth 的那个依赖注入到我修饰的变量中。\n\n## 双向数据绑定\n- [(ngModel)]=\"username\" ,[]的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉[]就是将ngModel赋值成username这个字符串。[] 的含义是单向绑定，就是将组件中给model 赋的值会设置到HTML的input控件中。[()]是双向绑定。ngModel 是FormModule中提供的指令，它负责从Domain Model中创建一个FormControl的实例，并将这个实例和表单控件绑定.\n- @Input()是输入型绑定的修饰符，用于从数据从父组件传到子组件。\n\n---------------------------------------------\n\n## 表单验证\n```html\n    <div>\n        <input required type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            />\n            {{usernameRef.valid}}\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            {{passwordRef.valid}}\n        <button (click)=\"onClick()\">Login</button>\n        </div>\n        <div>\n        <input #usernameRef type=\"text\">\n        <button (click)=\"onClick(usernameRef.value)\">Login</button>\n        </div>\n```\n\n1. 通过#usernameRef = 'ngModel'重新加入了引用，这个引用指向了ngModel,这个引用是要在模板中使用的所以加入这个引用。\n2. 在输入框中加入#usernameRef，这个叫引用，引用的是input对象，如果想要传递input 的值，可以用usernameRef.value.\n```html\n    <div>\n        <input type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            {{ usernameRef.errors | json }}\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n        <button (click)=\"onClick()\">Login</button>\n    </div>\n```\n*ngIf = \"usernameRef.error?.required\" 的意思是当usernameRef.error.required 为true 的时候显示div 标签\n```html\n    <div>\n        <form #formRef=\"ngForm\" (ngSubmit)=\"onSubmit(formRef.value)\"> \n        <fieldset ngModelGroup=\"login\">\n            <input type=\"text\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n            <input type=\"password\"\n            name=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            required\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n            <button (click)=\"onClick()\">Login</button>\n            <button type=\"submit\">Submit</button>\n            </fieldset>\n        </form>\n        </div>\n```\n- ngModel 会注册成Form 的子控件，注册控件需要name ，这个要求我们显示的指定对应控件的name ，因此需要为input 增加name属性，在formREF.value中包含了表单所有填写项的值\n\n- 有时在表单相中表单项过多时，就使用HTML中的fieldset标签用来处理。<fieldset ngModelGroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。\n\n------------------------------------------------\n\n## 路由\n路径配置的顺序是非常重要的，angular2使用“先匹配优先”的原则。\n- redirectTo 重定向\n## service \n\n```javascript\n    //post /todos\n    addTodo(desc:string):Promise<Todo>{\n        let todo={\n            id:UUID.UUID(),\n            desc:desc,\n            completed:false\n        };\n        return this.http\n            .post(this.api_url,JSON.stringfy(todo),{header:this.headers})\n            .toPromise()\n            .then(res=>res.json().data as Todo)\n            .catch(this.handleError);\n    }\n\n```\n----------------------------------------\n\n```javascript\n    inputValue: string = '';\n    @Input() placeholder: string = 'What needs to be done?';\n    @Input() delay: number = 300;\n\n    //detect the input value and output this to parent\n    @Output() textChanges = new EventEmitter<string>();\n    //detect the enter keyup event and output this to parent\n    @Output() onEnterUp = new EventEmitter<boolean>();\n    ```\n- placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。\n- 由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。\n- export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.\n\n\n--------------------------\n## 验证用户帐户的流程\n- UserService:用于通过用户名查找用户并返回用户\n- AuthService:用于认证用户，其中需要利用UserService 的方法。\n- AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。\n- @SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,\nparentModule参数也就被赋值为空。\n\n----------------\n## 路由守卫\n应用场景如下:\n该用户可能无权导航到目标组件。导航前需要用户先登录。\n\n路由器支持多种守卫：\n\n- 用CanActivate来处理导航到某路由的情况。\n- 用CanActivateChild处理导航到子路由的情况。\n- 用CanDeactivate来处理从当前路由离开的情况。\n- 用Resolve在路由激活之前获取路由数据。\n- 用CanLoad来处理异步导航到某特性模块的情况。\n\n----------------------\n## 模块优化\n 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)\n\n```javascript\n    import { NgModule } from '@angular/core';\n    import { CommonModule } from '@angular/common';\n    import { FormsModule } from '@angular/forms';\n    import { MdlModule } from 'angular2-mdl';\n\n    @NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ],\n    exports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ]\n    })\n    export class SharedModule { }\n```\n这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可\n\n\n","slug":"angular基础","published":1,"date":"2018-01-15T08:18:09.875Z","updated":"2017-12-29T07:06:49.292Z","layout":"post","photos":[],"link":"","_id":"cjcr3j7dy000gj8vr7bjrmhqn","content":"<h2 id=\"angular-与-vue-的区别\"><a href=\"#angular-与-vue-的区别\" class=\"headerlink\" title=\"angular 与 vue 的区别\"></a>angular 与 vue 的区别</h2><ul>\n<li>angular2全部采用TypeScript编写，TypeScript（编译工具），它为JS带来了类似于Java 和C# 的静态类型，</li>\n<li>vue 的双向绑定基于ES5 的getter/setter 来实现的，而angular是由自己实现一套模板编译规则们需要进行“脏”检查，而vue不需要，因此vue在性能上更高效。</li>\n<li>angular 中，当watcher 越来越多时会越来越慢，因为作用域的每一次变化</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"angular\"><a href=\"#angular\" class=\"headerlink\" title=\"angular\"></a>angular</h2><ul>\n<li>组件化，数据的单向中心。es6的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</li>\n<li>DOM事件，譬如用户输入文本，点击按钮等。( ng-click )</li>\n<li>XHR响应事件 ( $http )</li>\n<li>浏览器Location变更事件 ( $location )</li>\n<li>Timer事件( $timeout , $interval )</li>\n<li>执行 $digest() 或 $apply()</li>\n</ul>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h2><ul>\n<li>速度很快：来源于虚拟DOM，只有在调用get 和 set 的时候才会更新DOM，而且是先更新虚拟DOM再更新实际的DOM，由此更新DOM 的次数少内容也会少很多。</li>\n<li>FLUX 架构，react 更关注UI 的组件化和数据的单向更新。可以直接有es6的一些语法。</li>\n<li>服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是web的执行。</li>\n<li>目标是UI。</li>\n<li>本身是一个MVC 中的V。</li>\n</ul>\n<hr>\n<h2 id=\"Angular-为表单内置了4种css样式\"><a href=\"#Angular-为表单内置了4种css样式\" class=\"headerlink\" title=\"Angular 为表单内置了4种css样式\"></a>Angular 为表单内置了4种css样式</h2><ul>\n<li>ng-valid 校验合法状态</li>\n<li>ng-invalid 校验非法状态</li>\n<li>ng-pristine 如果要使用原生的form，需要设置这个值</li>\n<li>ng-dirty 表单处于脏数据状态</li>\n</ul>\n<hr>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h2><ul>\n<li>@Component 是Angular 提供的装饰函数，用来描述Component的元数据</li>\n<li>selector 指这个组件在HTML模板中的标签是什么</li>\n<li>template是嵌入（inline）的HTML模板，如果使用单独文件可用templateUrl。</li>\n<li>styles是嵌入（inline）的CSS样式，如果使用单独文件可用styleUrls。</li>\n<li>providers 列出会在此模块中“注入”的服务(service)-依赖注入</li>\n<li>bootstrap指明哪个组件为引导组件(比如AppComponent),当angular引导应用时，它会在Dom中渲染这个引导性组件，并把结果放进index.html的该组件的标签中。</li>\n</ul>\n<h2 id=\"NgModule\"><a href=\"#NgModule\" class=\"headerlink\" title=\"@NgModule\"></a>@NgModule</h2><p>@NgModule装饰器用来为模块定义元数据。declarations列出了应用中的顶层组件，在module里面声明的组件在module范围内都可以直接使用，也就是说在同一module里面的任何Component都可以在其模板文件中直接使用声明的组件，就想我们在AppComponent的模板末尾加上 <app-login></app-login> 一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; HttpModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; LoginComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./login/login.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declarations: [</span><br><span class=\"line\">    AppComponent,</span><br><span class=\"line\">    LoginComponent</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  imports: [</span><br><span class=\"line\">    BrowserModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    HttpModule</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  providers: [],</span><br><span class=\"line\">  bootstrap: [AppComponent]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>NgModule装饰器用来为模块定义元数据。</p>\n<ul>\n<li>declarations列出了应用中的顶层组件。</li>\n<li>BrowerModule 提供了运行在浏览器中的应用所需要的关键服务(service)和指令(Directive),这个模块所在需要在浏览器中跑的应用都应用引用。</li>\n<li>FormsModule 提供了表单处理和双向绑定等服务和指令。</li>\n<li>HttpModule 提供Htpp请求和响应的服务。</li>\n<li>providers 列出会在此模版中“注入”的服务（service）。</li>\n<li>bootstrap 指明哪个组件为引导性组件，并把结果放到index.html 的该组件的元素标签中。</li>\n<li>静态引导AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);</li>\n</ul>\n<hr>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>如果不使用依赖注入，则需要<br>    //声明成员变量，其类型为service 里面自定义的方法</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种：</span></span><br><span class=\"line\">service:AuthService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.service = <span class=\"keyword\">new</span> AuthService();<span class=\"comment\">//在构造中初始化service</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二种：</span></span><br><span class=\"line\"></span><br><span class=\"line\">providers: [</span><br><span class=\"line\">&#123;<span class=\"attr\">provide</span>: <span class=\"string\">'auth'</span>,  <span class=\"attr\">useClass</span>: AuthService&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>第一种：由于实例化是在组件中进行的，意味着我们如果更改service的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量service。当import 相关的服务后，这是import将类型引入进来，而provider 里面会配置这个类型的实例。</li>\n<li><p>provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    onstructor(@Inject(<span class=\"string\">'auth'</span>) private service) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@inject(‘auth’),这个修饰符的意思是请到系统配置中找到名称为auth 的那个依赖注入到我修饰的变量中。</p>\n</li>\n</ul>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><ul>\n<li>[(ngModel)]=”username” ,[]的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉[]就是将ngModel赋值成username这个字符串。[] 的含义是单向绑定，就是将组件中给model 赋的值会设置到HTML的input控件中。[()]是双向绑定。ngModel 是FormModule中提供的指令，它负责从Domain Model中创建一个FormControl的实例，并将这个实例和表单控件绑定.</li>\n<li>@Input()是输入型绑定的修饰符，用于从数据从父组件传到子组件。</li>\n</ul>\n<hr>\n<h2 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;usernameRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;passwordRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">usernameRef</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick(usernameRef.value)\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过#usernameRef = ‘ngModel’重新加入了引用，这个引用指向了ngModel,这个引用是要在模板中使用的所以加入这个引用。</li>\n<li>在输入框中加入#usernameRef，这个叫引用，引用的是input对象，如果想要传递input 的值，可以用usernameRef.value.<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123; usernameRef.errors | json &#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>*ngIf = “usernameRef.error?.required” 的意思是当usernameRef.error.required 为true 的时候显示div 标签<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">formRef</span>=<span class=\"string\">\"ngForm\"</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">\"onSubmit(formRef.value)\"</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fieldset</span> <span class=\"attr\">ngModelGroup</span>=<span class=\"string\">\"login\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>ngModel 会注册成Form 的子控件，注册控件需要name ，这个要求我们显示的指定对应控件的name ，因此需要为input 增加name属性，在formREF.value中包含了表单所有填写项的值</p>\n</li>\n<li><p>有时在表单相中表单项过多时，就使用HTML中的fieldset标签用来处理。<fieldset ngmodelgroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。</fieldset></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>路径配置的顺序是非常重要的，angular2使用“先匹配优先”的原则。</p>\n<ul>\n<li>redirectTo 重定向<h2 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h2></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//post /todos</span></span><br><span class=\"line\">addTodo(desc:string):<span class=\"built_in\">Promise</span>&lt;Todo&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> todo=&#123;</span><br><span class=\"line\">        id:UUID.UUID(),</span><br><span class=\"line\">        desc:desc,</span><br><span class=\"line\">        completed:<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http</span><br><span class=\"line\">        .post(<span class=\"keyword\">this</span>.api_url,<span class=\"built_in\">JSON</span>.stringfy(todo),&#123;<span class=\"attr\">header</span>:<span class=\"keyword\">this</span>.headers&#125;)</span><br><span class=\"line\">        .toPromise()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>res.json().data <span class=\"keyword\">as</span> Todo)</span><br><span class=\"line\">        .catch(<span class=\"keyword\">this</span>.handleError);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputValue: string = <span class=\"string\">''</span>;</span><br><span class=\"line\">@Input() placeholder: string = <span class=\"string\">'What needs to be done?'</span>;</span><br><span class=\"line\">@Input() delay: number = <span class=\"number\">300</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//detect the input value and output this to parent</span></span><br><span class=\"line\">@Output() textChanges = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\"><span class=\"comment\">//detect the enter keyup event and output this to parent</span></span><br><span class=\"line\">@Output() onEnterUp = <span class=\"keyword\">new</span> EventEmitter&lt;boolean&gt;();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。</li>\n<li>由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。</li>\n<li>export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.</li>\n</ul>\n<hr>\n<h2 id=\"验证用户帐户的流程\"><a href=\"#验证用户帐户的流程\" class=\"headerlink\" title=\"验证用户帐户的流程\"></a>验证用户帐户的流程</h2><ul>\n<li>UserService:用于通过用户名查找用户并返回用户</li>\n<li>AuthService:用于认证用户，其中需要利用UserService 的方法。</li>\n<li>AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。</li>\n<li>@SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,<br>parentModule参数也就被赋值为空。</li>\n</ul>\n<hr>\n<h2 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h2><p>应用场景如下:<br>该用户可能无权导航到目标组件。导航前需要用户先登录。</p>\n<p>路由器支持多种守卫：</p>\n<ul>\n<li>用CanActivate来处理导航到某路由的情况。</li>\n<li>用CanActivateChild处理导航到子路由的情况。</li>\n<li>用CanDeactivate来处理从当前路由离开的情况。</li>\n<li>用Resolve在路由激活之前获取路由数据。</li>\n<li>用CanLoad来处理异步导航到某特性模块的情况。</li>\n</ul>\n<hr>\n<h2 id=\"模块优化\"><a href=\"#模块优化\" class=\"headerlink\" title=\"模块优化\"></a>模块优化</h2><p> 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; CommonModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/common'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; FormsModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/forms'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; MdlModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2-mdl'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">imports: [</span><br><span class=\"line\">    CommonModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    MdlModule</span><br><span class=\"line\">],</span><br><span class=\"line\">exports: [</span><br><span class=\"line\">    CommonModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    MdlModule</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"angular-与-vue-的区别\"><a href=\"#angular-与-vue-的区别\" class=\"headerlink\" title=\"angular 与 vue 的区别\"></a>angular 与 vue 的区别</h2><ul>\n<li>angular2全部采用TypeScript编写，TypeScript（编译工具），它为JS带来了类似于Java 和C# 的静态类型，</li>\n<li>vue 的双向绑定基于ES5 的getter/setter 来实现的，而angular是由自己实现一套模板编译规则们需要进行“脏”检查，而vue不需要，因此vue在性能上更高效。</li>\n<li>angular 中，当watcher 越来越多时会越来越慢，因为作用域的每一次变化</li>\n</ul>","more":"<h2 id=\"angular\"><a href=\"#angular\" class=\"headerlink\" title=\"angular\"></a>angular</h2><ul>\n<li>组件化，数据的单向中心。es6的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下：</li>\n<li>DOM事件，譬如用户输入文本，点击按钮等。( ng-click )</li>\n<li>XHR响应事件 ( $http )</li>\n<li>浏览器Location变更事件 ( $location )</li>\n<li>Timer事件( $timeout , $interval )</li>\n<li>执行 $digest() 或 $apply()</li>\n</ul>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h2><ul>\n<li>速度很快：来源于虚拟DOM，只有在调用get 和 set 的时候才会更新DOM，而且是先更新虚拟DOM再更新实际的DOM，由此更新DOM 的次数少内容也会少很多。</li>\n<li>FLUX 架构，react 更关注UI 的组件化和数据的单向更新。可以直接有es6的一些语法。</li>\n<li>服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是web的执行。</li>\n<li>目标是UI。</li>\n<li>本身是一个MVC 中的V。</li>\n</ul>\n<hr>\n<h2 id=\"Angular-为表单内置了4种css样式\"><a href=\"#Angular-为表单内置了4种css样式\" class=\"headerlink\" title=\"Angular 为表单内置了4种css样式\"></a>Angular 为表单内置了4种css样式</h2><ul>\n<li>ng-valid 校验合法状态</li>\n<li>ng-invalid 校验非法状态</li>\n<li>ng-pristine 如果要使用原生的form，需要设置这个值</li>\n<li>ng-dirty 表单处于脏数据状态</li>\n</ul>\n<hr>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h2><ul>\n<li>@Component 是Angular 提供的装饰函数，用来描述Component的元数据</li>\n<li>selector 指这个组件在HTML模板中的标签是什么</li>\n<li>template是嵌入（inline）的HTML模板，如果使用单独文件可用templateUrl。</li>\n<li>styles是嵌入（inline）的CSS样式，如果使用单独文件可用styleUrls。</li>\n<li>providers 列出会在此模块中“注入”的服务(service)-依赖注入</li>\n<li>bootstrap指明哪个组件为引导组件(比如AppComponent),当angular引导应用时，它会在Dom中渲染这个引导性组件，并把结果放进index.html的该组件的标签中。</li>\n</ul>\n<h2 id=\"NgModule\"><a href=\"#NgModule\" class=\"headerlink\" title=\"@NgModule\"></a>@NgModule</h2><p>@NgModule装饰器用来为模块定义元数据。declarations列出了应用中的顶层组件，在module里面声明的组件在module范围内都可以直接使用，也就是说在同一module里面的任何Component都可以在其模板文件中直接使用声明的组件，就想我们在AppComponent的模板末尾加上 <app-login></app-login> 一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; HttpModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; LoginComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./login/login.component'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declarations: [</span><br><span class=\"line\">    AppComponent,</span><br><span class=\"line\">    LoginComponent</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  imports: [</span><br><span class=\"line\">    BrowserModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    HttpModule</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  providers: [],</span><br><span class=\"line\">  bootstrap: [AppComponent]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>NgModule装饰器用来为模块定义元数据。</p>\n<ul>\n<li>declarations列出了应用中的顶层组件。</li>\n<li>BrowerModule 提供了运行在浏览器中的应用所需要的关键服务(service)和指令(Directive),这个模块所在需要在浏览器中跑的应用都应用引用。</li>\n<li>FormsModule 提供了表单处理和双向绑定等服务和指令。</li>\n<li>HttpModule 提供Htpp请求和响应的服务。</li>\n<li>providers 列出会在此模版中“注入”的服务（service）。</li>\n<li>bootstrap 指明哪个组件为引导性组件，并把结果放到index.html 的该组件的元素标签中。</li>\n<li>静态引导AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);</li>\n</ul>\n<hr>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>如果不使用依赖注入，则需要<br>    //声明成员变量，其类型为service 里面自定义的方法</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种：</span></span><br><span class=\"line\">service:AuthService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.service = <span class=\"keyword\">new</span> AuthService();<span class=\"comment\">//在构造中初始化service</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二种：</span></span><br><span class=\"line\"></span><br><span class=\"line\">providers: [</span><br><span class=\"line\">&#123;<span class=\"attr\">provide</span>: <span class=\"string\">'auth'</span>,  <span class=\"attr\">useClass</span>: AuthService&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>第一种：由于实例化是在组件中进行的，意味着我们如果更改service的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量service。当import 相关的服务后，这是import将类型引入进来，而provider 里面会配置这个类型的实例。</li>\n<li><p>provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    onstructor(@Inject(<span class=\"string\">'auth'</span>) private service) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>@inject(‘auth’),这个修饰符的意思是请到系统配置中找到名称为auth 的那个依赖注入到我修饰的变量中。</p>\n</li>\n</ul>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><ul>\n<li>[(ngModel)]=”username” ,[]的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉[]就是将ngModel赋值成username这个字符串。[] 的含义是单向绑定，就是将组件中给model 赋的值会设置到HTML的input控件中。[()]是双向绑定。ngModel 是FormModule中提供的指令，它负责从Domain Model中创建一个FormControl的实例，并将这个实例和表单控件绑定.</li>\n<li>@Input()是输入型绑定的修饰符，用于从数据从父组件传到子组件。</li>\n</ul>\n<hr>\n<h2 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;usernameRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;passwordRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">usernameRef</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick(usernameRef.value)\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过#usernameRef = ‘ngModel’重新加入了引用，这个引用指向了ngModel,这个引用是要在模板中使用的所以加入这个引用。</li>\n<li>在输入框中加入#usernameRef，这个叫引用，引用的是input对象，如果想要传递input 的值，可以用usernameRef.value.<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123; usernameRef.errors | json &#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>*ngIf = “usernameRef.error?.required” 的意思是当usernameRef.error.required 为true 的时候显示div 标签<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">formRef</span>=<span class=\"string\">\"ngForm\"</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">\"onSubmit(formRef.value)\"</span>&gt;</span> </span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fieldset</span> <span class=\"attr\">ngModelGroup</span>=<span class=\"string\">\"login\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><p>ngModel 会注册成Form 的子控件，注册控件需要name ，这个要求我们显示的指定对应控件的name ，因此需要为input 增加name属性，在formREF.value中包含了表单所有填写项的值</p>\n</li>\n<li><p>有时在表单相中表单项过多时，就使用HTML中的fieldset标签用来处理。<fieldset ngmodelgroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。</fieldset></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>路径配置的顺序是非常重要的，angular2使用“先匹配优先”的原则。</p>\n<ul>\n<li>redirectTo 重定向<h2 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h2></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//post /todos</span></span><br><span class=\"line\">addTodo(desc:string):<span class=\"built_in\">Promise</span>&lt;Todo&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> todo=&#123;</span><br><span class=\"line\">        id:UUID.UUID(),</span><br><span class=\"line\">        desc:desc,</span><br><span class=\"line\">        completed:<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http</span><br><span class=\"line\">        .post(<span class=\"keyword\">this</span>.api_url,<span class=\"built_in\">JSON</span>.stringfy(todo),&#123;<span class=\"attr\">header</span>:<span class=\"keyword\">this</span>.headers&#125;)</span><br><span class=\"line\">        .toPromise()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>res.json().data <span class=\"keyword\">as</span> Todo)</span><br><span class=\"line\">        .catch(<span class=\"keyword\">this</span>.handleError);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inputValue: string = <span class=\"string\">''</span>;</span><br><span class=\"line\">@Input() placeholder: string = <span class=\"string\">'What needs to be done?'</span>;</span><br><span class=\"line\">@Input() delay: number = <span class=\"number\">300</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//detect the input value and output this to parent</span></span><br><span class=\"line\">@Output() textChanges = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\"><span class=\"comment\">//detect the enter keyup event and output this to parent</span></span><br><span class=\"line\">@Output() onEnterUp = <span class=\"keyword\">new</span> EventEmitter&lt;boolean&gt;();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。</li>\n<li>由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。</li>\n<li>export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.</li>\n</ul>\n<hr>\n<h2 id=\"验证用户帐户的流程\"><a href=\"#验证用户帐户的流程\" class=\"headerlink\" title=\"验证用户帐户的流程\"></a>验证用户帐户的流程</h2><ul>\n<li>UserService:用于通过用户名查找用户并返回用户</li>\n<li>AuthService:用于认证用户，其中需要利用UserService 的方法。</li>\n<li>AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。</li>\n<li>@SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,<br>parentModule参数也就被赋值为空。</li>\n</ul>\n<hr>\n<h2 id=\"路由守卫\"><a href=\"#路由守卫\" class=\"headerlink\" title=\"路由守卫\"></a>路由守卫</h2><p>应用场景如下:<br>该用户可能无权导航到目标组件。导航前需要用户先登录。</p>\n<p>路由器支持多种守卫：</p>\n<ul>\n<li>用CanActivate来处理导航到某路由的情况。</li>\n<li>用CanActivateChild处理导航到子路由的情况。</li>\n<li>用CanDeactivate来处理从当前路由离开的情况。</li>\n<li>用Resolve在路由激活之前获取路由数据。</li>\n<li>用CanLoad来处理异步导航到某特性模块的情况。</li>\n</ul>\n<hr>\n<h2 id=\"模块优化\"><a href=\"#模块优化\" class=\"headerlink\" title=\"模块优化\"></a>模块优化</h2><p> 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; CommonModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/common'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; FormsModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/forms'</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; MdlModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2-mdl'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">imports: [</span><br><span class=\"line\">    CommonModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    MdlModule</span><br><span class=\"line\">],</span><br><span class=\"line\">exports: [</span><br><span class=\"line\">    CommonModule,</span><br><span class=\"line\">    FormsModule,</span><br><span class=\"line\">    MdlModule</span><br><span class=\"line\">]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可</p>"},{"title":"css 小技巧","_content":"css 在开发中的填坑总结\n\n<!--more-->\n\n## 一、利用css 的content属性attr 抓取资料\n想要获取伪元素，可以用以下写法：\n\n```html\n<div data-msg=\"open\"></div>\ndiv:hover:after{\n    content:attr(data-mag);\n}\n```\n\n## 二、利用：valid 和：invalid来做表单即使校验\n- :required 伪类指定具有required 属性的表单元素\n- :valid 伪类指定一个通过匹配正确的所要求的表单元素\n- :invalid 伪类指定一个不匹配指定要求的表单元素\n\n## 三、writing-mode\n使用writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;\n\n## 四、实现鼠标悬浮内容自动撑开的过渡动画\n需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：\n\n```html\n<ul>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n</ul>\n.bd {\n  max-height:0;\n  overflow:hidden;\n  transition: all 1s ease-out;\n}\nli:hover .bd {\n  max-height: 600px;\n  transition-timing-function: ease-in;\n}\n```\n\n## 五、移动端web页面支持弹性滚动\n-webkit-overflow-scrolling: touch;\n\n\n## 六、美化浏览器自带的 radio ，checkbox 属性\n```html\n<div class=\"radio-beauty-container\">\n    <label>\n        <span class=\"radio-name\">前端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName1\" hidden/>\n        <label for=\"radioName1\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">后端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName2\" hidden/>\n        <label for=\"radioName2\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">全栈工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName3\" hidden/>\n        <label for=\"radioName3\" class=\"radio-beauty\"></label>\n    </label>\n</div>\n.radio-beauty-container {\n    font-size: 0;\n    $bgc: green;\n    %common {\n        padding: 2px;\n        background-color: $bgc;\n        background-clip: content-box;\n    }\n    .radio-name {\n        vertical-align: middle;\n        font-size: 16px;\n    }\n    .radio-beauty {\n        width: 18px;\n        height: 18px;\n        box-sizing: border-box;\n        display: inline-block;\n        border: 1px solid $bgc;\n        vertical-align: middle;\n        margin: 0 15px 0 3px;\n        border-radius: 50%;\n        &:hover {\n            box-shadow: 0 0 7px $bgc;\n            @extend %common;\n        }\n    }\n    input[type=\"radio\"]:checked+.radio-beauty {\n        @extend %common;\n    }\n}\n```\n\n## 七、改变 input 焦点光标的颜色\n```html\n<input value=\"This field uses a default caret.\" />\n<input class=\"custom\" value=\"I have a custom caret color!\" />\ninput {\n  caret-color: auto;\n  display: block;\n  margin-bottom: .5em;\n}\n\ninput.custom {\n  caret-color: red;\n}\n```\n\n## 八、rem 布局不再使用 JavaScript 设置\n现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：\n```html\nhtml{\nfont-size: 100vw / 750\n}\n```\n## 切角兄效果实现\n切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成45°的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。\n\n![](https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67)","source":"_posts/css-小技巧.md","raw":"---\ntitle: css 小技巧\ncategories: css\n---\ncss 在开发中的填坑总结\n\n<!--more-->\n\n## 一、利用css 的content属性attr 抓取资料\n想要获取伪元素，可以用以下写法：\n\n```html\n<div data-msg=\"open\"></div>\ndiv:hover:after{\n    content:attr(data-mag);\n}\n```\n\n## 二、利用：valid 和：invalid来做表单即使校验\n- :required 伪类指定具有required 属性的表单元素\n- :valid 伪类指定一个通过匹配正确的所要求的表单元素\n- :invalid 伪类指定一个不匹配指定要求的表单元素\n\n## 三、writing-mode\n使用writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;\n\n## 四、实现鼠标悬浮内容自动撑开的过渡动画\n需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：\n\n```html\n<ul>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n</ul>\n.bd {\n  max-height:0;\n  overflow:hidden;\n  transition: all 1s ease-out;\n}\nli:hover .bd {\n  max-height: 600px;\n  transition-timing-function: ease-in;\n}\n```\n\n## 五、移动端web页面支持弹性滚动\n-webkit-overflow-scrolling: touch;\n\n\n## 六、美化浏览器自带的 radio ，checkbox 属性\n```html\n<div class=\"radio-beauty-container\">\n    <label>\n        <span class=\"radio-name\">前端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName1\" hidden/>\n        <label for=\"radioName1\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">后端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName2\" hidden/>\n        <label for=\"radioName2\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">全栈工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName3\" hidden/>\n        <label for=\"radioName3\" class=\"radio-beauty\"></label>\n    </label>\n</div>\n.radio-beauty-container {\n    font-size: 0;\n    $bgc: green;\n    %common {\n        padding: 2px;\n        background-color: $bgc;\n        background-clip: content-box;\n    }\n    .radio-name {\n        vertical-align: middle;\n        font-size: 16px;\n    }\n    .radio-beauty {\n        width: 18px;\n        height: 18px;\n        box-sizing: border-box;\n        display: inline-block;\n        border: 1px solid $bgc;\n        vertical-align: middle;\n        margin: 0 15px 0 3px;\n        border-radius: 50%;\n        &:hover {\n            box-shadow: 0 0 7px $bgc;\n            @extend %common;\n        }\n    }\n    input[type=\"radio\"]:checked+.radio-beauty {\n        @extend %common;\n    }\n}\n```\n\n## 七、改变 input 焦点光标的颜色\n```html\n<input value=\"This field uses a default caret.\" />\n<input class=\"custom\" value=\"I have a custom caret color!\" />\ninput {\n  caret-color: auto;\n  display: block;\n  margin-bottom: .5em;\n}\n\ninput.custom {\n  caret-color: red;\n}\n```\n\n## 八、rem 布局不再使用 JavaScript 设置\n现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：\n```html\nhtml{\nfont-size: 100vw / 750\n}\n```\n## 切角兄效果实现\n切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成45°的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。\n\n![](https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67)","slug":"css-小技巧","published":1,"date":"2018-01-15T08:18:09.881Z","updated":"2017-12-29T07:06:49.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7e2000hj8vr19i8mbur","content":"<p>css 在开发中的填坑总结</p>\n<a id=\"more\"></a>\n<h2 id=\"一、利用css-的content属性attr-抓取资料\"><a href=\"#一、利用css-的content属性attr-抓取资料\" class=\"headerlink\" title=\"一、利用css 的content属性attr 抓取资料\"></a>一、利用css 的content属性attr 抓取资料</h2><p>想要获取伪元素，可以用以下写法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-msg</span>=<span class=\"string\">\"open\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">div:hover:after&#123;</span><br><span class=\"line\">    content:attr(data-mag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、利用：valid-和：invalid来做表单即使校验\"><a href=\"#二、利用：valid-和：invalid来做表单即使校验\" class=\"headerlink\" title=\"二、利用：valid 和：invalid来做表单即使校验\"></a>二、利用：valid 和：invalid来做表单即使校验</h2><ul>\n<li>:required 伪类指定具有required 属性的表单元素</li>\n<li>:valid 伪类指定一个通过匹配正确的所要求的表单元素</li>\n<li>:invalid 伪类指定一个不匹配指定要求的表单元素</li>\n</ul>\n<h2 id=\"三、writing-mode\"><a href=\"#三、writing-mode\" class=\"headerlink\" title=\"三、writing-mode\"></a>三、writing-mode</h2><p>使用writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;</p>\n<h2 id=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"><a href=\"#四、实现鼠标悬浮内容自动撑开的过渡动画\" class=\"headerlink\" title=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"></a>四、实现鼠标悬浮内容自动撑开的过渡动画</h2><p>需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">.bd &#123;</span><br><span class=\"line\">  max-height:0;</span><br><span class=\"line\">  overflow:hidden;</span><br><span class=\"line\">  transition: all 1s ease-out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">li:hover .bd &#123;</span><br><span class=\"line\">  max-height: 600px;</span><br><span class=\"line\">  transition-timing-function: ease-in;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、移动端web页面支持弹性滚动\"><a href=\"#五、移动端web页面支持弹性滚动\" class=\"headerlink\" title=\"五、移动端web页面支持弹性滚动\"></a>五、移动端web页面支持弹性滚动</h2><p>-webkit-overflow-scrolling: touch;</p>\n<h2 id=\"六、美化浏览器自带的-radio-，checkbox-属性\"><a href=\"#六、美化浏览器自带的-radio-，checkbox-属性\" class=\"headerlink\" title=\"六、美化浏览器自带的 radio ，checkbox 属性\"></a>六、美化浏览器自带的 radio ，checkbox 属性</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty-container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>前端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>后端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>全栈工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.radio-beauty-container &#123;</span><br><span class=\"line\">    font-size: 0;</span><br><span class=\"line\">    $bgc: green;</span><br><span class=\"line\">    %common &#123;</span><br><span class=\"line\">        padding: 2px;</span><br><span class=\"line\">        background-color: $bgc;</span><br><span class=\"line\">        background-clip: content-box;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-name &#123;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        font-size: 16px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-beauty &#123;</span><br><span class=\"line\">        width: 18px;</span><br><span class=\"line\">        height: 18px;</span><br><span class=\"line\">        box-sizing: border-box;</span><br><span class=\"line\">        display: inline-block;</span><br><span class=\"line\">        border: 1px solid $bgc;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        margin: 0 15px 0 3px;</span><br><span class=\"line\">        border-radius: 50%;</span><br><span class=\"line\">        &amp;:hover &#123;</span><br><span class=\"line\">            box-shadow: 0 0 7px $bgc;</span><br><span class=\"line\">            @extend %common;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    input[type=\"radio\"]:checked+.radio-beauty &#123;</span><br><span class=\"line\">        @extend %common;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"七、改变-input-焦点光标的颜色\"><a href=\"#七、改变-input-焦点光标的颜色\" class=\"headerlink\" title=\"七、改变 input 焦点光标的颜色\"></a>七、改变 input 焦点光标的颜色</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"This field uses a default caret.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"custom\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"I have a custom caret color!\"</span> /&gt;</span></span><br><span class=\"line\">input &#123;</span><br><span class=\"line\">  caret-color: auto;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  margin-bottom: .5em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">input.custom &#123;</span><br><span class=\"line\">  caret-color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"八、rem-布局不再使用-JavaScript-设置\"><a href=\"#八、rem-布局不再使用-JavaScript-设置\" class=\"headerlink\" title=\"八、rem 布局不再使用 JavaScript 设置\"></a>八、rem 布局不再使用 JavaScript 设置</h2><p>现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html&#123;</span><br><span class=\"line\">font-size: 100vw / 750</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"切角兄效果实现\"><a href=\"#切角兄效果实现\" class=\"headerlink\" title=\"切角兄效果实现\"></a>切角兄效果实现</h2><p>切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成45°的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。</p>\n<p><img src=\"https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<p>css 在开发中的填坑总结</p>","more":"<h2 id=\"一、利用css-的content属性attr-抓取资料\"><a href=\"#一、利用css-的content属性attr-抓取资料\" class=\"headerlink\" title=\"一、利用css 的content属性attr 抓取资料\"></a>一、利用css 的content属性attr 抓取资料</h2><p>想要获取伪元素，可以用以下写法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-msg</span>=<span class=\"string\">\"open\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">div:hover:after&#123;</span><br><span class=\"line\">    content:attr(data-mag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、利用：valid-和：invalid来做表单即使校验\"><a href=\"#二、利用：valid-和：invalid来做表单即使校验\" class=\"headerlink\" title=\"二、利用：valid 和：invalid来做表单即使校验\"></a>二、利用：valid 和：invalid来做表单即使校验</h2><ul>\n<li>:required 伪类指定具有required 属性的表单元素</li>\n<li>:valid 伪类指定一个通过匹配正确的所要求的表单元素</li>\n<li>:invalid 伪类指定一个不匹配指定要求的表单元素</li>\n</ul>\n<h2 id=\"三、writing-mode\"><a href=\"#三、writing-mode\" class=\"headerlink\" title=\"三、writing-mode\"></a>三、writing-mode</h2><p>使用writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;</p>\n<h2 id=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"><a href=\"#四、实现鼠标悬浮内容自动撑开的过渡动画\" class=\"headerlink\" title=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"></a>四、实现鼠标悬浮内容自动撑开的过渡动画</h2><p>需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">.bd &#123;</span><br><span class=\"line\">  max-height:0;</span><br><span class=\"line\">  overflow:hidden;</span><br><span class=\"line\">  transition: all 1s ease-out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">li:hover .bd &#123;</span><br><span class=\"line\">  max-height: 600px;</span><br><span class=\"line\">  transition-timing-function: ease-in;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、移动端web页面支持弹性滚动\"><a href=\"#五、移动端web页面支持弹性滚动\" class=\"headerlink\" title=\"五、移动端web页面支持弹性滚动\"></a>五、移动端web页面支持弹性滚动</h2><p>-webkit-overflow-scrolling: touch;</p>\n<h2 id=\"六、美化浏览器自带的-radio-，checkbox-属性\"><a href=\"#六、美化浏览器自带的-radio-，checkbox-属性\" class=\"headerlink\" title=\"六、美化浏览器自带的 radio ，checkbox 属性\"></a>六、美化浏览器自带的 radio ，checkbox 属性</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty-container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>前端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>后端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>全栈工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.radio-beauty-container &#123;</span><br><span class=\"line\">    font-size: 0;</span><br><span class=\"line\">    $bgc: green;</span><br><span class=\"line\">    %common &#123;</span><br><span class=\"line\">        padding: 2px;</span><br><span class=\"line\">        background-color: $bgc;</span><br><span class=\"line\">        background-clip: content-box;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-name &#123;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        font-size: 16px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-beauty &#123;</span><br><span class=\"line\">        width: 18px;</span><br><span class=\"line\">        height: 18px;</span><br><span class=\"line\">        box-sizing: border-box;</span><br><span class=\"line\">        display: inline-block;</span><br><span class=\"line\">        border: 1px solid $bgc;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        margin: 0 15px 0 3px;</span><br><span class=\"line\">        border-radius: 50%;</span><br><span class=\"line\">        &amp;:hover &#123;</span><br><span class=\"line\">            box-shadow: 0 0 7px $bgc;</span><br><span class=\"line\">            @extend %common;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    input[type=\"radio\"]:checked+.radio-beauty &#123;</span><br><span class=\"line\">        @extend %common;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"七、改变-input-焦点光标的颜色\"><a href=\"#七、改变-input-焦点光标的颜色\" class=\"headerlink\" title=\"七、改变 input 焦点光标的颜色\"></a>七、改变 input 焦点光标的颜色</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"This field uses a default caret.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"custom\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"I have a custom caret color!\"</span> /&gt;</span></span><br><span class=\"line\">input &#123;</span><br><span class=\"line\">  caret-color: auto;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  margin-bottom: .5em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">input.custom &#123;</span><br><span class=\"line\">  caret-color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"八、rem-布局不再使用-JavaScript-设置\"><a href=\"#八、rem-布局不再使用-JavaScript-设置\" class=\"headerlink\" title=\"八、rem 布局不再使用 JavaScript 设置\"></a>八、rem 布局不再使用 JavaScript 设置</h2><p>现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：<br><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html&#123;</span><br><span class=\"line\">font-size: 100vw / 750</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"切角兄效果实现\"><a href=\"#切角兄效果实现\" class=\"headerlink\" title=\"切角兄效果实现\"></a>切角兄效果实现</h2><p>切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成45°的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。</p>\n<p><img src=\"https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67\" alt=\"\"></p>"},{"title":"react-native 入门","_content":"react-native 入门基础笔记：\n使用 ：react-native init AwesomeProject 进行构建 react-native 项目\n\n<!--more-->\n\n## react-native 目录详解\n\n里面有四个文件夹：\n\n- android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；\n- node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；\n- js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自\n","source":"_posts/react-native-入门.md","raw":"---\ntitle: react-native 入门\ncategories: react-native\ntags:\n---\nreact-native 入门基础笔记：\n使用 ：react-native init AwesomeProject 进行构建 react-native 项目\n\n<!--more-->\n\n## react-native 目录详解\n\n里面有四个文件夹：\n\n- android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；\n- node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；\n- js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自\n","slug":"react-native-入门","published":1,"date":"2018-01-16T01:10:46.819Z","updated":"2018-01-16T01:10:46.820Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7e7000kj8vraonrr34p","content":"<p>react-native 入门基础笔记：<br>使用 ：react-native init AwesomeProject 进行构建 react-native 项目</p>\n<a id=\"more\"></a>\n<h2 id=\"react-native-目录详解\"><a href=\"#react-native-目录详解\" class=\"headerlink\" title=\"react-native 目录详解\"></a>react-native 目录详解</h2><p>里面有四个文件夹：</p>\n<ul>\n<li>android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；</li>\n<li>node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；</li>\n<li>js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>react-native 入门基础笔记：<br>使用 ：react-native init AwesomeProject 进行构建 react-native 项目</p>","more":"<h2 id=\"react-native-目录详解\"><a href=\"#react-native-目录详解\" class=\"headerlink\" title=\"react-native 目录详解\"></a>react-native 目录详解</h2><p>里面有四个文件夹：</p>\n<ul>\n<li>android / ios：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；</li>\n<li>node_modules：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；</li>\n<li>js：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自</li>\n</ul>"},{"title":"localstorage","_content":"HTML5中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。**Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费**。\n\nweb storage 提供了两个存储对象：localStorage和sessionStorage。\n<!--more-->\n\n## localStorage和sessionStorage\n\nsessionStorage存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于sessionStorage存储的数据。也是由这些特性导致sessionStorage的使用场景较少。\n\nlocalStorage可以永久存储，而且同源下数据多窗口可以共享。\n\n## localStorage的基本使用\n有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：\n\n```javascript\ntry {  \n  localStorage.setItem(key, value);\n} catch(e) {\n  if (isQuotaExceeded(e)) {\n    // Storage full, maybe notify user or do some clean-up\n  }\n}\n\nfunction isQuotaExceeded(e) {  \n  var quotaExceeded = false;\n  if (e) {\n    if (e.code) {\n      switch (e.code) {\n        case 22:\n          quotaExceeded = true;\n          break;\n        case 1014:\n          // Firefox\n          if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n            quotaExceeded = true;\n          }\n          break;\n      }\n    } else if (e.number === -2147024882) {\n      // Internet Explorer 8\n      quotaExceeded = true;\n    }\n  }\n  return quotaExceeded;\n\n  ```\n  另外在存储容量快满时，会造成 getItem 性能急剧下降\n\n  \n","source":"_posts/localstorage.md","raw":"---\ntitle: localstorage\ncategories: webAPI\n---\nHTML5中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。**Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费**。\n\nweb storage 提供了两个存储对象：localStorage和sessionStorage。\n<!--more-->\n\n## localStorage和sessionStorage\n\nsessionStorage存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于sessionStorage存储的数据。也是由这些特性导致sessionStorage的使用场景较少。\n\nlocalStorage可以永久存储，而且同源下数据多窗口可以共享。\n\n## localStorage的基本使用\n有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：\n\n```javascript\ntry {  \n  localStorage.setItem(key, value);\n} catch(e) {\n  if (isQuotaExceeded(e)) {\n    // Storage full, maybe notify user or do some clean-up\n  }\n}\n\nfunction isQuotaExceeded(e) {  \n  var quotaExceeded = false;\n  if (e) {\n    if (e.code) {\n      switch (e.code) {\n        case 22:\n          quotaExceeded = true;\n          break;\n        case 1014:\n          // Firefox\n          if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n            quotaExceeded = true;\n          }\n          break;\n      }\n    } else if (e.number === -2147024882) {\n      // Internet Explorer 8\n      quotaExceeded = true;\n    }\n  }\n  return quotaExceeded;\n\n  ```\n  另外在存储容量快满时，会造成 getItem 性能急剧下降\n\n  \n","slug":"localstorage","published":1,"date":"2018-01-15T08:18:09.884Z","updated":"2017-12-29T07:06:49.293Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7ea000lj8vr53zj5391","content":"<p>HTML5中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。<strong>Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费</strong>。</p>\n<p>web storage 提供了两个存储对象：localStorage和sessionStorage。<br><a id=\"more\"></a></p>\n<h2 id=\"localStorage和sessionStorage\"><a href=\"#localStorage和sessionStorage\" class=\"headerlink\" title=\"localStorage和sessionStorage\"></a>localStorage和sessionStorage</h2><p>sessionStorage存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于sessionStorage存储的数据。也是由这些特性导致sessionStorage的使用场景较少。</p>\n<p>localStorage可以永久存储，而且同源下数据多窗口可以共享。</p>\n<h2 id=\"localStorage的基本使用\"><a href=\"#localStorage的基本使用\" class=\"headerlink\" title=\"localStorage的基本使用\"></a>localStorage的基本使用</h2><p>有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">  localStorage.setItem(key, value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isQuotaExceeded(e)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Storage full, maybe notify user or do some clean-up</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isQuotaExceeded</span>(<span class=\"params\">e</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> quotaExceeded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.code) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (e.code) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">22</span>:</span><br><span class=\"line\">          quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1014</span>:</span><br><span class=\"line\">          <span class=\"comment\">// Firefox</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.name === <span class=\"string\">'NS_ERROR_DOM_QUOTA_REACHED'</span>) &#123;</span><br><span class=\"line\">            quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e.number === <span class=\"number\">-2147024882</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Internet Explorer 8</span></span><br><span class=\"line\">      quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quotaExceeded;</span><br></pre></td></tr></table></figure>\n<p>  另外在存储容量快满时，会造成 getItem 性能急剧下降</p>\n","site":{"data":{}},"excerpt":"<p>HTML5中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。<strong>Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费</strong>。</p>\n<p>web storage 提供了两个存储对象：localStorage和sessionStorage。<br>","more":"</p>\n<h2 id=\"localStorage和sessionStorage\"><a href=\"#localStorage和sessionStorage\" class=\"headerlink\" title=\"localStorage和sessionStorage\"></a>localStorage和sessionStorage</h2><p>sessionStorage存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于sessionStorage存储的数据。也是由这些特性导致sessionStorage的使用场景较少。</p>\n<p>localStorage可以永久存储，而且同源下数据多窗口可以共享。</p>\n<h2 id=\"localStorage的基本使用\"><a href=\"#localStorage的基本使用\" class=\"headerlink\" title=\"localStorage的基本使用\"></a>localStorage的基本使用</h2><p>有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;  </span><br><span class=\"line\">  localStorage.setItem(key, value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isQuotaExceeded(e)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Storage full, maybe notify user or do some clean-up</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isQuotaExceeded</span>(<span class=\"params\">e</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> quotaExceeded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.code) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (e.code) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">22</span>:</span><br><span class=\"line\">          quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1014</span>:</span><br><span class=\"line\">          <span class=\"comment\">// Firefox</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.name === <span class=\"string\">'NS_ERROR_DOM_QUOTA_REACHED'</span>) &#123;</span><br><span class=\"line\">            quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e.number === <span class=\"number\">-2147024882</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Internet Explorer 8</span></span><br><span class=\"line\">      quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quotaExceeded;</span><br></pre></td></tr></table></figure>\n<p>  另外在存储容量快满时，会造成 getItem 性能急剧下降</p>"},{"title":"this指向","date":"2018-01-23T03:39:32.000Z","_content":"\n[链接](http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w)\n\n1. js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。\n2. 普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过\n   call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。\n3. this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。\n\n<!--more-->\n\n## 默认绑定\n\n在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就\n会应用默认绑定规则，默认绑定的指向的是全局作用域。\n\n```javascript\n<script type=\"text/javascript\" charset=\"utf-8\">\n  var name = \"g\";\n  function a() {\n      console.log(this.name);        //g\n      a.name = 'inside';\n      function b() {\n          console.log(this.name);  //g\n\n\n      }\n      b();\n  }\n  a();\n</script>\n```\n\na() 函数在全局作用域中被调用，因此第 1 句中的 this 就绑定在了全局对象上。b() 函数在 a() 函数里面调用，即使这样第二句中的\nthis 指代的仍然是全局对象，即使 a() 函数设置了 name 属性。这就是默认绑定规则，它是 js 中最常见的一种函数调用模式，this\n的绑定规则也是最简单的一种，就是绑定在全局作用域上\n\n== 但是如果使用了严格模式，则 this 不能绑定到全局对象，在严格模式下，把 this 绑定到全局对象上时，实际上绑定的是\nunderfined，因此上面的代码会报错 ==\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var c = this\n  c.name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。\n\n---\n\n## 隐式绑定\n\n当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果\n觉得上面这段话不够直白的话，还是来看代码。\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar obj1 = {\n  name: 'zxt',\n  say: say\n}\nvar obj2 = {\n  name: 'zxt1',\n  say: say\n}\nobj1.say() // zxt\nobj2.say() // zxt1\n```\n\nobj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自\n然指向了这个上下文对象。这是很常见的函数调用模式\n\n== 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 ==\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nvar obj2 = {\n  a: 42,\n  foo: foo\n}\nvar obj1 = {\n  a: 2,\n  obj2: obj2\n}\nobj1.obj2.foo()\n```\n\n## 隐式绑定上下文的时丢失上下文\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj = {\n  name: 'inside',\n  say: say\n}\nvar alias = obj.say // 设置一个简写   (1)\nalias() // 函数调用 输出\"global\"  (2)\n```\n\n由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias =\nsay，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下\n文 ”。最终执行 alias 函数只不过简单的执行了 say 函数\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nfunction doFoo(fn) {\n  // fn其实引用的是foo\n  fn() // <-- 调用位置！\n}\nvar obj = {\n  a: 2,\n  foo: foo\n}\nvar a = 'oops, global' // a是全局对象的属性\ndoFoo(obj.foo)\n```\n\n参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数\n可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置\n\n---\n\n## 显示绑定\n\n显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本\n相似，他们之间的区别是：\n\napply(obj,[arg1.arg2,...]); 被调用函数的参数以数组的形式给出\n\ncall(obj,arg1,arg2,arg3,...); 被调用函数的参数依次给出\n\n而 bind 函数执行后，返回的是一个新函数。\n\n== 硬性绑定的应用场景：==\n\n```javascript\nfunction foo(something) {\nconsole.log( this.a, something );\nreturn this.a + something;\n} v\nar obj = {\na:2\n};\nvar bar = function() {\nreturn foo.apply( obj, arguments );\n};\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n另一种使用方法是创建一个\n\n```javascript\nfunction speak() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj1 = {\n  name: 'obj1'\n}\nvar obj2 = {\n  name: 'obj2'\n}\nspeak() // global 等价于speak.call(window)\nspeak.call(window)\nspeak.call(obj1) // obj1\nspeak.call(obj2) // obj2\n```\n\n带参数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar obj2 = {\n  a: 3\n}\ncount.call(obj1, 1, 2) // 4\ncount.apply(obj1, [1, 2]) // 4\ncount.call(obj2, 1, 2) // 5\ncount.apply(obj2, [1, 2]) // 5\n```\n\n因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了\ncall 或者 apply 所调用的对象上。\n\n而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar bound1 = count.bind(obj1) // 未指定参数\nbound1(1, 2) // 4\nvar bound2 = count.bind(obj1, 1) // 指定了一个参数\nbound2(2) // 4\nvar bound3 = count.bind(obj1, 1, 2) // 指定了两个参数\nbound3() //4\nvar bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略\nbound4() // 4\n```\n\n所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。\n\n---\n\nnew 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，\n只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  console.log('我也只不过是个普通函数')\n  console.log(this) //window、window、Person\n}\nPerson('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(this.name) // \"zxt\"\nconsole.log(age) // 22\nPerson('yh', 122)\nconsole.log(this.name) //yu\nvar zxt = new Person('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(zxt.name) // \"zxt\"\nconsole.log(zxt.age) // 22\nconsole.log(this.name) //yu\n```\n\n定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。\n如果通过一个 new 操作符，则构造了一个新的对象。\n\n两种调用方式的不同之处：\n\n* == 普通函数调用时，应用启用默认绑定规则 ==，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。\n* 当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函\n  数，会自动执行下面的操作\n  1. 创建一个全新的对象。\n  2. 这个新对象或被执行原型链连接\n  3. 这个新对象会绑定到函数调用的 this\n  4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象\n\n---\n\n## 四种绑定的优先级\n\n这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四\n种绑定的优先级顺序又是怎么样的。== 默认优先级最低 < 隐式绑定第二 < 显示绑定第三 < new 绑定最高 ==\n\n---\n\n## 箭头函数中的 this\n\n箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍\n的调用时绑定的对象\n\n```javascript\nvar a = 1\nvar foo = () => {\n  console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域\n}\nvar obj = {\n  a: 2\n}\nfoo() // 1 ,在全局对象中调用\nfoo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果\n```\n\n箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  this.speak = function() {\n    console.log(this.name)\n    // 普通函数（非箭头函数),this绑定在调用时的作用域\n  }\n  this.bornYear = () => {\n    // 本文写于2016年，因此new Date().getFullYear()得到的是2016\n    // 箭头函数，this绑定在实例内部\n    console.log(new Date().getFullYear() - this.age)\n  }\n}\nvar zxt = new Person('zxt', 22)\nzxt.speak() // \"zxt\"\nzxt.bornYear() // 1994\n// 到这里应该大家应该都没什么问题\nvar xiaoMing = {\n  name: 'xiaoming',\n  age: 18 // 小明永远18岁\n}\nzxt.speak.call(xiaoMing)\n// \"xiaoming\" this绑定的是xiaoMing这个对象\nzxt.bornYear.call(xiaoMing)\n```\n\n以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施\n以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。\n\n---\n\n```javascript\nvar obj = {\n  id: 'awesome',\n  cool: function coolFn() {\n    var _this = this\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nobj.cool() // 酷,object\nsetTimeout(obj.cool, 100) //window\n```\n\ncool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。\n\n```javascript\nfunction Obj(name) {\n  var _this = this //_this = object{}\n  _this.id = name\n  _this.cool = function() {\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nvar test = new Obj('yaya') //yaya\ntest.cool() //yaya\nvar xiaohong = {\n  id: xiaohong,\n  age: 18\n}\ntest.cool.call(xiaohong) //根本不执行\n```\n\n---\n\n```javascript\nfunction identify() {\n  return this.name.toUpperCase()\n}\nfunction speak() {\n  var greeting = \"Hello, I'm \" + identify.call(this)\n  console.log(greeting)\n}\nvar me = {\n  name: 'Kyle'\n}\nvar you = {\n  name: 'Reader'\n}\nidentify.call(me) // KYLE\nidentify.call(you) // READER\nspeak.call(me) // Hello, 我是KYLE\nspeak.call(you) // Hello, 我是READER\n```\n\n---\n\n```javascript\nfunction foo(num) {\n  console.log('foo: ' + num)\n  // 记录foo被调用的次数\n\n  this.count++\n}\nfoo.count = 0\nvar i\nfor (i = 0; i < 10; i++) {\n  if (i > 5) {\n    foo(i)\n  }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo被调用了多少次？\nconsole.log(foo.count) // 0 -- WTF?\n```\n\n执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，\n所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。\n\n== 匿名函数无法指向自身 ==，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用\n匿名函数，至少在需要自引用时使用时使用具名函数\n\n==this 在任何情况下都不指向函数的词法作用域 ==，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 ==\n\n```javascript\nfunction foo() {\n        var a = 2;\n        this.bar();\n    }\n    function bar() {\n        console.log( this.a );\n    }\n    foo();\n```\n\n试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，== 不能使用 this\n来引用一个词法作用域内部的东西 ==，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的\n\n---\n","source":"_posts/this指向.md","raw":"---\ntitle: this指向\ndate: 2018-01-23 11:39:32\ntags:\n---\n\n[链接](http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w)\n\n1. js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。\n2. 普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过\n   call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。\n3. this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。\n\n<!--more-->\n\n## 默认绑定\n\n在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就\n会应用默认绑定规则，默认绑定的指向的是全局作用域。\n\n```javascript\n<script type=\"text/javascript\" charset=\"utf-8\">\n  var name = \"g\";\n  function a() {\n      console.log(this.name);        //g\n      a.name = 'inside';\n      function b() {\n          console.log(this.name);  //g\n\n\n      }\n      b();\n  }\n  a();\n</script>\n```\n\na() 函数在全局作用域中被调用，因此第 1 句中的 this 就绑定在了全局对象上。b() 函数在 a() 函数里面调用，即使这样第二句中的\nthis 指代的仍然是全局对象，即使 a() 函数设置了 name 属性。这就是默认绑定规则，它是 js 中最常见的一种函数调用模式，this\n的绑定规则也是最简单的一种，就是绑定在全局作用域上\n\n== 但是如果使用了严格模式，则 this 不能绑定到全局对象，在严格模式下，把 this 绑定到全局对象上时，实际上绑定的是\nunderfined，因此上面的代码会报错 ==\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var c = this\n  c.name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。\n\n---\n\n## 隐式绑定\n\n当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果\n觉得上面这段话不够直白的话，还是来看代码。\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar obj1 = {\n  name: 'zxt',\n  say: say\n}\nvar obj2 = {\n  name: 'zxt1',\n  say: say\n}\nobj1.say() // zxt\nobj2.say() // zxt1\n```\n\nobj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自\n然指向了这个上下文对象。这是很常见的函数调用模式\n\n== 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 ==\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nvar obj2 = {\n  a: 42,\n  foo: foo\n}\nvar obj1 = {\n  a: 2,\n  obj2: obj2\n}\nobj1.obj2.foo()\n```\n\n## 隐式绑定上下文的时丢失上下文\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj = {\n  name: 'inside',\n  say: say\n}\nvar alias = obj.say // 设置一个简写   (1)\nalias() // 函数调用 输出\"global\"  (2)\n```\n\n由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias =\nsay，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下\n文 ”。最终执行 alias 函数只不过简单的执行了 say 函数\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nfunction doFoo(fn) {\n  // fn其实引用的是foo\n  fn() // <-- 调用位置！\n}\nvar obj = {\n  a: 2,\n  foo: foo\n}\nvar a = 'oops, global' // a是全局对象的属性\ndoFoo(obj.foo)\n```\n\n参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数\n可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置\n\n---\n\n## 显示绑定\n\n显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本\n相似，他们之间的区别是：\n\napply(obj,[arg1.arg2,...]); 被调用函数的参数以数组的形式给出\n\ncall(obj,arg1,arg2,arg3,...); 被调用函数的参数依次给出\n\n而 bind 函数执行后，返回的是一个新函数。\n\n== 硬性绑定的应用场景：==\n\n```javascript\nfunction foo(something) {\nconsole.log( this.a, something );\nreturn this.a + something;\n} v\nar obj = {\na:2\n};\nvar bar = function() {\nreturn foo.apply( obj, arguments );\n};\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n另一种使用方法是创建一个\n\n```javascript\nfunction speak() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj1 = {\n  name: 'obj1'\n}\nvar obj2 = {\n  name: 'obj2'\n}\nspeak() // global 等价于speak.call(window)\nspeak.call(window)\nspeak.call(obj1) // obj1\nspeak.call(obj2) // obj2\n```\n\n带参数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar obj2 = {\n  a: 3\n}\ncount.call(obj1, 1, 2) // 4\ncount.apply(obj1, [1, 2]) // 4\ncount.call(obj2, 1, 2) // 5\ncount.apply(obj2, [1, 2]) // 5\n```\n\n因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了\ncall 或者 apply 所调用的对象上。\n\n而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar bound1 = count.bind(obj1) // 未指定参数\nbound1(1, 2) // 4\nvar bound2 = count.bind(obj1, 1) // 指定了一个参数\nbound2(2) // 4\nvar bound3 = count.bind(obj1, 1, 2) // 指定了两个参数\nbound3() //4\nvar bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略\nbound4() // 4\n```\n\n所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。\n\n---\n\nnew 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，\n只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  console.log('我也只不过是个普通函数')\n  console.log(this) //window、window、Person\n}\nPerson('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(this.name) // \"zxt\"\nconsole.log(age) // 22\nPerson('yh', 122)\nconsole.log(this.name) //yu\nvar zxt = new Person('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(zxt.name) // \"zxt\"\nconsole.log(zxt.age) // 22\nconsole.log(this.name) //yu\n```\n\n定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。\n如果通过一个 new 操作符，则构造了一个新的对象。\n\n两种调用方式的不同之处：\n\n* == 普通函数调用时，应用启用默认绑定规则 ==，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。\n* 当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函\n  数，会自动执行下面的操作\n  1. 创建一个全新的对象。\n  2. 这个新对象或被执行原型链连接\n  3. 这个新对象会绑定到函数调用的 this\n  4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象\n\n---\n\n## 四种绑定的优先级\n\n这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四\n种绑定的优先级顺序又是怎么样的。== 默认优先级最低 < 隐式绑定第二 < 显示绑定第三 < new 绑定最高 ==\n\n---\n\n## 箭头函数中的 this\n\n箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍\n的调用时绑定的对象\n\n```javascript\nvar a = 1\nvar foo = () => {\n  console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域\n}\nvar obj = {\n  a: 2\n}\nfoo() // 1 ,在全局对象中调用\nfoo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果\n```\n\n箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  this.speak = function() {\n    console.log(this.name)\n    // 普通函数（非箭头函数),this绑定在调用时的作用域\n  }\n  this.bornYear = () => {\n    // 本文写于2016年，因此new Date().getFullYear()得到的是2016\n    // 箭头函数，this绑定在实例内部\n    console.log(new Date().getFullYear() - this.age)\n  }\n}\nvar zxt = new Person('zxt', 22)\nzxt.speak() // \"zxt\"\nzxt.bornYear() // 1994\n// 到这里应该大家应该都没什么问题\nvar xiaoMing = {\n  name: 'xiaoming',\n  age: 18 // 小明永远18岁\n}\nzxt.speak.call(xiaoMing)\n// \"xiaoming\" this绑定的是xiaoMing这个对象\nzxt.bornYear.call(xiaoMing)\n```\n\n以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施\n以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。\n\n---\n\n```javascript\nvar obj = {\n  id: 'awesome',\n  cool: function coolFn() {\n    var _this = this\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nobj.cool() // 酷,object\nsetTimeout(obj.cool, 100) //window\n```\n\ncool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。\n\n```javascript\nfunction Obj(name) {\n  var _this = this //_this = object{}\n  _this.id = name\n  _this.cool = function() {\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nvar test = new Obj('yaya') //yaya\ntest.cool() //yaya\nvar xiaohong = {\n  id: xiaohong,\n  age: 18\n}\ntest.cool.call(xiaohong) //根本不执行\n```\n\n---\n\n```javascript\nfunction identify() {\n  return this.name.toUpperCase()\n}\nfunction speak() {\n  var greeting = \"Hello, I'm \" + identify.call(this)\n  console.log(greeting)\n}\nvar me = {\n  name: 'Kyle'\n}\nvar you = {\n  name: 'Reader'\n}\nidentify.call(me) // KYLE\nidentify.call(you) // READER\nspeak.call(me) // Hello, 我是KYLE\nspeak.call(you) // Hello, 我是READER\n```\n\n---\n\n```javascript\nfunction foo(num) {\n  console.log('foo: ' + num)\n  // 记录foo被调用的次数\n\n  this.count++\n}\nfoo.count = 0\nvar i\nfor (i = 0; i < 10; i++) {\n  if (i > 5) {\n    foo(i)\n  }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo被调用了多少次？\nconsole.log(foo.count) // 0 -- WTF?\n```\n\n执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，\n所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。\n\n== 匿名函数无法指向自身 ==，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用\n匿名函数，至少在需要自引用时使用时使用具名函数\n\n==this 在任何情况下都不指向函数的词法作用域 ==，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 ==\n\n```javascript\nfunction foo() {\n        var a = 2;\n        this.bar();\n    }\n    function bar() {\n        console.log( this.a );\n    }\n    foo();\n```\n\n试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，== 不能使用 this\n来引用一个词法作用域内部的东西 ==，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的\n\n---\n","slug":"this指向","published":1,"updated":"2018-01-23T03:43:39.712Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7ed000nj8vrp041z0oa","content":"<p><a href=\"http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<ol>\n<li>js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。</li>\n<li>普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过<br>call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。</li>\n<li>this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就<br>会应用默认绑定规则，默认绑定的指向的是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> charset=<span class=\"string\">\"utf-8\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"g\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);        <span class=\"comment\">//g</span></span><br><span class=\"line\">      a.name = <span class=\"string\">'inside'</span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);  <span class=\"comment\">//g</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      b();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>a() 函数在全局作用域中被调用，因此第 1 句中的 this 就绑定在了全局对象上。b() 函数在 a() 函数里面调用，即使这样第二句中的<br>this 指代的仍然是全局对象，即使 a() 函数设置了 name 属性。这就是默认绑定规则，它是 js 中最常见的一种函数调用模式，this<br>的绑定规则也是最简单的一种，就是绑定在全局作用域上</p>\n<p>== 但是如果使用了严格模式，则 this 不能绑定到全局对象，在严格模式下，把 this 绑定到全局对象上时，实际上绑定的是<br>underfined，因此上面的代码会报错 ==</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span></span><br><span class=\"line\">  c.name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<p>所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。</p>\n<hr>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果<br>觉得上面这段话不够直白的话，还是来看代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt1'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.say() <span class=\"comment\">// zxt</span></span><br><span class=\"line\">obj2.say() <span class=\"comment\">// zxt1</span></span><br></pre></td></tr></table></figure>\n<p>obj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自<br>然指向了这个上下文对象。这是很常见的函数调用模式</p>\n<p>== 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 ==</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">42</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  obj2: obj2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.obj2.foo()</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式绑定上下文的时丢失上下文\"><a href=\"#隐式绑定上下文的时丢失上下文\" class=\"headerlink\" title=\"隐式绑定上下文的时丢失上下文\"></a>隐式绑定上下文的时丢失上下文</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'inside'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> alias = obj.say <span class=\"comment\">// 设置一个简写   (1)</span></span><br><span class=\"line\">alias() <span class=\"comment\">// 函数调用 输出\"global\"  (2)</span></span><br></pre></td></tr></table></figure>\n<p>由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias =<br>say，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下<br>文 ”。最终执行 alias 函数只不过简单的执行了 say 函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// fn其实引用的是foo</span></span><br><span class=\"line\">  fn() <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'oops, global'</span> <span class=\"comment\">// a是全局对象的属性</span></span><br><span class=\"line\">doFoo(obj.foo)</span><br></pre></td></tr></table></figure>\n<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数<br>可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置</p>\n<hr>\n<h2 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h2><p>显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本<br>相似，他们之间的区别是：</p>\n<p>apply(obj,[arg1.arg2,…]); 被调用函数的参数以数组的形式给出</p>\n<p>call(obj,arg1,arg2,arg3,…); 被调用函数的参数依次给出</p>\n<p>而 bind 函数执行后，返回的是一个新函数。</p>\n<p>== 硬性绑定的应用场景：==</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar obj = &#123;</span><br><span class=\"line\">a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>另一种使用方法是创建一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">speak() <span class=\"comment\">// global 等价于speak.call(window)</span></span><br><span class=\"line\">speak.call(<span class=\"built_in\">window</span>)</span><br><span class=\"line\">speak.call(obj1) <span class=\"comment\">// obj1</span></span><br><span class=\"line\">speak.call(obj2) <span class=\"comment\">// obj2</span></span><br></pre></td></tr></table></figure>\n<p>带参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count.call(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.call(obj2, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 5</span></span><br><span class=\"line\">count.apply(obj2, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了<br>call 或者 apply 所调用的对象上。</p>\n<p>而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bound1 = count.bind(obj1) <span class=\"comment\">// 未指定参数</span></span><br><span class=\"line\">bound1(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound2 = count.bind(obj1, <span class=\"number\">1</span>) <span class=\"comment\">// 指定了一个参数</span></span><br><span class=\"line\">bound2(<span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound3 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 指定了两个参数</span></span><br><span class=\"line\">bound3() <span class=\"comment\">//4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound4 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 指定了多余的参数,多余的参数会被忽略</span></span><br><span class=\"line\">bound4() <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。</p>\n<hr>\n<p>new 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，<br>只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'我也只不过是个普通函数'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//window、window、Person</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age) <span class=\"comment\">// 22</span></span><br><span class=\"line\">Person(<span class=\"string\">'yh'</span>, <span class=\"number\">122</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.age) <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br></pre></td></tr></table></figure>\n<p>定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。<br>如果通过一个 new 操作符，则构造了一个新的对象。</p>\n<p>两种调用方式的不同之处：</p>\n<ul>\n<li>== 普通函数调用时，应用启用默认绑定规则 ==，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。</li>\n<li>当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函<br>数，会自动执行下面的操作<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象或被执行原型链连接</li>\n<li>这个新对象会绑定到函数调用的 this</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"四种绑定的优先级\"><a href=\"#四种绑定的优先级\" class=\"headerlink\" title=\"四种绑定的优先级\"></a>四种绑定的优先级</h2><p>这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四<br>种绑定的优先级顺序又是怎么样的。== 默认优先级最低 &lt; 隐式绑定第二 &lt; 显示绑定第三 &lt; new 绑定最高 ==</p>\n<hr>\n<h2 id=\"箭头函数中的-this\"><a href=\"#箭头函数中的-this\" class=\"headerlink\" title=\"箭头函数中的 this\"></a>箭头函数中的 this</h2><p>箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍<br>的调用时绑定的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// 定义在全局对象中，因此this绑定在全局作用域</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 1 ,在全局对象中调用</span></span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// 1,显示绑定，由obj对象来调用，但根本不影响结果</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.speak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    <span class=\"comment\">// 普通函数（非箭头函数),this绑定在调用时的作用域</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bornYear = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 本文写于2016年，因此new Date().getFullYear()得到的是2016</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数，this绑定在实例内部</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear() - <span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>)</span><br><span class=\"line\">zxt.speak() <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\">zxt.bornYear() <span class=\"comment\">// 1994</span></span><br><span class=\"line\"><span class=\"comment\">// 到这里应该大家应该都没什么问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoMing = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xiaoming'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span> <span class=\"comment\">// 小明永远18岁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">zxt.speak.call(xiaoMing)</span><br><span class=\"line\"><span class=\"comment\">// \"xiaoming\" this绑定的是xiaoMing这个对象</span></span><br><span class=\"line\">zxt.bornYear.call(xiaoMing)</span><br></pre></td></tr></table></figure>\n<p>以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施<br>以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">'awesome'</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\">obj.cool() <span class=\"comment\">// 酷,object</span></span><br><span class=\"line\">setTimeout(obj.cool, <span class=\"number\">100</span>) <span class=\"comment\">//window</span></span><br></pre></td></tr></table></figure>\n<p>cool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span> <span class=\"comment\">//_this = object&#123;&#125;</span></span><br><span class=\"line\">  _this.id = name</span><br><span class=\"line\">  _this.cool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"keyword\">new</span> Obj(<span class=\"string\">'yaya'</span>) <span class=\"comment\">//yaya</span></span><br><span class=\"line\">test.cool() <span class=\"comment\">//yaya</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</span><br><span class=\"line\">  id: xiaohong,</span><br><span class=\"line\">  age: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test.cool.call(xiaohong) <span class=\"comment\">//根本不执行</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identify</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + identify.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(greeting)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kyle'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> you = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Reader'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">identify.call(me) <span class=\"comment\">// KYLE</span></span><br><span class=\"line\">identify.call(you) <span class=\"comment\">// READER</span></span><br><span class=\"line\">speak.call(me) <span class=\"comment\">// Hello, 我是KYLE</span></span><br><span class=\"line\">speak.call(you) <span class=\"comment\">// Hello, 我是READER</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo: '</span> + num)</span><br><span class=\"line\">  <span class=\"comment\">// 记录foo被调用的次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"><span class=\"comment\">// foo被调用了多少次？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count) <span class=\"comment\">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>\n<p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，<br>所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。</p>\n<p>== 匿名函数无法指向自身 ==，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用<br>匿名函数，至少在需要自引用时使用时使用具名函数</p>\n<p>==this 在任何情况下都不指向函数的词法作用域 ==，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 ==</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    foo();</span><br></pre></td></tr></table></figure>\n<p>试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，== 不能使用 this<br>来引用一个词法作用域内部的东西 ==，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的</p>\n<hr>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<ol>\n<li>js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。</li>\n<li>普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过<br>call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。</li>\n<li>this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。</li>\n</ol>","more":"<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就<br>会应用默认绑定规则，默认绑定的指向的是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> charset=<span class=\"string\">\"utf-8\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"g\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);        <span class=\"comment\">//g</span></span><br><span class=\"line\">      a.name = <span class=\"string\">'inside'</span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);  <span class=\"comment\">//g</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      b();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>a() 函数在全局作用域中被调用，因此第 1 句中的 this 就绑定在了全局对象上。b() 函数在 a() 函数里面调用，即使这样第二句中的<br>this 指代的仍然是全局对象，即使 a() 函数设置了 name 属性。这就是默认绑定规则，它是 js 中最常见的一种函数调用模式，this<br>的绑定规则也是最简单的一种，就是绑定在全局作用域上</p>\n<p>== 但是如果使用了严格模式，则 this 不能绑定到全局对象，在严格模式下，把 this 绑定到全局对象上时，实际上绑定的是<br>underfined，因此上面的代码会报错 ==</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span></span><br><span class=\"line\">  c.name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<p>所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。</p>\n<hr>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果<br>觉得上面这段话不够直白的话，还是来看代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt1'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.say() <span class=\"comment\">// zxt</span></span><br><span class=\"line\">obj2.say() <span class=\"comment\">// zxt1</span></span><br></pre></td></tr></table></figure>\n<p>obj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自<br>然指向了这个上下文对象。这是很常见的函数调用模式</p>\n<p>== 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 ==</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">42</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  obj2: obj2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.obj2.foo()</span><br></pre></td></tr></table></figure>\n<h2 id=\"隐式绑定上下文的时丢失上下文\"><a href=\"#隐式绑定上下文的时丢失上下文\" class=\"headerlink\" title=\"隐式绑定上下文的时丢失上下文\"></a>隐式绑定上下文的时丢失上下文</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'inside'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> alias = obj.say <span class=\"comment\">// 设置一个简写   (1)</span></span><br><span class=\"line\">alias() <span class=\"comment\">// 函数调用 输出\"global\"  (2)</span></span><br></pre></td></tr></table></figure>\n<p>由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias =<br>say，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下<br>文 ”。最终执行 alias 函数只不过简单的执行了 say 函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// fn其实引用的是foo</span></span><br><span class=\"line\">  fn() <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'oops, global'</span> <span class=\"comment\">// a是全局对象的属性</span></span><br><span class=\"line\">doFoo(obj.foo)</span><br></pre></td></tr></table></figure>\n<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数<br>可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置</p>\n<hr>\n<h2 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h2><p>显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本<br>相似，他们之间的区别是：</p>\n<p>apply(obj,[arg1.arg2,…]); 被调用函数的参数以数组的形式给出</p>\n<p>call(obj,arg1,arg2,arg3,…); 被调用函数的参数依次给出</p>\n<p>而 bind 函数执行后，返回的是一个新函数。</p>\n<p>== 硬性绑定的应用场景：==</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar obj = &#123;</span><br><span class=\"line\">a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>另一种使用方法是创建一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">speak() <span class=\"comment\">// global 等价于speak.call(window)</span></span><br><span class=\"line\">speak.call(<span class=\"built_in\">window</span>)</span><br><span class=\"line\">speak.call(obj1) <span class=\"comment\">// obj1</span></span><br><span class=\"line\">speak.call(obj2) <span class=\"comment\">// obj2</span></span><br></pre></td></tr></table></figure>\n<p>带参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count.call(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.call(obj2, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 5</span></span><br><span class=\"line\">count.apply(obj2, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了<br>call 或者 apply 所调用的对象上。</p>\n<p>而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bound1 = count.bind(obj1) <span class=\"comment\">// 未指定参数</span></span><br><span class=\"line\">bound1(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound2 = count.bind(obj1, <span class=\"number\">1</span>) <span class=\"comment\">// 指定了一个参数</span></span><br><span class=\"line\">bound2(<span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound3 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 指定了两个参数</span></span><br><span class=\"line\">bound3() <span class=\"comment\">//4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound4 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 指定了多余的参数,多余的参数会被忽略</span></span><br><span class=\"line\">bound4() <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。</p>\n<hr>\n<p>new 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，<br>只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'我也只不过是个普通函数'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//window、window、Person</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age) <span class=\"comment\">// 22</span></span><br><span class=\"line\">Person(<span class=\"string\">'yh'</span>, <span class=\"number\">122</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.age) <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br></pre></td></tr></table></figure>\n<p>定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。<br>如果通过一个 new 操作符，则构造了一个新的对象。</p>\n<p>两种调用方式的不同之处：</p>\n<ul>\n<li>== 普通函数调用时，应用启用默认绑定规则 ==，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。</li>\n<li>当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函<br>数，会自动执行下面的操作<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象或被执行原型链连接</li>\n<li>这个新对象会绑定到函数调用的 this</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"四种绑定的优先级\"><a href=\"#四种绑定的优先级\" class=\"headerlink\" title=\"四种绑定的优先级\"></a>四种绑定的优先级</h2><p>这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四<br>种绑定的优先级顺序又是怎么样的。== 默认优先级最低 &lt; 隐式绑定第二 &lt; 显示绑定第三 &lt; new 绑定最高 ==</p>\n<hr>\n<h2 id=\"箭头函数中的-this\"><a href=\"#箭头函数中的-this\" class=\"headerlink\" title=\"箭头函数中的 this\"></a>箭头函数中的 this</h2><p>箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍<br>的调用时绑定的对象</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// 定义在全局对象中，因此this绑定在全局作用域</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 1 ,在全局对象中调用</span></span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// 1,显示绑定，由obj对象来调用，但根本不影响结果</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.speak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    <span class=\"comment\">// 普通函数（非箭头函数),this绑定在调用时的作用域</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bornYear = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 本文写于2016年，因此new Date().getFullYear()得到的是2016</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数，this绑定在实例内部</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear() - <span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>)</span><br><span class=\"line\">zxt.speak() <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\">zxt.bornYear() <span class=\"comment\">// 1994</span></span><br><span class=\"line\"><span class=\"comment\">// 到这里应该大家应该都没什么问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoMing = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xiaoming'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span> <span class=\"comment\">// 小明永远18岁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">zxt.speak.call(xiaoMing)</span><br><span class=\"line\"><span class=\"comment\">// \"xiaoming\" this绑定的是xiaoMing这个对象</span></span><br><span class=\"line\">zxt.bornYear.call(xiaoMing)</span><br></pre></td></tr></table></figure>\n<p>以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施<br>以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">'awesome'</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\">obj.cool() <span class=\"comment\">// 酷,object</span></span><br><span class=\"line\">setTimeout(obj.cool, <span class=\"number\">100</span>) <span class=\"comment\">//window</span></span><br></pre></td></tr></table></figure>\n<p>cool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span> <span class=\"comment\">//_this = object&#123;&#125;</span></span><br><span class=\"line\">  _this.id = name</span><br><span class=\"line\">  _this.cool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"keyword\">new</span> Obj(<span class=\"string\">'yaya'</span>) <span class=\"comment\">//yaya</span></span><br><span class=\"line\">test.cool() <span class=\"comment\">//yaya</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</span><br><span class=\"line\">  id: xiaohong,</span><br><span class=\"line\">  age: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test.cool.call(xiaohong) <span class=\"comment\">//根本不执行</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identify</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + identify.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(greeting)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kyle'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> you = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Reader'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">identify.call(me) <span class=\"comment\">// KYLE</span></span><br><span class=\"line\">identify.call(you) <span class=\"comment\">// READER</span></span><br><span class=\"line\">speak.call(me) <span class=\"comment\">// Hello, 我是KYLE</span></span><br><span class=\"line\">speak.call(you) <span class=\"comment\">// Hello, 我是READER</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo: '</span> + num)</span><br><span class=\"line\">  <span class=\"comment\">// 记录foo被调用的次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"><span class=\"comment\">// foo被调用了多少次？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count) <span class=\"comment\">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>\n<p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，<br>所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。</p>\n<p>== 匿名函数无法指向自身 ==，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用<br>匿名函数，至少在需要自引用时使用时使用具名函数</p>\n<p>==this 在任何情况下都不指向函数的词法作用域 ==，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 ==</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.bar();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    foo();</span><br></pre></td></tr></table></figure>\n<p>试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，== 不能使用 this<br>来引用一个词法作用域内部的东西 ==，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的</p>\n<hr>"},{"title":"作用域","date":"2018-01-23T03:30:11.000Z","_content":"\n1. 作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询\n2. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n\n<!--more-->\n\n## 欺骗词法作用域\n\n1. eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。\n\n   ```javascript\n   function foo(str, a) {\n   eval( str ); // 欺骗！\n   console.log( a, b );\n   } v\n   ar b = 2;\n   foo( \"var b = 3;\", 1 ); // 1, 3\n   ```\n\n2. with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。\n3. js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.\n\n## var a = 2\n\n编译器会进行如下的处理：\n\n1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。\n2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！\n\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。\n\n编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。\n\n在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS\n\n1. LHS: 赋值操作的目标是谁\n1. RHS：谁是赋值操作的源头\n\n---\n\n当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。\n\n遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。\n\n---\n\n## 函数作用域和块作用域\n\n函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )\n\n1. 立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。\n2. 直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。\n3. 当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。\n\n**提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。**\n\n---\n\n## 提升\n\n任何声明在某个作用域内的变量，都将属于这个作用域\n\n包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。\n\n函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n\nvar a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。\n\n---\n\n## 动态作用域\n\n```javascript\n词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。\nfunction foo() {\nconsole.log( a ); // 2\n} f\nunction bar() {\nvar a = 3;\nfoo();\n} v\nar a = 2;\nbar();\n```\n\n此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;\n\n而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。\n\n事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。\n\n**词法作用域是在写代码或者说定义时确定的**，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。\n","source":"_posts/作用域.md","raw":"---\ntitle: 作用域\ndate: 2018-01-23 11:30:11\ncategories: 原生JS\n---\n\n1. 作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询\n2. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n\n<!--more-->\n\n## 欺骗词法作用域\n\n1. eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。\n\n   ```javascript\n   function foo(str, a) {\n   eval( str ); // 欺骗！\n   console.log( a, b );\n   } v\n   ar b = 2;\n   foo( \"var b = 3;\", 1 ); // 1, 3\n   ```\n\n2. with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。\n3. js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.\n\n## var a = 2\n\n编译器会进行如下的处理：\n\n1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。\n2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！\n\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。\n\n编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。\n\n在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS\n\n1. LHS: 赋值操作的目标是谁\n1. RHS：谁是赋值操作的源头\n\n---\n\n当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。\n\n遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。\n\n---\n\n## 函数作用域和块作用域\n\n函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )\n\n1. 立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。\n2. 直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。\n3. 当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。\n\n**提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。**\n\n---\n\n## 提升\n\n任何声明在某个作用域内的变量，都将属于这个作用域\n\n包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。\n\n函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n\nvar a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。\n\n---\n\n## 动态作用域\n\n```javascript\n词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。\nfunction foo() {\nconsole.log( a ); // 2\n} f\nunction bar() {\nvar a = 3;\nfoo();\n} v\nar a = 2;\nbar();\n```\n\n此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;\n\n而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。\n\n事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。\n\n**词法作用域是在写代码或者说定义时确定的**，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。\n","slug":"作用域","published":1,"updated":"2018-01-23T03:35:51.418Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7eg000pj8vr28xb2ox9","content":"<ol>\n<li>作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询</li>\n<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h2><ol>\n<li><p>eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">eval</span>( str ); <span class=\"comment\">// 欺骗！</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a, b );</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar b = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo( <span class=\"string\">\"var b = 3;\"</span>, <span class=\"number\">1</span> ); <span class=\"comment\">// 1, 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。</p>\n</li>\n<li>js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.</li>\n</ol>\n<h2 id=\"var-a-2\"><a href=\"#var-a-2\" class=\"headerlink\" title=\"var a = 2\"></a>var a = 2</h2><p>编译器会进行如下的处理：</p>\n<ol>\n<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。</li>\n<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！</li>\n</ol>\n<p>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>\n<p>编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。</p>\n<p>在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS</p>\n<ol>\n<li>LHS: 赋值操作的目标是谁</li>\n<li>RHS：谁是赋值操作的源头</li>\n</ol>\n<hr>\n<p>当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。</p>\n<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>\n<hr>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )</p>\n<ol>\n<li>立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。</li>\n<li>直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。</li>\n<li>当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。</li>\n</ol>\n<p><strong>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。</strong></p>\n<hr>\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>任何声明在某个作用域内的变量，都将属于这个作用域</p>\n<p>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。</p>\n<p>函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>\n<p>var a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。</p>\n<hr>\n<h2 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125; f</span><br><span class=\"line\">unction bar() &#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">foo();</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar a = <span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;</p>\n<p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p>\n<p>事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。</p>\n<p><strong>词法作用域是在写代码或者说定义时确定的</strong>，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n","site":{"data":{}},"excerpt":"<ol>\n<li>作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询</li>\n<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</li>\n</ol>","more":"<h2 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h2><ol>\n<li><p>eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">eval</span>( str ); <span class=\"comment\">// 欺骗！</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a, b );</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar b = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo( <span class=\"string\">\"var b = 3;\"</span>, <span class=\"number\">1</span> ); <span class=\"comment\">// 1, 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。</p>\n</li>\n<li>js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.</li>\n</ol>\n<h2 id=\"var-a-2\"><a href=\"#var-a-2\" class=\"headerlink\" title=\"var a = 2\"></a>var a = 2</h2><p>编译器会进行如下的处理：</p>\n<ol>\n<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。</li>\n<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！</li>\n</ol>\n<p>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>\n<p>编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。</p>\n<p>在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS</p>\n<ol>\n<li>LHS: 赋值操作的目标是谁</li>\n<li>RHS：谁是赋值操作的源头</li>\n</ol>\n<hr>\n<p>当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。</p>\n<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>\n<hr>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )</p>\n<ol>\n<li>立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。</li>\n<li>直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。</li>\n<li>当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。</li>\n</ol>\n<p><strong>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。</strong></p>\n<hr>\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>任何声明在某个作用域内的变量，都将属于这个作用域</p>\n<p>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。</p>\n<p>函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>\n<p>var a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。</p>\n<hr>\n<h2 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125; f</span><br><span class=\"line\">unction bar() &#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">foo();</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar a = <span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;</p>\n<p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p>\n<p>事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。</p>\n<p><strong>词法作用域是在写代码或者说定义时确定的</strong>，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>"},{"title":"你不知道的JavaScript(中)","date":"2018-01-15T08:52:42.000Z","_content":"\n读 《你不知道的 JavaScript( 中 )》 笔记\n\n<!--more-->\n\n## 类型和语法\n\n### 内置类型\n\njavascript 有 7 中内置类型：\n\n* 空值 (null)\n* 未定义 (undefined)\n* 布尔值 (boolean)\n* 数字 (number)\n* 字符串 (string)\n* 对象 (object)\n* 符号 (symbol,ES6 中新增 )\n\n**除对象之外，其他同称为 “ 基本对象 ”**\n\njavascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。\n\n```javascript\nvar a\nvar b = 42\nvar c\nb = c\ntypeof b //undefined\ntypeof a //undefined\n```\n\nundeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报\n错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（\n阻止报错）来检查 undeclared 变量\n\n## 数组\n\n```javascript\nvar a = []\na[3] = '2'\na.length //4\n```\n\n### 字符串\n\n字符串经常被当成字符数组，但它们仅仅是看上去相似而已\n\n```javascript\nvar a = 'fff'\nvar b = ['f', 'f', 'f']\nconsole.log(a.length, b.length) //3,3\n```\n","source":"_posts/你不知道的JavaScript-中.md","raw":"---\ntitle: 你不知道的JavaScript(中)\ndate: 2018-01-15 16:52:42\ntags:\n---\n\n读 《你不知道的 JavaScript( 中 )》 笔记\n\n<!--more-->\n\n## 类型和语法\n\n### 内置类型\n\njavascript 有 7 中内置类型：\n\n* 空值 (null)\n* 未定义 (undefined)\n* 布尔值 (boolean)\n* 数字 (number)\n* 字符串 (string)\n* 对象 (object)\n* 符号 (symbol,ES6 中新增 )\n\n**除对象之外，其他同称为 “ 基本对象 ”**\n\njavascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。\n\n```javascript\nvar a\nvar b = 42\nvar c\nb = c\ntypeof b //undefined\ntypeof a //undefined\n```\n\nundeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报\n错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（\n阻止报错）来检查 undeclared 变量\n\n## 数组\n\n```javascript\nvar a = []\na[3] = '2'\na.length //4\n```\n\n### 字符串\n\n字符串经常被当成字符数组，但它们仅仅是看上去相似而已\n\n```javascript\nvar a = 'fff'\nvar b = ['f', 'f', 'f']\nconsole.log(a.length, b.length) //3,3\n```\n","slug":"你不知道的JavaScript-中","published":1,"updated":"2018-01-15T09:51:42.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7ei000qj8vrx1t9o9nu","content":"<p>读 《你不知道的 JavaScript( 中 )》 笔记</p>\n<a id=\"more\"></a>\n<h2 id=\"类型和语法\"><a href=\"#类型和语法\" class=\"headerlink\" title=\"类型和语法\"></a>类型和语法</h2><h3 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h3><p>javascript 有 7 中内置类型：</p>\n<ul>\n<li>空值 (null)</li>\n<li>未定义 (undefined)</li>\n<li>布尔值 (boolean)</li>\n<li>数字 (number)</li>\n<li>字符串 (string)</li>\n<li>对象 (object)</li>\n<li>符号 (symbol,ES6 中新增 )</li>\n</ul>\n<p><strong>除对象之外，其他同称为 “ 基本对象 ”</strong></p>\n<p>javascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c</span><br><span class=\"line\">b = c</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>undeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报<br>错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（<br>阻止报错）来检查 undeclared 变量</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = []</span><br><span class=\"line\">a[<span class=\"number\">3</span>] = <span class=\"string\">'2'</span></span><br><span class=\"line\">a.length <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串经常被当成字符数组，但它们仅仅是看上去相似而已</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'fff'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length, b.length) <span class=\"comment\">//3,3</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>读 《你不知道的 JavaScript( 中 )》 笔记</p>","more":"<h2 id=\"类型和语法\"><a href=\"#类型和语法\" class=\"headerlink\" title=\"类型和语法\"></a>类型和语法</h2><h3 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h3><p>javascript 有 7 中内置类型：</p>\n<ul>\n<li>空值 (null)</li>\n<li>未定义 (undefined)</li>\n<li>布尔值 (boolean)</li>\n<li>数字 (number)</li>\n<li>字符串 (string)</li>\n<li>对象 (object)</li>\n<li>符号 (symbol,ES6 中新增 )</li>\n</ul>\n<p><strong>除对象之外，其他同称为 “ 基本对象 ”</strong></p>\n<p>javascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c</span><br><span class=\"line\">b = c</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>undeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报<br>错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（<br>阻止报错）来检查 undeclared 变量</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = []</span><br><span class=\"line\">a[<span class=\"number\">3</span>] = <span class=\"string\">'2'</span></span><br><span class=\"line\">a.length <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串经常被当成字符数组，但它们仅仅是看上去相似而已</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'fff'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length, b.length) <span class=\"comment\">//3,3</span></span><br></pre></td></tr></table></figure>"},{"title":"字符串操作方法","date":"2018-01-15T10:02:34.000Z","_content":"\n字符串常见操作方法总结\n\n<!--more-->","source":"_posts/字符串操作方法.md","raw":"---\ntitle: 字符串操作方法\ndate: 2018-01-15 18:02:34\ncategories: 原生JS\n---\n\n字符串常见操作方法总结\n\n<!--more-->","slug":"字符串操作方法","published":1,"updated":"2018-01-17T10:11:50.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7ek000tj8vrhzh3an96","content":"<p>字符串常见操作方法总结</p>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<p>字符串常见操作方法总结</p>","more":""},{"title":"疑难杂问整理（原生JS）","date":"2018-01-19T02:12:08.000Z","_content":"\n在学习原生的过程中的困惑与解惑的总结\n\n<!--more-->\n\n## 工厂模式\n\n```javascript\nfunction createPerson(name, age, job) {\n  var o = new Object()\n  o.name = name\n  o.age = age\n  o.job = job\n  o.sayName = function() {\n    alert(this.name)\n  }\n  return 0\n}\n\nvar person1 = createPerson('Nicholas', 29, 'Software Engineer')\nvar person2 = createPerson('Greg', 27, 'Doctor')\n\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\n```\n\n## 构造函数\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nvar person3 = new Person('Mick', 23, 'Doctor')\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\nperson2 === person3 //false\nperson1.constructor == Person //true\nPerson.prototype // {constructor: ƒ}  为原型对象\nperson1.prototype //undefined\nPerson.prototype.prototype //undefined\nperson1.constructor == Person //true\nPerson.prototype.constructor == Person //true\n```\n\n实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n  return this\n}\nvar person1 = Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = Person('Mick', 23, 'Doctor')\nperson1 // this 指向window 且被person2覆盖\nperson2 // this 指向window\n```\n\n#### 与工厂模式的区别\n\n* 没有显示创建对象（new 运算符创建并实例化新对象）。\n* 直接将属性和方法赋给了 this 对象。\n* 没有 return 语句。\n* 要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象\n* 可以使用 instanceof 操作符检测对象类型。\n\n构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。\n\n## 原型链\n\n```javascript\nfunction f1() {}\nvar o3 = new f1()\nvar f3 = new Function('str', 'console.log(str)')\ntypeof f3 // function\ntypeof o3 //object\n```\n","source":"_posts/疑难杂问整理（原生JS）.md","raw":"---\ntitle: 疑难杂问整理（原生JS）\ndate: 2018-01-19 10:12:08\ncategories: 原生JS\n---\n\n在学习原生的过程中的困惑与解惑的总结\n\n<!--more-->\n\n## 工厂模式\n\n```javascript\nfunction createPerson(name, age, job) {\n  var o = new Object()\n  o.name = name\n  o.age = age\n  o.job = job\n  o.sayName = function() {\n    alert(this.name)\n  }\n  return 0\n}\n\nvar person1 = createPerson('Nicholas', 29, 'Software Engineer')\nvar person2 = createPerson('Greg', 27, 'Doctor')\n\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\n```\n\n## 构造函数\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nvar person3 = new Person('Mick', 23, 'Doctor')\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\nperson2 === person3 //false\nperson1.constructor == Person //true\nPerson.prototype // {constructor: ƒ}  为原型对象\nperson1.prototype //undefined\nPerson.prototype.prototype //undefined\nperson1.constructor == Person //true\nPerson.prototype.constructor == Person //true\n```\n\n实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n  return this\n}\nvar person1 = Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = Person('Mick', 23, 'Doctor')\nperson1 // this 指向window 且被person2覆盖\nperson2 // this 指向window\n```\n\n#### 与工厂模式的区别\n\n* 没有显示创建对象（new 运算符创建并实例化新对象）。\n* 直接将属性和方法赋给了 this 对象。\n* 没有 return 语句。\n* 要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象\n* 可以使用 instanceof 操作符检测对象类型。\n\n构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。\n\n## 原型链\n\n```javascript\nfunction f1() {}\nvar o3 = new f1()\nvar f3 = new Function('str', 'console.log(str)')\ntypeof f3 // function\ntypeof o3 //object\n```\n","slug":"疑难杂问整理（原生JS）","published":1,"updated":"2018-01-19T10:48:55.553Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7en000uj8vrfzc72jvp","content":"<p>在学习原生的过程中的困惑与解惑的总结</p>\n<a id=\"more\"></a>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">  o.name = name</span><br><span class=\"line\">  o.age = age</span><br><span class=\"line\">  o.job = job</span><br><span class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">'Nicholas'</span>, <span class=\"number\">29</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">'Greg'</span>, <span class=\"number\">27</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 === person3 <span class=\"comment\">//false</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype <span class=\"comment\">// &#123;constructor: ƒ&#125;  为原型对象</span></span><br><span class=\"line\">person1.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">Person.prototype.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype.constructor == Person <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// this 指向window 且被person2覆盖</span></span><br><span class=\"line\">person2 <span class=\"comment\">// this 指向window</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"与工厂模式的区别\"><a href=\"#与工厂模式的区别\" class=\"headerlink\" title=\"与工厂模式的区别\"></a>与工厂模式的区别</h4><ul>\n<li>没有显示创建对象（new 运算符创建并实例化新对象）。</li>\n<li>直接将属性和方法赋给了 this 对象。</li>\n<li>没有 return 语句。</li>\n<li>要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象</li>\n<li>可以使用 instanceof 操作符检测对象类型。</li>\n</ul>\n<p>构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o3 = <span class=\"keyword\">new</span> f1()</span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'str'</span>, <span class=\"string\">'console.log(str)'</span>)</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> f3 <span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> o3 <span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在学习原生的过程中的困惑与解惑的总结</p>","more":"<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">  o.name = name</span><br><span class=\"line\">  o.age = age</span><br><span class=\"line\">  o.job = job</span><br><span class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">'Nicholas'</span>, <span class=\"number\">29</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">'Greg'</span>, <span class=\"number\">27</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 === person3 <span class=\"comment\">//false</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype <span class=\"comment\">// &#123;constructor: ƒ&#125;  为原型对象</span></span><br><span class=\"line\">person1.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">Person.prototype.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype.constructor == Person <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// this 指向window 且被person2覆盖</span></span><br><span class=\"line\">person2 <span class=\"comment\">// this 指向window</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"与工厂模式的区别\"><a href=\"#与工厂模式的区别\" class=\"headerlink\" title=\"与工厂模式的区别\"></a>与工厂模式的区别</h4><ul>\n<li>没有显示创建对象（new 运算符创建并实例化新对象）。</li>\n<li>直接将属性和方法赋给了 this 对象。</li>\n<li>没有 return 语句。</li>\n<li>要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象</li>\n<li>可以使用 instanceof 操作符检测对象类型。</li>\n</ul>\n<p>构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。</p>\n<h2 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> o3 = <span class=\"keyword\">new</span> f1()</span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"keyword\">new</span> <span class=\"built_in\">Function</span>(<span class=\"string\">'str'</span>, <span class=\"string\">'console.log(str)'</span>)</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> f3 <span class=\"comment\">// function</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> o3 <span class=\"comment\">//object</span></span><br></pre></td></tr></table></figure>"},{"title":"如何实现双向数据绑定 mvvm","_content":"\n目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。\n<!--more-->\n\n实现数据双向绑定的集中做法大致如下：\n\n- 发布者-订阅者模式（backbone.js）\n\n- 脏值检查（angular.js）\n\n- 数据劫持（vue.js）\n\n## 数据劫持:\n\nvue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n## 1、实现Observer\nok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it\n### 实现监听\n我们知道可以利用Obeject.defineProperty()来监听属性变动\n那么将需要observe的数据对象进行递归遍历，包括子属性的属性，都加上 set和get\n这样的话，给这个对象的某个值赋值，就会触发set，那么就能监听到了数据变化。。相关代码可以是这样：\n```javascript\nvar data = {name:'kindeng'};\nobserve(data);\ndata.name = 'dmq'; //监听到值得变化 kindeng -->dmq\nfunction observe(data){\n  if(!data||typeof data !== 'object){  \n    //[]、{}\n    return;\n  }\n  object.key(data).forEach(function(key)){\n    defineReactive(data,key,data[key]);\n  }\n}\n\nfunction defineReactive(data,key,val){\n  observe(val);//监听子属性\n\n  //循环将data 中的每一个元素都绑定上数据劫持\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    //可枚举\n    configurable:false,\n    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化\n    get:function(){\n    return val;\n    },\n    set:function(){\n         console.log('值变');\n         val = newVal ;\n    }\n  })\n}\n```\n## 数据观测的实现\n\n### Angular \n\nAngular 的数据监测采用的是“脏值检测”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做watcher，一个作用域中可能有多个watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做digest cycle。脏值检测的劣势有两点：\n\n1. 任何数据变动都意味着当前作用域的每一个watcher需要被重新求值，且同一时间只允许一个digest运行，因此当watcher庞大时，应用性能就不可避免的收到影响，并且很难优化。\n2. 当数据变化时，框架并不能主动监测到变化的产生，需要手动触发digest cycle才能触发相应的DOM更新。Angular通过在DOM事件处理函数中自动触发digest cycle部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。\n\n#### $watch 对象\nAngular 每一个绑定到 UI 的数据，就会有一$watch 对象\n这个对象包含3个值\n\n```javascript\nwatch={\n  name:'',\n  getNewValue:function($scope){ //得到新值\n     return newValue\n  },\n  listener:function(newValue,oldValue){\n   //当数据发生变化时\n  }\n}\n```\ngetNewValue()可以得到当前$scope上的最新值，listener 函数得到新值和旧值并进行一些操作。\n\n每当我们将数据绑定到UI上，angular 就会想你的watchList 上插入一个$watch \n\n** 只有触发UI事件，ajax请求或者timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。\n\n### Vue\nvue采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：\n1. 将原生的数据改造成“可观察对象”。一个可观察对象可以被取值也可以被赋值。\n2. 在watcher的求值过程中，每一个被取值的可观察对象都都会将当前的watcher注册为自己的一个订阅者，并成为当前的watcher 的一个依赖。\n3. 当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的watcher重新求值，并触发相应的更新。\n4. 依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如Knockout,通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。\n","source":"_posts/如何实现双向数据绑定-mvvm.md","raw":"---\ntitle: 如何实现双向数据绑定 mvvm\ncategories: vue\ntags:\n---\n\n目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。\n<!--more-->\n\n实现数据双向绑定的集中做法大致如下：\n\n- 发布者-订阅者模式（backbone.js）\n\n- 脏值检查（angular.js）\n\n- 数据劫持（vue.js）\n\n## 数据劫持:\n\nvue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n## 1、实现Observer\nok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it\n### 实现监听\n我们知道可以利用Obeject.defineProperty()来监听属性变动\n那么将需要observe的数据对象进行递归遍历，包括子属性的属性，都加上 set和get\n这样的话，给这个对象的某个值赋值，就会触发set，那么就能监听到了数据变化。。相关代码可以是这样：\n```javascript\nvar data = {name:'kindeng'};\nobserve(data);\ndata.name = 'dmq'; //监听到值得变化 kindeng -->dmq\nfunction observe(data){\n  if(!data||typeof data !== 'object){  \n    //[]、{}\n    return;\n  }\n  object.key(data).forEach(function(key)){\n    defineReactive(data,key,data[key]);\n  }\n}\n\nfunction defineReactive(data,key,val){\n  observe(val);//监听子属性\n\n  //循环将data 中的每一个元素都绑定上数据劫持\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    //可枚举\n    configurable:false,\n    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化\n    get:function(){\n    return val;\n    },\n    set:function(){\n         console.log('值变');\n         val = newVal ;\n    }\n  })\n}\n```\n## 数据观测的实现\n\n### Angular \n\nAngular 的数据监测采用的是“脏值检测”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做watcher，一个作用域中可能有多个watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做digest cycle。脏值检测的劣势有两点：\n\n1. 任何数据变动都意味着当前作用域的每一个watcher需要被重新求值，且同一时间只允许一个digest运行，因此当watcher庞大时，应用性能就不可避免的收到影响，并且很难优化。\n2. 当数据变化时，框架并不能主动监测到变化的产生，需要手动触发digest cycle才能触发相应的DOM更新。Angular通过在DOM事件处理函数中自动触发digest cycle部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。\n\n#### $watch 对象\nAngular 每一个绑定到 UI 的数据，就会有一$watch 对象\n这个对象包含3个值\n\n```javascript\nwatch={\n  name:'',\n  getNewValue:function($scope){ //得到新值\n     return newValue\n  },\n  listener:function(newValue,oldValue){\n   //当数据发生变化时\n  }\n}\n```\ngetNewValue()可以得到当前$scope上的最新值，listener 函数得到新值和旧值并进行一些操作。\n\n每当我们将数据绑定到UI上，angular 就会想你的watchList 上插入一个$watch \n\n** 只有触发UI事件，ajax请求或者timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。\n\n### Vue\nvue采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：\n1. 将原生的数据改造成“可观察对象”。一个可观察对象可以被取值也可以被赋值。\n2. 在watcher的求值过程中，每一个被取值的可观察对象都都会将当前的watcher注册为自己的一个订阅者，并成为当前的watcher 的一个依赖。\n3. 当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的watcher重新求值，并触发相应的更新。\n4. 依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如Knockout,通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。\n","slug":"如何实现双向数据绑定-mvvm","published":1,"date":"2018-01-16T01:10:46.834Z","updated":"2018-01-17T09:14:24.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjcr3j7eq000xj8vrt97e1691","content":"<p>目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。<br><a id=\"more\"></a></p>\n<p>实现数据双向绑定的集中做法大致如下：</p>\n<ul>\n<li><p>发布者-订阅者模式（backbone.js）</p>\n</li>\n<li><p>脏值检查（angular.js）</p>\n</li>\n<li><p>数据劫持（vue.js）</p>\n</li>\n</ul>\n<h2 id=\"数据劫持\"><a href=\"#数据劫持\" class=\"headerlink\" title=\"数据劫持:\"></a>数据劫持:</h2><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<h2 id=\"1、实现Observer\"><a href=\"#1、实现Observer\" class=\"headerlink\" title=\"1、实现Observer\"></a>1、实现Observer</h2><p>ok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it</p>\n<h3 id=\"实现监听\"><a href=\"#实现监听\" class=\"headerlink\" title=\"实现监听\"></a>实现监听</h3><p>我们知道可以利用Obeject.defineProperty()来监听属性变动<br>那么将需要observe的数据对象进行递归遍历，包括子属性的属性，都加上 set和get<br>这样的话，给这个对象的某个值赋值，就会触发set，那么就能监听到了数据变化。。相关代码可以是这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'kindeng'</span>&#125;;</span><br><span class=\"line\">observe(data);</span><br><span class=\"line\">data.name = <span class=\"string\">'dmq'</span>; <span class=\"comment\">//监听到值得变化 kindeng --&gt;dmq</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!data||<span class=\"keyword\">typeof</span> data !== <span class=\"string\">'object)&#123;  </span></span><br><span class=\"line\"><span class=\"string\">    //[]、&#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    return;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  object.key(data).forEach(function(key))&#123;</span></span><br><span class=\"line\"><span class=\"string\">    defineReactive(data,key,data[key]);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function defineReactive(data,key,val)&#123;</span></span><br><span class=\"line\"><span class=\"string\">  observe(val);//监听子属性</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  //循环将data 中的每一个元素都绑定上数据劫持</span></span><br><span class=\"line\"><span class=\"string\">  Object.defineProperty(data,key,&#123;</span></span><br><span class=\"line\"><span class=\"string\">    enumerable:true,</span></span><br><span class=\"line\"><span class=\"string\">    //可枚举</span></span><br><span class=\"line\"><span class=\"string\">    configurable:false,</span></span><br><span class=\"line\"><span class=\"string\">    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化</span></span><br><span class=\"line\"><span class=\"string\">    get:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">    return val;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    set:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">         console.log('</span>值变<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\">         val = newVal ;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据观测的实现\"><a href=\"#数据观测的实现\" class=\"headerlink\" title=\"数据观测的实现\"></a>数据观测的实现</h2><h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 的数据监测采用的是“脏值检测”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做watcher，一个作用域中可能有多个watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做digest cycle。脏值检测的劣势有两点：</p>\n<ol>\n<li>任何数据变动都意味着当前作用域的每一个watcher需要被重新求值，且同一时间只允许一个digest运行，因此当watcher庞大时，应用性能就不可避免的收到影响，并且很难优化。</li>\n<li>当数据变化时，框架并不能主动监测到变化的产生，需要手动触发digest cycle才能触发相应的DOM更新。Angular通过在DOM事件处理函数中自动触发digest cycle部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。</li>\n</ol>\n<h4 id=\"watch-对象\"><a href=\"#watch-对象\" class=\"headerlink\" title=\"$watch 对象\"></a>$watch 对象</h4><p>Angular 每一个绑定到 UI 的数据，就会有一$watch 对象<br>这个对象包含3个值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">''</span>,</span><br><span class=\"line\">  getNewValue:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>)</span>&#123; <span class=\"comment\">//得到新值</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> newValue</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  listener:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue,oldValue</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//当数据发生变化时</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getNewValue()可以得到当前$scope上的最新值，listener 函数得到新值和旧值并进行一些操作。</p>\n<p>每当我们将数据绑定到UI上，angular 就会想你的watchList 上插入一个$watch </p>\n<p>** 只有触发UI事件，ajax请求或者timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。</p>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>vue采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：</p>\n<ol>\n<li>将原生的数据改造成“可观察对象”。一个可观察对象可以被取值也可以被赋值。</li>\n<li>在watcher的求值过程中，每一个被取值的可观察对象都都会将当前的watcher注册为自己的一个订阅者，并成为当前的watcher 的一个依赖。</li>\n<li>当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的watcher重新求值，并触发相应的更新。</li>\n<li>依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如Knockout,通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>目前几种主流的mvc(vm)框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input、textare等）添加了change(input)事件，来动态修改model和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。<br>","more":"</p>\n<p>实现数据双向绑定的集中做法大致如下：</p>\n<ul>\n<li><p>发布者-订阅者模式（backbone.js）</p>\n</li>\n<li><p>脏值检查（angular.js）</p>\n</li>\n<li><p>数据劫持（vue.js）</p>\n</li>\n</ul>\n<h2 id=\"数据劫持\"><a href=\"#数据劫持\" class=\"headerlink\" title=\"数据劫持:\"></a>数据劫持:</h2><p>vue.js 则是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<h2 id=\"1、实现Observer\"><a href=\"#1、实现Observer\" class=\"headerlink\" title=\"1、实现Observer\"></a>1、实现Observer</h2><p>ok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it</p>\n<h3 id=\"实现监听\"><a href=\"#实现监听\" class=\"headerlink\" title=\"实现监听\"></a>实现监听</h3><p>我们知道可以利用Obeject.defineProperty()来监听属性变动<br>那么将需要observe的数据对象进行递归遍历，包括子属性的属性，都加上 set和get<br>这样的话，给这个对象的某个值赋值，就会触发set，那么就能监听到了数据变化。。相关代码可以是这样：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'kindeng'</span>&#125;;</span><br><span class=\"line\">observe(data);</span><br><span class=\"line\">data.name = <span class=\"string\">'dmq'</span>; <span class=\"comment\">//监听到值得变化 kindeng --&gt;dmq</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!data||<span class=\"keyword\">typeof</span> data !== <span class=\"string\">'object)&#123;  </span></span><br><span class=\"line\"><span class=\"string\">    //[]、&#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    return;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  object.key(data).forEach(function(key))&#123;</span></span><br><span class=\"line\"><span class=\"string\">    defineReactive(data,key,data[key]);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function defineReactive(data,key,val)&#123;</span></span><br><span class=\"line\"><span class=\"string\">  observe(val);//监听子属性</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  //循环将data 中的每一个元素都绑定上数据劫持</span></span><br><span class=\"line\"><span class=\"string\">  Object.defineProperty(data,key,&#123;</span></span><br><span class=\"line\"><span class=\"string\">    enumerable:true,</span></span><br><span class=\"line\"><span class=\"string\">    //可枚举</span></span><br><span class=\"line\"><span class=\"string\">    configurable:false,</span></span><br><span class=\"line\"><span class=\"string\">    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化</span></span><br><span class=\"line\"><span class=\"string\">    get:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">    return val;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    set:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">         console.log('</span>值变<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\">         val = newVal ;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据观测的实现\"><a href=\"#数据观测的实现\" class=\"headerlink\" title=\"数据观测的实现\"></a>数据观测的实现</h2><h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 的数据监测采用的是“脏值检测”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做watcher，一个作用域中可能有多个watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做digest cycle。脏值检测的劣势有两点：</p>\n<ol>\n<li>任何数据变动都意味着当前作用域的每一个watcher需要被重新求值，且同一时间只允许一个digest运行，因此当watcher庞大时，应用性能就不可避免的收到影响，并且很难优化。</li>\n<li>当数据变化时，框架并不能主动监测到变化的产生，需要手动触发digest cycle才能触发相应的DOM更新。Angular通过在DOM事件处理函数中自动触发digest cycle部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。</li>\n</ol>\n<h4 id=\"watch-对象\"><a href=\"#watch-对象\" class=\"headerlink\" title=\"$watch 对象\"></a>$watch 对象</h4><p>Angular 每一个绑定到 UI 的数据，就会有一$watch 对象<br>这个对象包含3个值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch=&#123;</span><br><span class=\"line\">  name:<span class=\"string\">''</span>,</span><br><span class=\"line\">  getNewValue:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>)</span>&#123; <span class=\"comment\">//得到新值</span></span><br><span class=\"line\">     <span class=\"keyword\">return</span> newValue</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  listener:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue,oldValue</span>)</span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">//当数据发生变化时</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getNewValue()可以得到当前$scope上的最新值，listener 函数得到新值和旧值并进行一些操作。</p>\n<p>每当我们将数据绑定到UI上，angular 就会想你的watchList 上插入一个$watch </p>\n<p>** 只有触发UI事件，ajax请求或者timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。</p>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>vue采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：</p>\n<ol>\n<li>将原生的数据改造成“可观察对象”。一个可观察对象可以被取值也可以被赋值。</li>\n<li>在watcher的求值过程中，每一个被取值的可观察对象都都会将当前的watcher注册为自己的一个订阅者，并成为当前的watcher 的一个依赖。</li>\n<li>当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的watcher重新求值，并触发相应的更新。</li>\n<li>依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如Knockout,通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。</li>\n</ol>"},{"title":"数组操作方法","comments":1,"_content":"\n数组原形方法有以下几种:\njoin(),push(),pop(),sort(),reverse(),concat(),\nslice(),splice(),indexOf(),lastIndexOf(),forEach(),map(),\nfilter(),every(),some(),reduce(),reduceRight();\n\n<!--more-->\n\n#### 1.join()，不改变原数组。\njoin(separator):将数组的元素组成一个字符串，以separator为分隔符，省略则默认为逗号，该方法只接受一个参数。\n\n```javascript\nvar arr = [1,2,3];\nconsole.log(arr.join()); // 1,2,3\nconsole.log(arr.join(\"-\")); // 1-2-3\nconsole.log(arr); // [1, 2, 3]（原数组不变）\n```\n#### 2.push()与pop()，改变元素组\n- push():可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，**并返回修改后数组的长度**。\n- pop():数组末尾移除最后一项，减少数组的length的值，然后返回移除的项。\n\n```javascript\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.push(\"Jack\",\"Sean\");\nconsole.log(count); // 5\nconsole.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop();\nconsole.log(item); // Sean\nconsole.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n#### 3.shift()和unshift()，改变原数组\n- shift():删除原数组的第一项，并返回删除元素的值，如果为空则返回undefined。\n- unshift():将参数添加到原数组开头，**并返回数组的长度**。\n```javascript\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.unshift(\"Jack\",\"Sean\");\nconsole.log(count); // 5\nconsole.log(arr); //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift();\nconsole.log(item); // Jack\nconsole.log(arr); // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n#### 4.sort(),改变原数组\n按升序列排序数组系那个（从小到大），在排序时，sort()方法会调用每个数组的toString()转型方法，**然后比较得到的字符串**，已确定如何排序。即使数组中每一个都是数值,sort()方法比较的意识字符串，因此会出现以下情况：\n```javascript\nvar arr1 = [\"a\", \"d\", \"c\", \"b\"];\nconsole.log(arr1.sort()); // [\"a\", \"b\", \"c\", \"d\"]\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort()); // [13, 24, 3, 51]\nconsole.log(arr2); // [13, 24, 3, 51](元数组被改变)\n```\n为了解决上述问题，sort()方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：\n```javascript\nfunction compare(value1, value2) {\nif (value1 < value2) {\nreturn -1;\n} else if (value1 > value2) {\nreturn 1;\n} else {\nreturn 0;\n}\n}\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort(compare)); // [3, 13, 24, 51]\n```\n如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。\n\n#### 5.reverse()，改变原数组\nreverse():反转数组项的顺序\n```javascript\nreverse()：反转数组项的顺序。\n?\n1\n2\n3\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); //[3, 51, 24, 13]\nconsole.log(arr); //[3, 51, 24, 13](原数组改变)\n```\n#### 6.concat()，不改变原数组\nconcat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，**在没有给concat()方法传递一个参数的情况下，它只是复制当前数组并返回副本。**\n  ```javascript\nvar arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr); // [1, 3, 5, 7](原数组未被修改)\n```\n上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，**如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？**\n```javascript\nvar arrCopy2 = arr.concat([9,[11,13]]);\nconsole.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]\nconsole.log(arrCopy2[5]); //[11, 13]\n```\n#### 7.slice() 不改变原数组\nslice():返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项-但不包括结束位置的项。\n```javascript\nvar arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);\nvar arrCopy4 = arr.slice(-4,-1);\nconsole.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy); //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2); //[3, 5, 7]\nconsole.log(arrCopy3); //[3, 5, 7]\nconsole.log(arrCopy4); //[5, 7, 9]\n```\n#### 8.splice()可以实现删除、插入和替换 改变原数组\n- 删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2)会删除数组中的前两项。\n- 插入：可以向指定位置插入任意数量的项，需要3个参数，起始位置、0（要删除的项数）和要插入的项，例如splice(2,0,4,6)会在当前数组的位置2开始插入4和6\n- 替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要3个参数，只需要指定3个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如splice(2,1,4,6)会删除当前数组位置2的项，然后再从位置2开始插入4和6。\n```javascript\nvar arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr); //[5, 7, 9, 11]\nconsole.log(arrRemoved); //[1, 3]\nvar arrRemoved2 = arr.splice(2,0,4,6);\nconsole.log(arr); // [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2); // []\nvar arrRemoved3 = arr.splice(1,1,2,4);\nconsole.log(arr); // [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3); //[7]\n```\n#### 9.indexOf()和lastIndexOf() \n- indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。\n- lastIndexOf()：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找\n```javascript\nvar arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5)); //2\nconsole.log(arr.lastIndexOf(5)); //5\nconsole.log(arr.indexOf(5,2)); //2\nconsole.log(arr.lastIndexOf(5,4)); //2\nconsole.log(arr.indexOf(\"5\")); //-1\n```\n#### 10.forEach() 遍历\n对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function(x, index, a){\nconsole.log(x + '|' + index + '|' + (a === arr));\n});\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n```\n#### 11.map()\nmap()：指“映射”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item){\nreturn item*item;\n});\nconsole.log(arr2); //[1, 4, 9, 16, 25]\n```\n#### 12.filter()\nfilter(): “过滤功能”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n```javasript\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\nreturn index % 3 === 0 || x >= 8;\n}); \nconsole.log(arr2); //[1, 4, 7, 8, 9, 10]\n\n```\n#### 13.every()\n\nevery()，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回true。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) {\nreturn x < 10;\n}); \nconsole.log(arr2); //true\nvar arr3 = arr.every(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr3); // false\n```\n####  14.some()\nsome()：判断数组中是否存在满足条件的项，只要有一项满足，就会返回true。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr2); //true\nvar arr3 = arr.some(function(x) {\nreturn x < 1;\n}); \nconsole.log(arr3); // false\n```\n#### 15.reduce()和reduceRight()\n这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后，然而reduceRight()则是从数组的最后一项开始，向前遍历到第一项。\n下面代码实现了数组求和：\n```javascript\nvar values = [1,2,3,4,5];\nvar sum = values.reduceRight(function(prev, cur, index, array){\nreturn prev + cur;\n},10);\nconsole.log(sum); //25\n```","source":"_posts/数组操作方法.md","raw":"---\ntitle: 数组操作方法\ncategories: 原生JS\ncomments: true\n---\n\n数组原形方法有以下几种:\njoin(),push(),pop(),sort(),reverse(),concat(),\nslice(),splice(),indexOf(),lastIndexOf(),forEach(),map(),\nfilter(),every(),some(),reduce(),reduceRight();\n\n<!--more-->\n\n#### 1.join()，不改变原数组。\njoin(separator):将数组的元素组成一个字符串，以separator为分隔符，省略则默认为逗号，该方法只接受一个参数。\n\n```javascript\nvar arr = [1,2,3];\nconsole.log(arr.join()); // 1,2,3\nconsole.log(arr.join(\"-\")); // 1-2-3\nconsole.log(arr); // [1, 2, 3]（原数组不变）\n```\n#### 2.push()与pop()，改变元素组\n- push():可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，**并返回修改后数组的长度**。\n- pop():数组末尾移除最后一项，减少数组的length的值，然后返回移除的项。\n\n```javascript\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.push(\"Jack\",\"Sean\");\nconsole.log(count); // 5\nconsole.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop();\nconsole.log(item); // Sean\nconsole.log(arr); // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n#### 3.shift()和unshift()，改变原数组\n- shift():删除原数组的第一项，并返回删除元素的值，如果为空则返回undefined。\n- unshift():将参数添加到原数组开头，**并返回数组的长度**。\n```javascript\nvar arr = [\"Lily\",\"lucy\",\"Tom\"];\nvar count = arr.unshift(\"Jack\",\"Sean\");\nconsole.log(count); // 5\nconsole.log(arr); //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift();\nconsole.log(item); // Jack\nconsole.log(arr); // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n#### 4.sort(),改变原数组\n按升序列排序数组系那个（从小到大），在排序时，sort()方法会调用每个数组的toString()转型方法，**然后比较得到的字符串**，已确定如何排序。即使数组中每一个都是数值,sort()方法比较的意识字符串，因此会出现以下情况：\n```javascript\nvar arr1 = [\"a\", \"d\", \"c\", \"b\"];\nconsole.log(arr1.sort()); // [\"a\", \"b\", \"c\", \"d\"]\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort()); // [13, 24, 3, 51]\nconsole.log(arr2); // [13, 24, 3, 51](元数组被改变)\n```\n为了解决上述问题，sort()方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：\n```javascript\nfunction compare(value1, value2) {\nif (value1 < value2) {\nreturn -1;\n} else if (value1 > value2) {\nreturn 1;\n} else {\nreturn 0;\n}\n}\narr2 = [13, 24, 51, 3];\nconsole.log(arr2.sort(compare)); // [3, 13, 24, 51]\n```\n如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。\n\n#### 5.reverse()，改变原数组\nreverse():反转数组项的顺序\n```javascript\nreverse()：反转数组项的顺序。\n?\n1\n2\n3\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); //[3, 51, 24, 13]\nconsole.log(arr); //[3, 51, 24, 13](原数组改变)\n```\n#### 6.concat()，不改变原数组\nconcat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，**在没有给concat()方法传递一个参数的情况下，它只是复制当前数组并返回副本。**\n  ```javascript\nvar arr = [1,3,5,7];\nvar arrCopy = arr.concat(9,[11,13]);\nconsole.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr); // [1, 3, 5, 7](原数组未被修改)\n```\n上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，**如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？**\n```javascript\nvar arrCopy2 = arr.concat([9,[11,13]]);\nconsole.log(arrCopy2); //[1, 3, 5, 7, 9, Array[2]]\nconsole.log(arrCopy2[5]); //[11, 13]\n```\n#### 7.slice() 不改变原数组\nslice():返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项-但不包括结束位置的项。\n```javascript\nvar arr = [1,3,5,7,9,11];\nvar arrCopy = arr.slice(1);\nvar arrCopy2 = arr.slice(1,4);\nvar arrCopy3 = arr.slice(1,-2);\nvar arrCopy4 = arr.slice(-4,-1);\nconsole.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy); //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2); //[3, 5, 7]\nconsole.log(arrCopy3); //[3, 5, 7]\nconsole.log(arrCopy4); //[5, 7, 9]\n```\n#### 8.splice()可以实现删除、插入和替换 改变原数组\n- 删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2)会删除数组中的前两项。\n- 插入：可以向指定位置插入任意数量的项，需要3个参数，起始位置、0（要删除的项数）和要插入的项，例如splice(2,0,4,6)会在当前数组的位置2开始插入4和6\n- 替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要3个参数，只需要指定3个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如splice(2,1,4,6)会删除当前数组位置2的项，然后再从位置2开始插入4和6。\n```javascript\nvar arr = [1,3,5,7,9,11];\nvar arrRemoved = arr.splice(0,2);\nconsole.log(arr); //[5, 7, 9, 11]\nconsole.log(arrRemoved); //[1, 3]\nvar arrRemoved2 = arr.splice(2,0,4,6);\nconsole.log(arr); // [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2); // []\nvar arrRemoved3 = arr.splice(1,1,2,4);\nconsole.log(arr); // [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3); //[7]\n```\n#### 9.indexOf()和lastIndexOf() \n- indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。\n- lastIndexOf()：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找\n```javascript\nvar arr = [1,3,5,7,7,5,3,1];\nconsole.log(arr.indexOf(5)); //2\nconsole.log(arr.lastIndexOf(5)); //5\nconsole.log(arr.indexOf(5,2)); //2\nconsole.log(arr.lastIndexOf(5,4)); //2\nconsole.log(arr.indexOf(\"5\")); //-1\n```\n#### 10.forEach() 遍历\n对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\narr.forEach(function(x, index, a){\nconsole.log(x + '|' + index + '|' + (a === arr));\n});\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n```\n#### 11.map()\nmap()：指“映射”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.map(function(item){\nreturn item*item;\n});\nconsole.log(arr2); //[1, 4, 9, 16, 25]\n```\n#### 12.filter()\nfilter(): “过滤功能”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n```javasript\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\nreturn index % 3 === 0 || x >= 8;\n}); \nconsole.log(arr2); //[1, 4, 7, 8, 9, 10]\n\n```\n#### 13.every()\n\nevery()，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回true。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.every(function(x) {\nreturn x < 10;\n}); \nconsole.log(arr2); //true\nvar arr3 = arr.every(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr3); // false\n```\n####  14.some()\nsome()：判断数组中是否存在满足条件的项，只要有一项满足，就会返回true。\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = arr.some(function(x) {\nreturn x < 3;\n}); \nconsole.log(arr2); //true\nvar arr3 = arr.some(function(x) {\nreturn x < 1;\n}); \nconsole.log(arr3); // false\n```\n#### 15.reduce()和reduceRight()\n这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后，然而reduceRight()则是从数组的最后一项开始，向前遍历到第一项。\n下面代码实现了数组求和：\n```javascript\nvar values = [1,2,3,4,5];\nvar sum = values.reduceRight(function(prev, cur, index, array){\nreturn prev + cur;\n},10);\nconsole.log(sum); //25\n```","slug":"数组操作方法","published":1,"date":"2018-01-15T08:18:09.895Z","updated":"2018-01-15T08:19:51.758Z","layout":"post","photos":[],"link":"","_id":"cjcr3j7lc001fj8vr1frb30lp","content":"<p>数组原形方法有以下几种:<br>join(),push(),pop(),sort(),reverse(),concat(),<br>slice(),splice(),indexOf(),lastIndexOf(),forEach(),map(),<br>filter(),every(),some(),reduce(),reduceRight();</p>\n<a id=\"more\"></a>\n<h4 id=\"1-join-，不改变原数组。\"><a href=\"#1-join-，不改变原数组。\" class=\"headerlink\" title=\"1.join()，不改变原数组。\"></a>1.join()，不改变原数组。</h4><p>join(separator):将数组的元素组成一个字符串，以separator为分隔符，省略则默认为逗号，该方法只接受一个参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join()); <span class=\"comment\">// 1,2,3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join(<span class=\"string\">\"-\"</span>)); <span class=\"comment\">// 1-2-3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-push-与pop-，改变元素组\"><a href=\"#2-push-与pop-，改变元素组\" class=\"headerlink\" title=\"2.push()与pop()，改变元素组\"></a>2.push()与pop()，改变元素组</h4><ul>\n<li>push():可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，<strong>并返回修改后数组的长度</strong>。</li>\n<li>pop():数组末尾移除最后一项，减少数组的length的值，然后返回移除的项。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">\"Lily\"</span>,<span class=\"string\">\"lucy\"</span>,<span class=\"string\">\"Tom\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.push(<span class=\"string\">\"Jack\"</span>,<span class=\"string\">\"Sean\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.pop();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item); <span class=\"comment\">// Sean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shift-和unshift-，改变原数组\"><a href=\"#3-shift-和unshift-，改变原数组\" class=\"headerlink\" title=\"3.shift()和unshift()，改变原数组\"></a>3.shift()和unshift()，改变原数组</h4><ul>\n<li>shift():删除原数组的第一项，并返回删除元素的值，如果为空则返回undefined。</li>\n<li>unshift():将参数添加到原数组开头，<strong>并返回数组的长度</strong>。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">\"Lily\"</span>,<span class=\"string\">\"lucy\"</span>,<span class=\"string\">\"Tom\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.unshift(<span class=\"string\">\"Jack\"</span>,<span class=\"string\">\"Sean\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.shift();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item); <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"4-sort-改变原数组\"><a href=\"#4-sort-改变原数组\" class=\"headerlink\" title=\"4.sort(),改变原数组\"></a>4.sort(),改变原数组</h4><p>按升序列排序数组系那个（从小到大），在排序时，sort()方法会调用每个数组的toString()转型方法，<strong>然后比较得到的字符串</strong>，已确定如何排序。即使数组中每一个都是数值,sort()方法比较的意识字符串，因此会出现以下情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"b\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.sort()); <span class=\"comment\">// [\"a\", \"b\", \"c\", \"d\"]</span></span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort()); <span class=\"comment\">// [13, 24, 3, 51]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">// [13, 24, 3, 51](元数组被改变)</span></span><br></pre></td></tr></table></figure></p>\n<p>为了解决上述问题，sort()方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort(compare)); <span class=\"comment\">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure></p>\n<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。</p>\n<h4 id=\"5-reverse-，改变原数组\"><a href=\"#5-reverse-，改变原数组\" class=\"headerlink\" title=\"5.reverse()，改变原数组\"></a>5.reverse()，改变原数组</h4><p>reverse():反转数组项的顺序<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reverse()：反转数组项的顺序。</span><br><span class=\"line\">?</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.reverse()); <span class=\"comment\">//[3, 51, 24, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-concat-，不改变原数组\"><a href=\"#6-concat-，不改变原数组\" class=\"headerlink\" title=\"6.concat()，不改变原数组\"></a>6.concat()，不改变原数组</h4><p>concat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，<strong>在没有给concat()方法传递一个参数的情况下，它只是复制当前数组并返回副本。</strong><br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.concat(<span class=\"number\">9</span>,[<span class=\"number\">11</span>,<span class=\"number\">13</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy); <span class=\"comment\">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，<strong>如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.concat([<span class=\"number\">9</span>,[<span class=\"number\">11</span>,<span class=\"number\">13</span>]]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2); <span class=\"comment\">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2[<span class=\"number\">5</span>]); <span class=\"comment\">//[11, 13]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-slice-不改变原数组\"><a href=\"#7-slice-不改变原数组\" class=\"headerlink\" title=\"7.slice() 不改变原数组\"></a>7.slice() 不改变原数组</h4><p>slice():返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项-但不包括结束位置的项。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.slice(<span class=\"number\">1</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy3 = arr.slice(<span class=\"number\">1</span>,<span class=\"number\">-2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy4 = arr.slice(<span class=\"number\">-4</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy); <span class=\"comment\">//[3, 5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2); <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy3); <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy4); <span class=\"comment\">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-splice-可以实现删除、插入和替换-改变原数组\"><a href=\"#8-splice-可以实现删除、插入和替换-改变原数组\" class=\"headerlink\" title=\"8.splice()可以实现删除、插入和替换 改变原数组\"></a>8.splice()可以实现删除、插入和替换 改变原数组</h4><ul>\n<li>删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2)会删除数组中的前两项。</li>\n<li>插入：可以向指定位置插入任意数量的项，需要3个参数，起始位置、0（要删除的项数）和要插入的项，例如splice(2,0,4,6)会在当前数组的位置2开始插入4和6</li>\n<li>替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要3个参数，只需要指定3个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如splice(2,1,4,6)会删除当前数组位置2的项，然后再从位置2开始插入4和6。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved = arr.splice(<span class=\"number\">0</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved); <span class=\"comment\">//[1, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved2 = arr.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [5, 7, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved2); <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved3 = arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved3); <span class=\"comment\">//[7]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"9-indexOf-和lastIndexOf\"><a href=\"#9-indexOf-和lastIndexOf\" class=\"headerlink\" title=\"9.indexOf()和lastIndexOf()\"></a>9.indexOf()和lastIndexOf()</h4><ul>\n<li>indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。</li>\n<li>lastIndexOf()：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>,<span class=\"number\">2</span>)); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>,<span class=\"number\">4</span>)); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"string\">\"5\"</span>)); <span class=\"comment\">//-1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"10-forEach-遍历\"><a href=\"#10-forEach-遍历\" class=\"headerlink\" title=\"10.forEach() 遍历\"></a>10.forEach() 遍历</h4><p>对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, index, a</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x + <span class=\"string\">'|'</span> + index + <span class=\"string\">'|'</span> + (a === arr));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">// 1|0|true</span></span><br><span class=\"line\"><span class=\"comment\">// 2|1|true</span></span><br><span class=\"line\"><span class=\"comment\">// 3|2|true</span></span><br><span class=\"line\"><span class=\"comment\">// 4|3|true</span></span><br><span class=\"line\"><span class=\"comment\">// 5|4|true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"11-map\"><a href=\"#11-map\" class=\"headerlink\" title=\"11.map()\"></a>11.map()</h4><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> item*item;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"12-filter\"><a href=\"#12-filter\" class=\"headerlink\" title=\"12.filter()\"></a>12.filter()</h4><p>filter(): “过滤功能”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class=\"line\">var arr2 = arr.filter(function(x, index) &#123;</span><br><span class=\"line\">return index % 3 === 0 || x &gt;= 8;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">console.log(arr2); //[1, 4, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"13-every\"><a href=\"#13-every\" class=\"headerlink\" title=\"13.every()\"></a>13.every()</h4><p>every()，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"14-some\"><a href=\"#14-some\" class=\"headerlink\" title=\"14.some()\"></a>14.some()</h4><p>some()：判断数组中是否存在满足条件的项，只要有一项满足，就会返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"15-reduce-和reduceRight\"><a href=\"#15-reduce-和reduceRight\" class=\"headerlink\" title=\"15.reduce()和reduceRight()\"></a>15.reduce()和reduceRight()</h4><p>这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后，然而reduceRight()则是从数组的最后一项开始，向前遍历到第一项。<br>下面代码实现了数组求和：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = values.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> prev + cur;</span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum); <span class=\"comment\">//25</span></span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>数组原形方法有以下几种:<br>join(),push(),pop(),sort(),reverse(),concat(),<br>slice(),splice(),indexOf(),lastIndexOf(),forEach(),map(),<br>filter(),every(),some(),reduce(),reduceRight();</p>","more":"<h4 id=\"1-join-，不改变原数组。\"><a href=\"#1-join-，不改变原数组。\" class=\"headerlink\" title=\"1.join()，不改变原数组。\"></a>1.join()，不改变原数组。</h4><p>join(separator):将数组的元素组成一个字符串，以separator为分隔符，省略则默认为逗号，该方法只接受一个参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join()); <span class=\"comment\">// 1,2,3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join(<span class=\"string\">\"-\"</span>)); <span class=\"comment\">// 1-2-3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-push-与pop-，改变元素组\"><a href=\"#2-push-与pop-，改变元素组\" class=\"headerlink\" title=\"2.push()与pop()，改变元素组\"></a>2.push()与pop()，改变元素组</h4><ul>\n<li>push():可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，<strong>并返回修改后数组的长度</strong>。</li>\n<li>pop():数组末尾移除最后一项，减少数组的length的值，然后返回移除的项。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">\"Lily\"</span>,<span class=\"string\">\"lucy\"</span>,<span class=\"string\">\"Tom\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.push(<span class=\"string\">\"Jack\"</span>,<span class=\"string\">\"Sean\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.pop();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item); <span class=\"comment\">// Sean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"3-shift-和unshift-，改变原数组\"><a href=\"#3-shift-和unshift-，改变原数组\" class=\"headerlink\" title=\"3.shift()和unshift()，改变原数组\"></a>3.shift()和unshift()，改变原数组</h4><ul>\n<li>shift():删除原数组的第一项，并返回删除元素的值，如果为空则返回undefined。</li>\n<li>unshift():将参数添加到原数组开头，<strong>并返回数组的长度</strong>。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">\"Lily\"</span>,<span class=\"string\">\"lucy\"</span>,<span class=\"string\">\"Tom\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.unshift(<span class=\"string\">\"Jack\"</span>,<span class=\"string\">\"Sean\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count); <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.shift();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item); <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"4-sort-改变原数组\"><a href=\"#4-sort-改变原数组\" class=\"headerlink\" title=\"4.sort(),改变原数组\"></a>4.sort(),改变原数组</h4><p>按升序列排序数组系那个（从小到大），在排序时，sort()方法会调用每个数组的toString()转型方法，<strong>然后比较得到的字符串</strong>，已确定如何排序。即使数组中每一个都是数值,sort()方法比较的意识字符串，因此会出现以下情况：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">\"a\"</span>, <span class=\"string\">\"d\"</span>, <span class=\"string\">\"c\"</span>, <span class=\"string\">\"b\"</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.sort()); <span class=\"comment\">// [\"a\", \"b\", \"c\", \"d\"]</span></span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort()); <span class=\"comment\">// [13, 24, 3, 51]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">// [13, 24, 3, 51](元数组被改变)</span></span><br></pre></td></tr></table></figure></p>\n<p>为了解决上述问题，sort()方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort(compare)); <span class=\"comment\">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure></p>\n<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。</p>\n<h4 id=\"5-reverse-，改变原数组\"><a href=\"#5-reverse-，改变原数组\" class=\"headerlink\" title=\"5.reverse()，改变原数组\"></a>5.reverse()，改变原数组</h4><p>reverse():反转数组项的顺序<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reverse()：反转数组项的顺序。</span><br><span class=\"line\">?</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.reverse()); <span class=\"comment\">//[3, 51, 24, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-concat-，不改变原数组\"><a href=\"#6-concat-，不改变原数组\" class=\"headerlink\" title=\"6.concat()，不改变原数组\"></a>6.concat()，不改变原数组</h4><p>concat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，<strong>在没有给concat()方法传递一个参数的情况下，它只是复制当前数组并返回副本。</strong><br>  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.concat(<span class=\"number\">9</span>,[<span class=\"number\">11</span>,<span class=\"number\">13</span>]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy); <span class=\"comment\">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，<strong>如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？</strong><br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.concat([<span class=\"number\">9</span>,[<span class=\"number\">11</span>,<span class=\"number\">13</span>]]);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2); <span class=\"comment\">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2[<span class=\"number\">5</span>]); <span class=\"comment\">//[11, 13]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"7-slice-不改变原数组\"><a href=\"#7-slice-不改变原数组\" class=\"headerlink\" title=\"7.slice() 不改变原数组\"></a>7.slice() 不改变原数组</h4><p>slice():返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice()方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项-但不包括结束位置的项。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.slice(<span class=\"number\">1</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.slice(<span class=\"number\">1</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy3 = arr.slice(<span class=\"number\">1</span>,<span class=\"number\">-2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy4 = arr.slice(<span class=\"number\">-4</span>,<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy); <span class=\"comment\">//[3, 5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2); <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy3); <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy4); <span class=\"comment\">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"8-splice-可以实现删除、插入和替换-改变原数组\"><a href=\"#8-splice-可以实现删除、插入和替换-改变原数组\" class=\"headerlink\" title=\"8.splice()可以实现删除、插入和替换 改变原数组\"></a>8.splice()可以实现删除、插入和替换 改变原数组</h4><ul>\n<li>删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2)会删除数组中的前两项。</li>\n<li>插入：可以向指定位置插入任意数量的项，需要3个参数，起始位置、0（要删除的项数）和要插入的项，例如splice(2,0,4,6)会在当前数组的位置2开始插入4和6</li>\n<li>替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要3个参数，只需要指定3个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如splice(2,1,4,6)会删除当前数组位置2的项，然后再从位置2开始插入4和6。<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>,<span class=\"number\">11</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved = arr.splice(<span class=\"number\">0</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved); <span class=\"comment\">//[1, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved2 = arr.splice(<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [5, 7, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved2); <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved3 = arr.splice(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved3); <span class=\"comment\">//[7]</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"9-indexOf-和lastIndexOf\"><a href=\"#9-indexOf-和lastIndexOf\" class=\"headerlink\" title=\"9.indexOf()和lastIndexOf()\"></a>9.indexOf()和lastIndexOf()</h4><ul>\n<li>indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。</li>\n<li>lastIndexOf()：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">7</span>,<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">1</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>)); <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>,<span class=\"number\">2</span>)); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>,<span class=\"number\">4</span>)); <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"string\">\"5\"</span>)); <span class=\"comment\">//-1</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"10-forEach-遍历\"><a href=\"#10-forEach-遍历\" class=\"headerlink\" title=\"10.forEach() 遍历\"></a>10.forEach() 遍历</h4><p>对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, index, a</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x + <span class=\"string\">'|'</span> + index + <span class=\"string\">'|'</span> + (a === arr));</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">// 1|0|true</span></span><br><span class=\"line\"><span class=\"comment\">// 2|1|true</span></span><br><span class=\"line\"><span class=\"comment\">// 3|2|true</span></span><br><span class=\"line\"><span class=\"comment\">// 4|3|true</span></span><br><span class=\"line\"><span class=\"comment\">// 5|4|true</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"11-map\"><a href=\"#11-map\" class=\"headerlink\" title=\"11.map()\"></a>11.map()</h4><p>map()：指“映射”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> item*item;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"12-filter\"><a href=\"#12-filter\" class=\"headerlink\" title=\"12.filter()\"></a>12.filter()</h4><p>filter(): “过滤功能”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class=\"line\">var arr2 = arr.filter(function(x, index) &#123;</span><br><span class=\"line\">return index % 3 === 0 || x &gt;= 8;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\">console.log(arr2); //[1, 4, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"13-every\"><a href=\"#13-every\" class=\"headerlink\" title=\"13.every()\"></a>13.every()</h4><p>every()，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">10</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"14-some\"><a href=\"#14-some\" class=\"headerlink\" title=\"14.some()\"></a>14.some()</h4><p>some()：判断数组中是否存在满足条件的项，只要有一项满足，就会返回true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2); <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> x &lt; <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;); </span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"15-reduce-和reduceRight\"><a href=\"#15-reduce-和reduceRight\" class=\"headerlink\" title=\"15.reduce()和reduceRight()\"></a>15.reduce()和reduceRight()</h4><p>这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce()方法从数组的第一项开始，逐个遍历到最后，然而reduceRight()则是从数组的最后一项开始，向前遍历到第一项。<br>下面代码实现了数组求和：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = values.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> prev + cur;</span><br><span class=\"line\">&#125;,<span class=\"number\">10</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum); <span class=\"comment\">//25</span></span><br></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjcr3j7d20001j8vruyxt0kwk","category_id":"cjcr3j7d90003j8vrrlgvv355","_id":"cjcr3j7ds000aj8vrxdcbkkig"},{"post_id":"cjcr3j7d70002j8vr9qt6e3a6","category_id":"cjcr3j7do0007j8vrqrp16wan","_id":"cjcr3j7dx000ej8vr8dzj2d7a"},{"post_id":"cjcr3j7dh0004j8vrknithycp","category_id":"cjcr3j7dt000bj8vrzkoypzvp","_id":"cjcr3j7e5000ij8vrng9vce45"},{"post_id":"cjcr3j7dk0005j8vrd5zbg16f","category_id":"cjcr3j7dx000fj8vr4b6n6dzz","_id":"cjcr3j7ec000mj8vretm8rmdu"},{"post_id":"cjcr3j7dm0006j8vr7nb93o9f","category_id":"cjcr3j7e6000jj8vrsxxryaqm","_id":"cjcr3j7ek000sj8vr3jbhl0h8"},{"post_id":"cjcr3j7eg000pj8vr28xb2ox9","category_id":"cjcr3j7do0007j8vrqrp16wan","_id":"cjcr3j7eo000vj8vrs9eif3va"},{"post_id":"cjcr3j7do0008j8vrsqu90k7m","category_id":"cjcr3j7dx000fj8vr4b6n6dzz","_id":"cjcr3j7er000yj8vr3lhh7lei"},{"post_id":"cjcr3j7ek000tj8vrhzh3an96","category_id":"cjcr3j7do0007j8vrqrp16wan","_id":"cjcr3j7er000zj8vri00h7dzg"},{"post_id":"cjcr3j7dq0009j8vrmkvumxl8","category_id":"cjcr3j7ej000rj8vrob2r68b7","_id":"cjcr3j7es0011j8vr617no5cm"},{"post_id":"cjcr3j7en000uj8vrfzc72jvp","category_id":"cjcr3j7do0007j8vrqrp16wan","_id":"cjcr3j7es0012j8vrnl2t0kwa"},{"post_id":"cjcr3j7dt000cj8vr94jlbvnx","category_id":"cjcr3j7ej000rj8vrob2r68b7","_id":"cjcr3j7et0014j8vr48vxgxsw"},{"post_id":"cjcr3j7dv000dj8vrf5rrd5sz","category_id":"cjcr3j7ej000rj8vrob2r68b7","_id":"cjcr3j7et0016j8vrihxgd3tf"},{"post_id":"cjcr3j7dy000gj8vr7bjrmhqn","category_id":"cjcr3j7ej000rj8vrob2r68b7","_id":"cjcr3j7et0017j8vr639qdpm9"},{"post_id":"cjcr3j7e2000hj8vr19i8mbur","category_id":"cjcr3j7et0015j8vr3vct96jr","_id":"cjcr3j7eu0019j8vrprmyolm6"},{"post_id":"cjcr3j7e7000kj8vraonrr34p","category_id":"cjcr3j7eu0018j8vryrl4f269","_id":"cjcr3j7eu001bj8vrl8encol9"},{"post_id":"cjcr3j7ea000lj8vr53zj5391","category_id":"cjcr3j7eu001aj8vrywlysagn","_id":"cjcr3j7ev001dj8vr0bcu6un6"},{"post_id":"cjcr3j7eq000xj8vrt97e1691","category_id":"cjcr3j7eu001cj8vrdlyk30qi","_id":"cjcr3j7ev001ej8vrvgevugz8"},{"post_id":"cjcr3j7lc001fj8vr1frb30lp","category_id":"cjcr3j7do0007j8vrqrp16wan","_id":"cjcr3j7lk001ij8vrccr2jh31"}],"PostTag":[],"Tag":[]}}