{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/problem/1.png","path":"images/problem/1.png","modified":0,"renderable":0},{"_id":"source/images/problem/2.png","path":"images/problem/2.png","modified":0,"renderable":0},{"_id":"source/images/prototype/1.png","path":"images/prototype/1.png","modified":0,"renderable":0},{"_id":"source/images/prototype/2.png","path":"images/prototype/2.png","modified":0,"renderable":0},{"_id":"source/images/common/kuaipai.png","path":"images/common/kuaipai.png","modified":0,"renderable":0},{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":0,"renderable":0},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1521526652412},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1521526652412},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1521526652412},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1521526652412},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1521526652412},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1521526652412},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1521526652412},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1521526652412},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1521526652412},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1521526652412},{"_id":"themes/next/README.cn.md","hash":"87950c415dd162ff78e98b41f1148b85462103e2","modified":1521526652412},{"_id":"themes/next/README.md","hash":"927f82cfeb5969a89b815b5ec3a3f2881e3b1bb4","modified":1521526652412},{"_id":"themes/next/_config.yml","hash":"b26b51e4f6f3347f36f6053d6b491e02b6fdcd27","modified":1521516581800},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1521526652412},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1521526652412},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1521526652444},{"_id":"source/_posts/HTTPS.md","hash":"01cb2a6abba85f1a997b2926c2e4bd41f52dae26","modified":1521516581814},{"_id":"source/_posts/JS代码片段.md","hash":"cbdfef20b532ef2a3a8a533bb3a2857af2f0d58a","modified":1520921585941},{"_id":"source/_posts/JS原生-ES6.md","hash":"0a963252f5a5ac3dcbf32c09a84efd4b2d4889d1","modified":1521516581815},{"_id":"source/_posts/JS基础-ES5.md","hash":"a836199745a293f565e240507d01390552455389","modified":1521516581815},{"_id":"source/_posts/Object-defineProperty.md","hash":"1f0ecf8d58e74ee84123419830747006191a7ad7","modified":1521516581816},{"_id":"source/_posts/Observable.md","hash":"0ef9e37d4d53efce4a30641ee9dbca7809d3f342","modified":1521516581816},{"_id":"source/_posts/PWA-offline.md","hash":"c228db34ce0c9c1b3c04018f72c1a21e61335fef","modified":1520868562786},{"_id":"source/_posts/PWA-pushMessage.md","hash":"60641e74c821faef5e15dbb1240ed78c967125b2","modified":1520868562787},{"_id":"source/_posts/angular-form.md","hash":"5ef04b1f34bdfa8101df50403dffe418d42dd392","modified":1521516581818},{"_id":"source/_posts/angular-数据绑定.md","hash":"d5d45194537cec04a9d927d930089c69f8662b3c","modified":1521516581818},{"_id":"source/_posts/angular-线上商城学习.md","hash":"5688f4df4e1eee9ced63f34a02f9473dcbfc7f85","modified":1521516581818},{"_id":"source/_posts/angular基础.md","hash":"ae4071702052f007283f10ae46702203c36b8943","modified":1521516581819},{"_id":"source/_posts/css-小技巧.md","hash":"afaf32be13070fa80f9ce929f807edb503fd603b","modified":1520921583235},{"_id":"source/_posts/localstorage.md","hash":"b08c8bc1c13c0a527ed61cc7752e4f1f1ab05b35","modified":1520868562788},{"_id":"source/_posts/react-native-入门.md","hash":"aec7677b4820e5760beae2329e0aa7008b7bae1f","modified":1521516581820},{"_id":"source/_posts/this指向.md","hash":"6175b0896cacec3b61ec8e3727cf025b4d6a810a","modified":1520868562789},{"_id":"source/_posts/优化.md","hash":"3038dfcecdf0f1f1a328122fc74b7a708b4f33c7","modified":1521516581821},{"_id":"source/_posts/webpack项目配置.md","hash":"76fb7553665d45a4a257b2a926c94e613c4415e5","modified":1520868562789},{"_id":"source/_posts/作用域.md","hash":"14e1d2c7352c482d27c53645535540dcf5a6ced4","modified":1521516581821},{"_id":"source/_posts/你不知道的JavaScript.md","hash":"85963882029ddb832fc30d2df970be6504e1df44","modified":1521516581822},{"_id":"source/_posts/如何实现双向数据绑定-mvvm.md","hash":"351310c719d5e5fc368c2d780cc2dce83a80b879","modified":1521516581822},{"_id":"source/_posts/字符串操作方法.md","hash":"5a5003b736ab8f26eccbb682eaea69b20e3cb4d4","modified":1521516581822},{"_id":"source/_posts/尤玉溪-Live.md","hash":"faa4d8e53399de36e336d669912f0c8b3314e18c","modified":1521516581823},{"_id":"source/_posts/数组操作方法.md","hash":"814391c60255d5a8b36f3029710c231fd063b0d2","modified":1521516581823},{"_id":"source/_posts/有趣JS题.md","hash":"3ad120e25e42498236e94b06855004dd0fed0b81","modified":1521516581823},{"_id":"source/_posts/疑难杂问整理（原生JS）.md","hash":"1d63794ba96e3a35e96ad41a25d0c633a34715df","modified":1520868562792},{"_id":"source/_posts/面试积累.md","hash":"8f8bdff00a754e38069084eba990da0bd8545281","modified":1521516581824},{"_id":"source/categories/index.md","hash":"1bd4bb9b63c655b4633c628c7f4e0d8fec921e47","modified":1521516581825},{"_id":"source/tags/index.md","hash":"d375fe31796f00ac23cfd31cb7491cb385d977aa","modified":1521516581833},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1520868760409},{"_id":"themes/next/.git/config","hash":"340cff4364d9733a32042fdb93097c334a781c93","modified":1521526652397},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1520868657416},{"_id":"themes/next/.git/index","hash":"325887f8e7b8d4c3912d4953cc3b0a7ba99ab849","modified":1521526652528},{"_id":"themes/next/.git/packed-refs","hash":"339779e225d913a344c5e6210617badd049c4434","modified":1520868760403},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1521526652412},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"b1ec000babd42bb7ffd26f5ad8aac9b5bec79ae5","modified":1521526652412},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1521526652412},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1520868760423},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1521526652412},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1521526652412},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1521526652412},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1521526652412},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1521526652412},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1521526652412},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1521526652412},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1521526652412},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1521526652412},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1521526652412},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1521526652412},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1521526652412},{"_id":"themes/next/languages/zh-Hans.yml","hash":"66b9b42f143c3cb2f782a94abd4c4cbd5fd7f55f","modified":1521526652412},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1521526652412},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1521526652412},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1521526652412},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1521526652412},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1521526652444},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1521526652444},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1521526652444},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1521526652444},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1521526652444},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1521526652444},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1521526652444},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1521526652444},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1521526652444},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1521526652528},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1521526652528},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1521526652528},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760499},{"_id":"source/images/problem/1.png","hash":"a566f9497bb5755ded08e82a615eabba2b2b668b","modified":1520868562795},{"_id":"source/images/problem/2.png","hash":"37ce91da9e0bf6fd101d1025be458d3ca9f09da7","modified":1520868562796},{"_id":"source/images/prototype/1.png","hash":"b56d7ed5068f6f314ba1d48a694f3917111fa659","modified":1520868562797},{"_id":"source/images/prototype/2.png","hash":"fc3a6c80a4d80fb8b5889c506e2ad7592b544134","modified":1520868562798},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1520868657417},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1520868657418},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1520868657418},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1520868657418},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1520868657419},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1520868657419},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1520868657420},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1520868657420},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1520868657420},{"_id":"themes/next/.git/hooks/update.sample","hash":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1521526642363},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1520868657421},{"_id":"themes/next/.git/logs/HEAD","hash":"1a2d8aaf84771cef7fb5267d836d245167daa201","modified":1521526652397},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1521526652412},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1521526652412},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1521526652412},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1521526652412},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1521526652412},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1521526652412},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1521526652412},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1521526652412},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4adc65a602d1276615da3b887dcbf2ac68e7382b","modified":1521526652428},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1521526652428},{"_id":"themes/next/layout/_partials/head.swig","hash":"f14a39dad1ddd98e6d3ceb25dda092ba80d391b5","modified":1521526652428},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1521526652428},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1521526652428},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1521526652428},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1521526652428},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1521526652428},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1521526652428},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1521526652428},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1521526652428},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1521526652428},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1521526652428},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1521526652428},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1521526652428},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1521526652428},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1521526652428},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1521526652444},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1521526652444},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1521526652444},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1521526652444},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1521526652444},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1521526652444},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1521526652444},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1521526652444},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1521526652444},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1521526652481},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1521526652481},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1520868760499},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1521526652482},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1521526652482},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1521526652483},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1521526652483},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1521526652483},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1521526652484},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1520868760499},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1521526652484},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1520868760502},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1520868760503},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520868760503},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1520868760503},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1521526652485},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1521526652485},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1521526652485},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1520868760505},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760443},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760443},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760487},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760487},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760488},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760497},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1520868760499},{"_id":"source/images/common/kuaipai.png","hash":"84a90e636ed5bbb0f93aca7834426987e65bf438","modified":1520868562795},{"_id":"themes/next/.git/refs/heads/master","hash":"f4d9f6f8bc79e9bc071cf29324a74a1d78158ab9","modified":1520868760411},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1521526652428},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1521526652428},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1521526652428},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1521526652428},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1521526652428},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1521526652428},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1521526652428},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1521526652428},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1521526652428},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1521526652428},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1521526652428},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"7b11eac3a0685fa1ab2ab6ecff60afc4f15f0d16","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1521526652428},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"493bd5999a1061b981922be92d8277a0f9152447","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"4dcc3213c033994d342d02b800b6229295433d30","modified":1521526652428},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1521526652428},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1521526652444},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1521526652444},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1521526652444},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1521526652444},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1521526652428},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1521526652459},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1521526652459},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1521526652459},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1521526652459},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1521526652480},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1521526652480},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1521526652480},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1521526652481},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1521526652486},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1521526652486},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1521526652486},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1521526652486},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1521526652487},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1521526652487},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1521526652487},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1521526652487},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1521526652488},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1521526652488},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1521526652488},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1520868760514},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1520868760516},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1521526652496},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1520868760518},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1520868760518},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1521526652496},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1521526652496},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1521526652496},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1521526652496},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1521526652512},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1521526652512},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1521526652512},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1521526652512},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1521526652512},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1521526652512},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1521526652512},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1520868760542},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1520868760542},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1520868760543},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1520868760543},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1520868760543},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1520868760544},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1520868760544},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1520868760544},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1520868760544},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1520868760545},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1520868760545},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1520868760545},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1520868760545},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1521526652512},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1521526652528},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1521526652528},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1521526652528},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1521526652528},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1521526652528},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1521526652528},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1521526652512},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1521526652528},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1521526652528},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1521526652512},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1521526652512},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1521526652512},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"1a2d8aaf84771cef7fb5267d836d245167daa201","modified":1521526652397},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1520868760408},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1521526652444},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1521526652459},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1521526652459},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1521526652459},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1521526652459},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1521526652459},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1521526652459},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1521526652459},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1521526652459},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1521526652475},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1521526652475},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1521526652475},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1521526652475},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1521526652476},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1521526652476},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1521526652476},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1521526652475},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1521526652477},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1521526652477},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1521526652478},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1521526652478},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1521526652478},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1521526652478},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1521526652479},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1521526652479},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1521526652479},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1521526652479},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1521526652479},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1521526652488},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1521526652491},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1521526652492},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1521526652493},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1520868760518},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1520868760518},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1520868760519},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1520868760519},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1520868760519},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1520868760520},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1520868760523},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1520868760524},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1520868760524},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1521526652496},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1520868760526},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1521526652496},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1521526652496},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1521526652528},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1521526652528},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1521526652492},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1520868760536},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1520868760537},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1521526652528},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"1a2d8aaf84771cef7fb5267d836d245167daa201","modified":1521526652397},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1521526652444},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1521526652459},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1521526652459},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1521526652477},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1521526652477},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1521526652478},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1520868760510},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1520868760511},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1520868760511},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1520868760511},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1520868760512},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1520868760520},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1520868760520},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1520868760521},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1520868760521},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1520868760522},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1520868760523},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1520868760530},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1520868760532},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1520868760536},{"_id":"themes/next/.git/objects/pack/pack-44982fc264fff35d139337d95663cb2f8d418931.idx","hash":"167d2c701cb534d16c3c5ed866f0992307f73230","modified":1520868759899},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1521526652496},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1521526652528},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1521526652512},{"_id":"themes/next/.git/objects/pack/pack-44982fc264fff35d139337d95663cb2f8d418931.pack","hash":"447b185d273f66aadc1e231dd8700f76f086454a","modified":1520868760042},{"_id":"source/images/avatar.jpg","hash":"663809c02cd10187b8903189eb4c6aed35e61a90","modified":1509705303929},{"_id":"themes/next/.git/objects/pack/pack-35be0f1b36a6f9640c84cdea2edab9ee6f6909d4.idx","hash":"a45013c035cd921a2f8603befc545e74f338761f","modified":1521526652329},{"_id":"themes/next/.git/objects/pack/pack-35be0f1b36a6f9640c84cdea2edab9ee6f6909d4.pack","hash":"398c75405ac39089cf7f70c7f859b5094058b7a8","modified":1521526652350}],"Category":[{"name":"http","_id":"cjepksjll00028gv6fa82vicb"},{"name":"原生JS","_id":"cjepksjm500068gv68ayqx6s8"},{"name":"数据劫持基石","_id":"cjepksjmb000a8gv6xtfudynx"},{"name":"rx.js","_id":"cjepksjn4000h8gv6cpf4r55b"},{"name":"PWA","_id":"cjepksjnd000m8gv6alhseg0h"},{"name":"angular","_id":"cjepksjnx000u8gv6bimdgswv"},{"name":"css","_id":"cjepksjoi001c8gv6ahfi0l02"},{"name":"webAPI","_id":"cjepksjom001h8gv6t5hutytv"},{"name":"react-native","_id":"cjepksjon001k8gv6bbrx64oi"},{"name":"项目构建工具","_id":"cjepksjoo001m8gv6jqx31n4s"},{"name":"vue","_id":"cjepksjop001o8gv6jjsz282j"}],"Data":[],"Page":[{"title":"分类","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ntype: \"categories\"\ncomments: false\n---\n","date":"2018-03-20T03:29:41.825Z","updated":"2018-03-20T03:29:41.825Z","path":"categories/index.html","_id":"cjepksjut001r8gv6ix5hayv3","layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","tags":"Testing","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ntags: Testing\n---\n","date":"2018-03-20T03:29:41.833Z","updated":"2018-03-20T03:29:41.833Z","path":"tags/index.html","_id":"cjepksjuv001s8gv64duwegnb","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"HTTPS","comments":1,"_content":"\nhttps 可以理解为 HTTP+TLS，TLS 是传输层加密协议，是 HTTPS 安全的核心，其前身是 SSL。TLS 主要有五部分 : 应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS 协议本身又是由 record 协议传输的。\n\n### 为什么要实现 HTTPS？\n\n为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。\n\n<!--more-->\n\n### 全站 HTTPS 必须解决的问题\n\n---\n\n**性能**\n\n* HTTPS 需要多次握手，因此网络耗时变长，用户从 HTTP 跳转到 HTTPS 需要一些时间。但是如果使用 SPDY，HTTPS 的速度甚至比 HTTP 快。HTTPS 对速度的影响主要来自两方面 :\n  1. 协议交换所增加的网络 RTT。\n  2. 加解密相关的计算耗时。\n* HTTPS 要做 RSA 校验，这会影响到设备性能。\n* 所有 CDN 节点要支持 HTTPS，而且需要有极其复杂的解决方案来面对 DDoS 的挑战。 ** 其次，兼容性及周边 :**\n* 页面中所有嵌入的资源（图片、附件、js 、视频等）都要改为 HTTPS 的，否者就会报警。\n\n### 基于协议和配置的优化\n\n1.HTTPS 访问速度优化 2.Tcp fast open\n\n#### HTTPS:\n\n网站通常的做法是对 HTTP 的访问服务器端做 302 跳转，跳转到 HTTPS。但是这个 302 跳转存在两个问题 : 1. 使用不安全的 HTTP 协议进行通信。 2. 增加一个 Round-Trip Time。\n\n而 HSTS 是 HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建链接。其实 HSTS 的最大作用是防止 302HTTP 劫持（中间人）HSTS 的缺点是浏览器支持率不高，另外配置 HTST 后 HTTPS 很难实时降级为 HTTP。\n\n采用 HSTS 协议的网站将保证浏览器始终连接到该网站的 HTTPS 加密版本，不需要用户手动在 URL 地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。\n\n在https://xxx 的响应头中含有 Strict-Transport-Security:max-age=31536000;includeSubDomains 这就意味着两点：\n\n1. 在一年的时间里（31536000 秒）中，浏览器只要向 XXX 或者其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接。比如用户在地址栏输入http://xxx 或者点击超链接，浏览器应当自动将 http 转写成 https, 然后直接向https://xxx/ 发起请求。\n2. 在接下来的一年中，如果 xxx 服务器发送的 TLS 证书无效，用户不能忽略浏览器警告继续访问网站。\n\n##### 作用\n\nHTST 可以用来抵御 SSL 剥离攻击。攻击者在用户访问 HTTP 页面时替换所有 https 开头的连接为 http。达到阻止 HTTPS 的目的。但是如果使用了 HTST，一旦服务器发送了 HSTS 字段，用户将不再允许忽略警告。\n\n##### 不足\n\n用户首次访问网站是不受 HSTS 保护的。这是因为首次访问时，浏览器还未收到 HSTS，所以仍有可能明文 HTTP 访问。HTST 会在一段时间后失效（由 max-age 指定 )。所以浏览器是否强制 HSTS 取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。\n\n一旦浏览器接受到 HSTS Header( 假如有效期是 1 年），但是网站的证书出现问题，那么在有效都无法访问网站。\n\n#### Session resume 复用 session\n\n1. 减少 CPU 消耗，因为不需要非对称秘钥交换的计算。\n2. 提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。\n\n##### Session cache\n\nSession cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。\n\nSession cache 有两个缺点：\n\n1. 需要消耗服务端内存来存储 session 内容。\n\n2. 目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。\n\nSession cache 也有一个非常大的优点：\n\n1. session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。\n\n百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。\n\n#### 使用 SPDY 或者 HTTP2\n\nSPDY 是 google 推出的优化 HTTP 传输效率的协议（https://www.chromium.org/spdy） 它基本上沿用了 HTTP 协议的语义 , 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。\n\nHTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。\n\n需要说明两点 :\n\n1. SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。\n\n2. SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。\n\nGoogle 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。\n\n百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。\n","source":"_posts/HTTPS.md","raw":"---\ntitle: HTTPS\ncategories: http\ncomments: true\n---\n\nhttps 可以理解为 HTTP+TLS，TLS 是传输层加密协议，是 HTTPS 安全的核心，其前身是 SSL。TLS 主要有五部分 : 应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS 协议本身又是由 record 协议传输的。\n\n### 为什么要实现 HTTPS？\n\n为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。\n\n<!--more-->\n\n### 全站 HTTPS 必须解决的问题\n\n---\n\n**性能**\n\n* HTTPS 需要多次握手，因此网络耗时变长，用户从 HTTP 跳转到 HTTPS 需要一些时间。但是如果使用 SPDY，HTTPS 的速度甚至比 HTTP 快。HTTPS 对速度的影响主要来自两方面 :\n  1. 协议交换所增加的网络 RTT。\n  2. 加解密相关的计算耗时。\n* HTTPS 要做 RSA 校验，这会影响到设备性能。\n* 所有 CDN 节点要支持 HTTPS，而且需要有极其复杂的解决方案来面对 DDoS 的挑战。 ** 其次，兼容性及周边 :**\n* 页面中所有嵌入的资源（图片、附件、js 、视频等）都要改为 HTTPS 的，否者就会报警。\n\n### 基于协议和配置的优化\n\n1.HTTPS 访问速度优化 2.Tcp fast open\n\n#### HTTPS:\n\n网站通常的做法是对 HTTP 的访问服务器端做 302 跳转，跳转到 HTTPS。但是这个 302 跳转存在两个问题 : 1. 使用不安全的 HTTP 协议进行通信。 2. 增加一个 Round-Trip Time。\n\n而 HSTS 是 HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建链接。其实 HSTS 的最大作用是防止 302HTTP 劫持（中间人）HSTS 的缺点是浏览器支持率不高，另外配置 HTST 后 HTTPS 很难实时降级为 HTTP。\n\n采用 HSTS 协议的网站将保证浏览器始终连接到该网站的 HTTPS 加密版本，不需要用户手动在 URL 地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。\n\n在https://xxx 的响应头中含有 Strict-Transport-Security:max-age=31536000;includeSubDomains 这就意味着两点：\n\n1. 在一年的时间里（31536000 秒）中，浏览器只要向 XXX 或者其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接。比如用户在地址栏输入http://xxx 或者点击超链接，浏览器应当自动将 http 转写成 https, 然后直接向https://xxx/ 发起请求。\n2. 在接下来的一年中，如果 xxx 服务器发送的 TLS 证书无效，用户不能忽略浏览器警告继续访问网站。\n\n##### 作用\n\nHTST 可以用来抵御 SSL 剥离攻击。攻击者在用户访问 HTTP 页面时替换所有 https 开头的连接为 http。达到阻止 HTTPS 的目的。但是如果使用了 HTST，一旦服务器发送了 HSTS 字段，用户将不再允许忽略警告。\n\n##### 不足\n\n用户首次访问网站是不受 HSTS 保护的。这是因为首次访问时，浏览器还未收到 HSTS，所以仍有可能明文 HTTP 访问。HTST 会在一段时间后失效（由 max-age 指定 )。所以浏览器是否强制 HSTS 取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。\n\n一旦浏览器接受到 HSTS Header( 假如有效期是 1 年），但是网站的证书出现问题，那么在有效都无法访问网站。\n\n#### Session resume 复用 session\n\n1. 减少 CPU 消耗，因为不需要非对称秘钥交换的计算。\n2. 提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。\n\n##### Session cache\n\nSession cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。\n\nSession cache 有两个缺点：\n\n1. 需要消耗服务端内存来存储 session 内容。\n\n2. 目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。\n\nSession cache 也有一个非常大的优点：\n\n1. session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。\n\n百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。\n\n#### 使用 SPDY 或者 HTTP2\n\nSPDY 是 google 推出的优化 HTTP 传输效率的协议（https://www.chromium.org/spdy） 它基本上沿用了 HTTP 协议的语义 , 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。\n\nHTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。\n\n需要说明两点 :\n\n1. SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。\n\n2. SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。\n\nGoogle 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。\n\n百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。\n","slug":"HTTPS","published":1,"date":"2018-03-20T03:29:41.814Z","updated":"2018-03-20T03:29:41.814Z","_id":"cjepksjl700008gv65nxb23d6","layout":"post","photos":[],"link":"","content":"<p>https 可以理解为 HTTP+TLS，TLS 是传输层加密协议，是 HTTPS 安全的核心，其前身是 SSL。TLS 主要有五部分 : 应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS 协议本身又是由 record 协议传输的。</p>\n<h3 id=\"为什么要实现-HTTPS？\"><a href=\"#为什么要实现-HTTPS？\" class=\"headerlink\" title=\"为什么要实现 HTTPS？\"></a>为什么要实现 HTTPS？</h3><p>为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。</p>\n<a id=\"more\"></a>\n<h3 id=\"全站-HTTPS-必须解决的问题\"><a href=\"#全站-HTTPS-必须解决的问题\" class=\"headerlink\" title=\"全站 HTTPS 必须解决的问题\"></a>全站 HTTPS 必须解决的问题</h3><hr>\n<p><strong>性能</strong></p>\n<ul>\n<li>HTTPS 需要多次握手，因此网络耗时变长，用户从 HTTP 跳转到 HTTPS 需要一些时间。但是如果使用 SPDY，HTTPS 的速度甚至比 HTTP 快。HTTPS 对速度的影响主要来自两方面 :<ol>\n<li>协议交换所增加的网络 RTT。</li>\n<li>加解密相关的计算耗时。</li>\n</ol>\n</li>\n<li>HTTPS 要做 RSA 校验，这会影响到设备性能。</li>\n<li>所有 CDN 节点要支持 HTTPS，而且需要有极其复杂的解决方案来面对 DDoS 的挑战。 <strong> 其次，兼容性及周边 :</strong></li>\n<li>页面中所有嵌入的资源（图片、附件、js 、视频等）都要改为 HTTPS 的，否者就会报警。</li>\n</ul>\n<h3 id=\"基于协议和配置的优化\"><a href=\"#基于协议和配置的优化\" class=\"headerlink\" title=\"基于协议和配置的优化\"></a>基于协议和配置的优化</h3><p>1.HTTPS 访问速度优化 2.Tcp fast open</p>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS:\"></a>HTTPS:</h4><p>网站通常的做法是对 HTTP 的访问服务器端做 302 跳转，跳转到 HTTPS。但是这个 302 跳转存在两个问题 : 1. 使用不安全的 HTTP 协议进行通信。 2. 增加一个 Round-Trip Time。</p>\n<p>而 HSTS 是 HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建链接。其实 HSTS 的最大作用是防止 302HTTP 劫持（中间人）HSTS 的缺点是浏览器支持率不高，另外配置 HTST 后 HTTPS 很难实时降级为 HTTP。</p>\n<p>采用 HSTS 协议的网站将保证浏览器始终连接到该网站的 HTTPS 加密版本，不需要用户手动在 URL 地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。</p>\n<p>在<a href=\"https://xxx\" target=\"_blank\" rel=\"noopener\">https://xxx</a> 的响应头中含有 Strict-Transport-Security:max-age=31536000;includeSubDomains 这就意味着两点：</p>\n<ol>\n<li>在一年的时间里（31536000 秒）中，浏览器只要向 XXX 或者其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接。比如用户在地址栏输入<a href=\"http://xxx\" target=\"_blank\" rel=\"noopener\">http://xxx</a> 或者点击超链接，浏览器应当自动将 http 转写成 https, 然后直接向<a href=\"https://xxx/\" target=\"_blank\" rel=\"noopener\">https://xxx/</a> 发起请求。</li>\n<li>在接下来的一年中，如果 xxx 服务器发送的 TLS 证书无效，用户不能忽略浏览器警告继续访问网站。</li>\n</ol>\n<h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><p>HTST 可以用来抵御 SSL 剥离攻击。攻击者在用户访问 HTTP 页面时替换所有 https 开头的连接为 http。达到阻止 HTTPS 的目的。但是如果使用了 HTST，一旦服务器发送了 HSTS 字段，用户将不再允许忽略警告。</p>\n<h5 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h5><p>用户首次访问网站是不受 HSTS 保护的。这是因为首次访问时，浏览器还未收到 HSTS，所以仍有可能明文 HTTP 访问。HTST 会在一段时间后失效（由 max-age 指定 )。所以浏览器是否强制 HSTS 取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。</p>\n<p>一旦浏览器接受到 HSTS Header( 假如有效期是 1 年），但是网站的证书出现问题，那么在有效都无法访问网站。</p>\n<h4 id=\"Session-resume-复用-session\"><a href=\"#Session-resume-复用-session\" class=\"headerlink\" title=\"Session resume 复用 session\"></a>Session resume 复用 session</h4><ol>\n<li>减少 CPU 消耗，因为不需要非对称秘钥交换的计算。</li>\n<li>提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。</li>\n</ol>\n<h5 id=\"Session-cache\"><a href=\"#Session-cache\" class=\"headerlink\" title=\"Session cache\"></a>Session cache</h5><p>Session cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。</p>\n<p>Session cache 有两个缺点：</p>\n<ol>\n<li><p>需要消耗服务端内存来存储 session 内容。</p>\n</li>\n<li><p>目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。</p>\n</li>\n</ol>\n<p>Session cache 也有一个非常大的优点：</p>\n<ol>\n<li>session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。</li>\n</ol>\n<p>百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。</p>\n<h4 id=\"使用-SPDY-或者-HTTP2\"><a href=\"#使用-SPDY-或者-HTTP2\" class=\"headerlink\" title=\"使用 SPDY 或者 HTTP2\"></a>使用 SPDY 或者 HTTP2</h4><p>SPDY 是 google 推出的优化 HTTP 传输效率的协议（<a href=\"https://www.chromium.org/spdy）\" target=\"_blank\" rel=\"noopener\">https://www.chromium.org/spdy）</a> 它基本上沿用了 HTTP 协议的语义 , 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。</p>\n<p>HTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。</p>\n<p>需要说明两点 :</p>\n<ol>\n<li><p>SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。</p>\n</li>\n<li><p>SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。</p>\n</li>\n</ol>\n<p>Google 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。</p>\n<p>百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。</p>\n","site":{"data":{}},"excerpt":"<p>https 可以理解为 HTTP+TLS，TLS 是传输层加密协议，是 HTTPS 安全的核心，其前身是 SSL。TLS 主要有五部分 : 应用数据层协议，握手协议，报警协议，加密消息确认协议，心跳协议。TLS 协议本身又是由 record 协议传输的。</p>\n<h3 id=\"为什么要实现-HTTPS？\"><a href=\"#为什么要实现-HTTPS？\" class=\"headerlink\" title=\"为什么要实现 HTTPS？\"></a>为什么要实现 HTTPS？</h3><p>为保护用户隐私和网络安全。通过数据加密、校验数据完整性和身份认证三种机制来保障安全。</p>","more":"<h3 id=\"全站-HTTPS-必须解决的问题\"><a href=\"#全站-HTTPS-必须解决的问题\" class=\"headerlink\" title=\"全站 HTTPS 必须解决的问题\"></a>全站 HTTPS 必须解决的问题</h3><hr>\n<p><strong>性能</strong></p>\n<ul>\n<li>HTTPS 需要多次握手，因此网络耗时变长，用户从 HTTP 跳转到 HTTPS 需要一些时间。但是如果使用 SPDY，HTTPS 的速度甚至比 HTTP 快。HTTPS 对速度的影响主要来自两方面 :<ol>\n<li>协议交换所增加的网络 RTT。</li>\n<li>加解密相关的计算耗时。</li>\n</ol>\n</li>\n<li>HTTPS 要做 RSA 校验，这会影响到设备性能。</li>\n<li>所有 CDN 节点要支持 HTTPS，而且需要有极其复杂的解决方案来面对 DDoS 的挑战。 <strong> 其次，兼容性及周边 :</strong></li>\n<li>页面中所有嵌入的资源（图片、附件、js 、视频等）都要改为 HTTPS 的，否者就会报警。</li>\n</ul>\n<h3 id=\"基于协议和配置的优化\"><a href=\"#基于协议和配置的优化\" class=\"headerlink\" title=\"基于协议和配置的优化\"></a>基于协议和配置的优化</h3><p>1.HTTPS 访问速度优化 2.Tcp fast open</p>\n<h4 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS:\"></a>HTTPS:</h4><p>网站通常的做法是对 HTTP 的访问服务器端做 302 跳转，跳转到 HTTPS。但是这个 302 跳转存在两个问题 : 1. 使用不安全的 HTTP 协议进行通信。 2. 增加一个 Round-Trip Time。</p>\n<p>而 HSTS 是 HTTP Strict Transport Security 的缩写，作用是强制客户端（如浏览器）使用 HTTPS 与服务器创建链接。其实 HSTS 的最大作用是防止 302HTTP 劫持（中间人）HSTS 的缺点是浏览器支持率不高，另外配置 HTST 后 HTTPS 很难实时降级为 HTTP。</p>\n<p>采用 HSTS 协议的网站将保证浏览器始终连接到该网站的 HTTPS 加密版本，不需要用户手动在 URL 地址栏中输入加密地址。该协议将帮助网站采用全局加密，用户看到的是该网站的安全版本。</p>\n<p>在<a href=\"https://xxx\" target=\"_blank\" rel=\"noopener\">https://xxx</a> 的响应头中含有 Strict-Transport-Security:max-age=31536000;includeSubDomains 这就意味着两点：</p>\n<ol>\n<li>在一年的时间里（31536000 秒）中，浏览器只要向 XXX 或者其子域名发送 HTTP 请求时，必须采用 HTTPS 来发起连接。比如用户在地址栏输入<a href=\"http://xxx\" target=\"_blank\" rel=\"noopener\">http://xxx</a> 或者点击超链接，浏览器应当自动将 http 转写成 https, 然后直接向<a href=\"https://xxx/\" target=\"_blank\" rel=\"noopener\">https://xxx/</a> 发起请求。</li>\n<li>在接下来的一年中，如果 xxx 服务器发送的 TLS 证书无效，用户不能忽略浏览器警告继续访问网站。</li>\n</ol>\n<h5 id=\"作用\"><a href=\"#作用\" class=\"headerlink\" title=\"作用\"></a>作用</h5><p>HTST 可以用来抵御 SSL 剥离攻击。攻击者在用户访问 HTTP 页面时替换所有 https 开头的连接为 http。达到阻止 HTTPS 的目的。但是如果使用了 HTST，一旦服务器发送了 HSTS 字段，用户将不再允许忽略警告。</p>\n<h5 id=\"不足\"><a href=\"#不足\" class=\"headerlink\" title=\"不足\"></a>不足</h5><p>用户首次访问网站是不受 HSTS 保护的。这是因为首次访问时，浏览器还未收到 HSTS，所以仍有可能明文 HTTP 访问。HTST 会在一段时间后失效（由 max-age 指定 )。所以浏览器是否强制 HSTS 取决于当前系统时间。部分操作系统经常通过网络时间协议更新系统时间。</p>\n<p>一旦浏览器接受到 HSTS Header( 假如有效期是 1 年），但是网站的证书出现问题，那么在有效都无法访问网站。</p>\n<h4 id=\"Session-resume-复用-session\"><a href=\"#Session-resume-复用-session\" class=\"headerlink\" title=\"Session resume 复用 session\"></a>Session resume 复用 session</h4><ol>\n<li>减少 CPU 消耗，因为不需要非对称秘钥交换的计算。</li>\n<li>提升访问速度，不需要进行完全握手阶段二，节省了一个 RTT 和计算耗时。</li>\n</ol>\n<h5 id=\"Session-cache\"><a href=\"#Session-cache\" class=\"headerlink\" title=\"Session cache\"></a>Session cache</h5><p>Session cache 的原理是使用 client hello 中的 session id 查询服务端的 session cache, 如果服务端有对应的缓存，则直接使用已有的 session 信息提前完成握手，称为简化握手。</p>\n<p>Session cache 有两个缺点：</p>\n<ol>\n<li><p>需要消耗服务端内存来存储 session 内容。</p>\n</li>\n<li><p>目前的开源软件包括 nginx,apache 只支持单机多进程间共享缓存，不支持多机间分布式缓存，对于百度或者其他大型互联网公司而言，单机 session cache 几乎没有作用。</p>\n</li>\n</ol>\n<p>Session cache 也有一个非常大的优点：</p>\n<ol>\n<li>session id 是 TLS 协议的标准字段，市面上的浏览器全部都支持 session cache。</li>\n</ol>\n<p>百度通过对 TLS 握手协议及服务器端实现的优化，已经支持全局的 session cache，能够明显提升用户的访问速度，节省服务器计算资源。</p>\n<h4 id=\"使用-SPDY-或者-HTTP2\"><a href=\"#使用-SPDY-或者-HTTP2\" class=\"headerlink\" title=\"使用 SPDY 或者 HTTP2\"></a>使用 SPDY 或者 HTTP2</h4><p>SPDY 是 google 推出的优化 HTTP 传输效率的协议（<a href=\"https://www.chromium.org/spdy）\" target=\"_blank\" rel=\"noopener\">https://www.chromium.org/spdy）</a> 它基本上沿用了 HTTP 协议的语义 , 但是通过使用帧控制实现了多个特性，显著提升了 HTTP 协议的传输效率。SPDY 最大的特性就是多路复用，能将多个 HTTP 请求在同一个连接上一起发出去，不像目前的 HTTP 协议一样，只能串行地逐个发送请求。Pipeline 虽然支持多个请求一起发送，但是接收时依然得按照顺序接收，本质上无法解决并发的问题。</p>\n<p>HTTP2 是 IETF 2015 年 2 月份通过的 HTTP 下一代协议，它以 SPDY 为原型，经过两年多的讨论和完善最终确定。</p>\n<p>需要说明两点 :</p>\n<ol>\n<li><p>SPDY 和 HTTP2 目前的实现默认使用 HTTPS 协议。</p>\n</li>\n<li><p>SPDY 和 HTTP2 都支持现有的 HTTP 语义和 API，对 WEB 应用几乎是透明的。</p>\n</li>\n</ol>\n<p>Google 宣布 chrome 浏览器 2016 年将放弃 SPDY 协议，全面支持 HTTP2，但是目前国内部分浏览器厂商进度非常慢，不仅不支持 HTTP2，连 SPDY 都没有支持过。</p>\n<p>百度服务端和百度手机浏览器现在都已经支持 SPDY3.1 协议。</p>"},{"title":"JS代码片段","date":"2018-01-15T08:27:23.000Z","_content":"\n搬砖时的 JS 代码片段整理\n\n<!--more-->\n\n## 将 bytes 格式化\n\n```javascript\nlet total = this.fileSizeFormat(spaceSize, 2, true, false)\n\n fileSizeFormat(bytes, digits, unitFlag, floorFlag) {\n      bytes = parseFloat(bytes)\n      let absBytes = Math.abs(bytes)\n      let humanSize, unit\n\n      if (digits === undefined) {\n        digits = 2\n      }\n      if (unitFlag === undefined) {\n        unitFlag = true\n      }\n\n      if (absBytes < 1024) {\n        digits = 0\n        humanSize = bytes\n        unit = 'B'\n      } else {\n        if (absBytes < 900 * 1024) {\n          humanSize = bytes / 1024\n          unit = 'K'\n        } else {\n          if (absBytes < 900 * 1048576) {\n            humanSize = bytes / 1048576\n            unit = 'M'\n          } else {\n            if (absBytes < 900 * 1073741824 || (digits === 0 && absBytes < 1048576 * 1048576)) {\n              humanSize = bytes / 1073741824\n              unit = 'G'\n            } else {\n              humanSize = bytes / (1048576 * 1048576)\n              unit = 'T'\n            }\n          }\n        }\n        humanSize = Math.round(humanSize * Math.pow(10, digits)) / parseFloat(Math.pow(10, digits))\n        humanSize = humanSize.toFixed(digits)\n\n        let result\n        if (floorFlag && digits > 0) {\n          if (humanSize !== Math.floor(humanSize)) {\n            result = humanSize\n          } else {\n            result = parseInt(Math.floor(humanSize), 10)\n          }\n        } else {\n          result = humanSize\n        }\n        if (unitFlag) {\n          result = result + unit\n        }\n\n        return result\n      }\n    }\n```\n\n## 获取文件扩展名\n\n```javascript\nconst extname = filename => {\n  if (filename.indexOf('.') > 0) {\n    var resultArr = filename.split('.')\n    var result = '.' + resultArr[resultArr.length - 1]\n    return result\n  } else return ''\n}\n```\n\n## 冒泡排序\n\n```javascript\nfunction bubbleSort(arr) {\n  var i = arr.length,\n    j\n  var tempExchangVal\n  while (i > 0) {\n    for (j = 0; j < i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        tempExchangVal = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = tempExchangVal\n      }\n    }\n    i--\n  }\n  return arr\n}\n\nvar arr = [3, 2, 4, 9, 1, 5, 7, 6, 8]\nvar arrSorted = bubbleSort(arr)\nconsole.log(arrSorted)\nalert(arrSorted)\n```\n\n## 快速排序算法\n\n快速排序是处理大数据急最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。\n\n![img caption](/images/common/kuaipai.png)\n\n```javascript\nfunction quickSort(array) {\n  if (array.length == 0) {\n    return []\n  }\n  var left = []\n  var right = []\n  var priot = array[0]\n\n  for (var i = 1; i < array.length; i++) {\n    if (array[i] < privot) {\n      left.push(array[i])\n    } else {\n      right.push(array[i])\n    }\n  }\n  return quickSort(left).concat(privot, quickSort(right))\n}\n```\n\n## JS 深度克隆\n\n```javascript\nfunction deepClone(obj) {\n  var _toString = Object.prototype.toString\n\n  // null, undefined, non-object, function\n  if (!obj || typeof obj !== 'object') {\n    return obj\n  }\n\n  // DOM Node\n  if (obj.nodeType && 'cloneNode' in obj) {\n    return obj.cloneNode(true)\n  }\n\n  // Date\n  if (_toString.call(obj) === '[object Date]') {\n    return new Date(obj.getTime())\n  }\n\n  // RegExp\n  if (_toString.call(obj) === '[object RegExp]') {\n    var flags = []\n    if (obj.global) {\n      flags.push('g')\n    }\n    if (obj.multiline) {\n      flags.push('m')\n    }\n    if (obj.ignoreCase) {\n      flags.push('i')\n    }\n\n    return new RegExp(obj.source, flags.join(''))\n  }\n\n  var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : {}\n\n  for (var key in obj) {\n    result[key] = deepClone(obj[key])\n  }\n\n  return result\n}\n\nfunction A() {\n  this.a = a\n}\n\nvar a = {\n  name: 'qiu',\n  birth: new Date(),\n  pattern: /qiu/gim,\n  container: document.body,\n  hobbys: ['book', new Date(), /aaa/gim, 111]\n}\n\nvar c = new A()\nvar b = deepClone(c)\nconsole.log(c.a === b.a)\nconsole.log(c, b)\n```\n","source":"_posts/JS代码片段.md","raw":"---\ntitle: JS代码片段\ndate: 2018-01-15 16:27:23\ntags:\n---\n\n搬砖时的 JS 代码片段整理\n\n<!--more-->\n\n## 将 bytes 格式化\n\n```javascript\nlet total = this.fileSizeFormat(spaceSize, 2, true, false)\n\n fileSizeFormat(bytes, digits, unitFlag, floorFlag) {\n      bytes = parseFloat(bytes)\n      let absBytes = Math.abs(bytes)\n      let humanSize, unit\n\n      if (digits === undefined) {\n        digits = 2\n      }\n      if (unitFlag === undefined) {\n        unitFlag = true\n      }\n\n      if (absBytes < 1024) {\n        digits = 0\n        humanSize = bytes\n        unit = 'B'\n      } else {\n        if (absBytes < 900 * 1024) {\n          humanSize = bytes / 1024\n          unit = 'K'\n        } else {\n          if (absBytes < 900 * 1048576) {\n            humanSize = bytes / 1048576\n            unit = 'M'\n          } else {\n            if (absBytes < 900 * 1073741824 || (digits === 0 && absBytes < 1048576 * 1048576)) {\n              humanSize = bytes / 1073741824\n              unit = 'G'\n            } else {\n              humanSize = bytes / (1048576 * 1048576)\n              unit = 'T'\n            }\n          }\n        }\n        humanSize = Math.round(humanSize * Math.pow(10, digits)) / parseFloat(Math.pow(10, digits))\n        humanSize = humanSize.toFixed(digits)\n\n        let result\n        if (floorFlag && digits > 0) {\n          if (humanSize !== Math.floor(humanSize)) {\n            result = humanSize\n          } else {\n            result = parseInt(Math.floor(humanSize), 10)\n          }\n        } else {\n          result = humanSize\n        }\n        if (unitFlag) {\n          result = result + unit\n        }\n\n        return result\n      }\n    }\n```\n\n## 获取文件扩展名\n\n```javascript\nconst extname = filename => {\n  if (filename.indexOf('.') > 0) {\n    var resultArr = filename.split('.')\n    var result = '.' + resultArr[resultArr.length - 1]\n    return result\n  } else return ''\n}\n```\n\n## 冒泡排序\n\n```javascript\nfunction bubbleSort(arr) {\n  var i = arr.length,\n    j\n  var tempExchangVal\n  while (i > 0) {\n    for (j = 0; j < i - 1; j++) {\n      if (arr[j] > arr[j + 1]) {\n        tempExchangVal = arr[j]\n        arr[j] = arr[j + 1]\n        arr[j + 1] = tempExchangVal\n      }\n    }\n    i--\n  }\n  return arr\n}\n\nvar arr = [3, 2, 4, 9, 1, 5, 7, 6, 8]\nvar arrSorted = bubbleSort(arr)\nconsole.log(arrSorted)\nalert(arrSorted)\n```\n\n## 快速排序算法\n\n快速排序是处理大数据急最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。\n\n![img caption](/images/common/kuaipai.png)\n\n```javascript\nfunction quickSort(array) {\n  if (array.length == 0) {\n    return []\n  }\n  var left = []\n  var right = []\n  var priot = array[0]\n\n  for (var i = 1; i < array.length; i++) {\n    if (array[i] < privot) {\n      left.push(array[i])\n    } else {\n      right.push(array[i])\n    }\n  }\n  return quickSort(left).concat(privot, quickSort(right))\n}\n```\n\n## JS 深度克隆\n\n```javascript\nfunction deepClone(obj) {\n  var _toString = Object.prototype.toString\n\n  // null, undefined, non-object, function\n  if (!obj || typeof obj !== 'object') {\n    return obj\n  }\n\n  // DOM Node\n  if (obj.nodeType && 'cloneNode' in obj) {\n    return obj.cloneNode(true)\n  }\n\n  // Date\n  if (_toString.call(obj) === '[object Date]') {\n    return new Date(obj.getTime())\n  }\n\n  // RegExp\n  if (_toString.call(obj) === '[object RegExp]') {\n    var flags = []\n    if (obj.global) {\n      flags.push('g')\n    }\n    if (obj.multiline) {\n      flags.push('m')\n    }\n    if (obj.ignoreCase) {\n      flags.push('i')\n    }\n\n    return new RegExp(obj.source, flags.join(''))\n  }\n\n  var result = Array.isArray(obj) ? [] : obj.constructor ? new obj.constructor() : {}\n\n  for (var key in obj) {\n    result[key] = deepClone(obj[key])\n  }\n\n  return result\n}\n\nfunction A() {\n  this.a = a\n}\n\nvar a = {\n  name: 'qiu',\n  birth: new Date(),\n  pattern: /qiu/gim,\n  container: document.body,\n  hobbys: ['book', new Date(), /aaa/gim, 111]\n}\n\nvar c = new A()\nvar b = deepClone(c)\nconsole.log(c.a === b.a)\nconsole.log(c, b)\n```\n","slug":"JS代码片段","published":1,"updated":"2018-03-13T06:13:05.941Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjlf00018gv6rf3u7k47","content":"<p>搬砖时的 JS 代码片段整理</p>\n<a id=\"more\"></a>\n<h2 id=\"将-bytes-格式化\"><a href=\"#将-bytes-格式化\" class=\"headerlink\" title=\"将 bytes 格式化\"></a>将 bytes 格式化</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"keyword\">this</span>.fileSizeFormat(spaceSize, <span class=\"number\">2</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> fileSizeFormat(bytes, digits, unitFlag, floorFlag) &#123;</span><br><span class=\"line\">      bytes = <span class=\"built_in\">parseFloat</span>(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> absBytes = <span class=\"built_in\">Math</span>.abs(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> humanSize, unit</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (digits === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        digits = <span class=\"number\">2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unitFlag === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        unitFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">        digits = <span class=\"number\">0</span></span><br><span class=\"line\">        humanSize = bytes</span><br><span class=\"line\">        unit = <span class=\"string\">'B'</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">          humanSize = bytes / <span class=\"number\">1024</span></span><br><span class=\"line\">          unit = <span class=\"string\">'K'</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1048576</span>) &#123;</span><br><span class=\"line\">            humanSize = bytes / <span class=\"number\">1048576</span></span><br><span class=\"line\">            unit = <span class=\"string\">'M'</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1073741824</span> || (digits === <span class=\"number\">0</span> &amp;&amp; absBytes &lt; <span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)) &#123;</span><br><span class=\"line\">              humanSize = bytes / <span class=\"number\">1073741824</span></span><br><span class=\"line\">              unit = <span class=\"string\">'G'</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              humanSize = bytes / (<span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)</span><br><span class=\"line\">              unit = <span class=\"string\">'T'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        humanSize = <span class=\"built_in\">Math</span>.round(humanSize * <span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, digits)) / <span class=\"built_in\">parseFloat</span>(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, digits))</span><br><span class=\"line\">        humanSize = humanSize.toFixed(digits)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (floorFlag &amp;&amp; digits &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (humanSize !== <span class=\"built_in\">Math</span>.floor(humanSize)) &#123;</span><br><span class=\"line\">            result = humanSize</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.floor(humanSize), <span class=\"number\">10</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          result = humanSize</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unitFlag) &#123;</span><br><span class=\"line\">          result = result + unit</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取文件扩展名\"><a href=\"#获取文件扩展名\" class=\"headerlink\" title=\"获取文件扩展名\"></a>获取文件扩展名</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> extname = <span class=\"function\"><span class=\"params\">filename</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (filename.indexOf(<span class=\"string\">'.'</span>) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> resultArr = filename.split(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">'.'</span> + resultArr[resultArr.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = arr.length,</span><br><span class=\"line\">    j</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tempExchangVal</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        tempExchangVal = arr[j]</span><br><span class=\"line\">        arr[j] = arr[j + <span class=\"number\">1</span>]</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = tempExchangVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrSorted = bubbleSort(arr)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrSorted)</span><br><span class=\"line\">alert(arrSorted)</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序算法\"><a href=\"#快速排序算法\" class=\"headerlink\" title=\"快速排序算法\"></a>快速排序算法</h2><p>快速排序是处理大数据急最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。</p>\n<p><img src=\"/images/common/kuaipai.png\" alt=\"img caption\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> priot = array[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; privot) &#123;</span><br><span class=\"line\">      left.push(array[i])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(array[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(privot, quickSort(right))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-深度克隆\"><a href=\"#JS-深度克隆\" class=\"headerlink\" title=\"JS 深度克隆\"></a>JS 深度克隆</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _toString = <span class=\"built_in\">Object</span>.prototype.toString</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// null, undefined, non-object, function</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// DOM Node</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.nodeType &amp;&amp; <span class=\"string\">'cloneNode'</span> <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj.cloneNode(<span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Date</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_toString.call(obj) === <span class=\"string\">'[object Date]'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(obj.getTime())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// RegExp</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_toString.call(obj) === <span class=\"string\">'[object RegExp]'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flags = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.global) &#123;</span><br><span class=\"line\">      flags.push(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.multiline) &#123;</span><br><span class=\"line\">      flags.push(<span class=\"string\">'m'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.ignoreCase) &#123;</span><br><span class=\"line\">      flags.push(<span class=\"string\">'i'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(obj.source, flags.join(<span class=\"string\">''</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : obj.constructor ? <span class=\"keyword\">new</span> obj.constructor() : &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    result[key] = deepClone(obj[key])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'qiu'</span>,</span><br><span class=\"line\">  birth: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">  pattern: <span class=\"regexp\">/qiu/gim</span>,</span><br><span class=\"line\">  container: <span class=\"built_in\">document</span>.body,</span><br><span class=\"line\">  hobbys: [<span class=\"string\">'book'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), /aaa/gim, <span class=\"number\">111</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = deepClone(c)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c.a === b.a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c, b)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>搬砖时的 JS 代码片段整理</p>","more":"<h2 id=\"将-bytes-格式化\"><a href=\"#将-bytes-格式化\" class=\"headerlink\" title=\"将 bytes 格式化\"></a>将 bytes 格式化</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> total = <span class=\"keyword\">this</span>.fileSizeFormat(spaceSize, <span class=\"number\">2</span>, <span class=\"literal\">true</span>, <span class=\"literal\">false</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"> fileSizeFormat(bytes, digits, unitFlag, floorFlag) &#123;</span><br><span class=\"line\">      bytes = <span class=\"built_in\">parseFloat</span>(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> absBytes = <span class=\"built_in\">Math</span>.abs(bytes)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> humanSize, unit</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (digits === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        digits = <span class=\"number\">2</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (unitFlag === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">        unitFlag = <span class=\"literal\">true</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">        digits = <span class=\"number\">0</span></span><br><span class=\"line\">        humanSize = bytes</span><br><span class=\"line\">        unit = <span class=\"string\">'B'</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1024</span>) &#123;</span><br><span class=\"line\">          humanSize = bytes / <span class=\"number\">1024</span></span><br><span class=\"line\">          unit = <span class=\"string\">'K'</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1048576</span>) &#123;</span><br><span class=\"line\">            humanSize = bytes / <span class=\"number\">1048576</span></span><br><span class=\"line\">            unit = <span class=\"string\">'M'</span></span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (absBytes &lt; <span class=\"number\">900</span> * <span class=\"number\">1073741824</span> || (digits === <span class=\"number\">0</span> &amp;&amp; absBytes &lt; <span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)) &#123;</span><br><span class=\"line\">              humanSize = bytes / <span class=\"number\">1073741824</span></span><br><span class=\"line\">              unit = <span class=\"string\">'G'</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">              humanSize = bytes / (<span class=\"number\">1048576</span> * <span class=\"number\">1048576</span>)</span><br><span class=\"line\">              unit = <span class=\"string\">'T'</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        humanSize = <span class=\"built_in\">Math</span>.round(humanSize * <span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, digits)) / <span class=\"built_in\">parseFloat</span>(<span class=\"built_in\">Math</span>.pow(<span class=\"number\">10</span>, digits))</span><br><span class=\"line\">        humanSize = humanSize.toFixed(digits)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">let</span> result</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (floorFlag &amp;&amp; digits &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (humanSize !== <span class=\"built_in\">Math</span>.floor(humanSize)) &#123;</span><br><span class=\"line\">            result = humanSize</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = <span class=\"built_in\">parseInt</span>(<span class=\"built_in\">Math</span>.floor(humanSize), <span class=\"number\">10</span>)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">          result = humanSize</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (unitFlag) &#123;</span><br><span class=\"line\">          result = result + unit</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"获取文件扩展名\"><a href=\"#获取文件扩展名\" class=\"headerlink\" title=\"获取文件扩展名\"></a>获取文件扩展名</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> extname = <span class=\"function\"><span class=\"params\">filename</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (filename.indexOf(<span class=\"string\">'.'</span>) &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> resultArr = filename.split(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = <span class=\"string\">'.'</span> + resultArr[resultArr.length - <span class=\"number\">1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"string\">''</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bubbleSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> i = arr.length,</span><br><span class=\"line\">    j</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tempExchangVal</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (i &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; i - <span class=\"number\">1</span>; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[j] &gt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">        tempExchangVal = arr[j]</span><br><span class=\"line\">        arr[j] = arr[j + <span class=\"number\">1</span>]</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = tempExchangVal</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    i--</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrSorted = bubbleSort(arr)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrSorted)</span><br><span class=\"line\">alert(arrSorted)</span><br></pre></td></tr></table></figure>\n<h2 id=\"快速排序算法\"><a href=\"#快速排序算法\" class=\"headerlink\" title=\"快速排序算法\"></a>快速排序算法</h2><p>快速排序是处理大数据急最快的排序算法之一。它是一种分而治之的算法，通过递归的方式将数据一次分解为包含较小元素和较大元素的不同子序列。</p>\n<p><img src=\"/images/common/kuaipai.png\" alt=\"img caption\"></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (array.length == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> []</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> right = []</span><br><span class=\"line\">  <span class=\"keyword\">var</span> priot = array[<span class=\"number\">0</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">1</span>; i &lt; array.length; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (array[i] &lt; privot) &#123;</span><br><span class=\"line\">      left.push(array[i])</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(array[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(privot, quickSort(right))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-深度克隆\"><a href=\"#JS-深度克隆\" class=\"headerlink\" title=\"JS 深度克隆\"></a>JS 深度克隆</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _toString = <span class=\"built_in\">Object</span>.prototype.toString</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// null, undefined, non-object, function</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!obj || <span class=\"keyword\">typeof</span> obj !== <span class=\"string\">'object'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// DOM Node</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.nodeType &amp;&amp; <span class=\"string\">'cloneNode'</span> <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj.cloneNode(<span class=\"literal\">true</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Date</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_toString.call(obj) === <span class=\"string\">'[object Date]'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(obj.getTime())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// RegExp</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_toString.call(obj) === <span class=\"string\">'[object RegExp]'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> flags = []</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.global) &#123;</span><br><span class=\"line\">      flags.push(<span class=\"string\">'g'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.multiline) &#123;</span><br><span class=\"line\">      flags.push(<span class=\"string\">'m'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (obj.ignoreCase) &#123;</span><br><span class=\"line\">      flags.push(<span class=\"string\">'i'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(obj.source, flags.join(<span class=\"string\">''</span>))</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> result = <span class=\"built_in\">Array</span>.isArray(obj) ? [] : obj.constructor ? <span class=\"keyword\">new</span> obj.constructor() : &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> key <span class=\"keyword\">in</span> obj) &#123;</span><br><span class=\"line\">    result[key] = deepClone(obj[key])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">A</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.a = a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'qiu'</span>,</span><br><span class=\"line\">  birth: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">  pattern: <span class=\"regexp\">/qiu/gim</span>,</span><br><span class=\"line\">  container: <span class=\"built_in\">document</span>.body,</span><br><span class=\"line\">  hobbys: [<span class=\"string\">'book'</span>, <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(), /aaa/gim, <span class=\"number\">111</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> A()</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = deepClone(c)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c.a === b.a)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(c, b)</span><br></pre></td></tr></table></figure>"},{"title":"JS原生-ES6","date":"2018-01-24T02:51:11.000Z","_content":"\n发现自己对于 javascript 的底层 API 所知甚少，在这里记录一下所遇到的有趣又是在的 API。\n\n<!--more-->\n\n## set 对象 （可用于去重）\n\nset 独享允许你存储任何类型唯一值，无论是原始值或是对象。NaN 之间视为相同的值。\n\n```javascript\n引用 const set1 = new Set([1,1, 2, NaN, NaN, 5]);\n\nconsole.log(set1.has(1)); // expected output: true\n\nconsole.log(set1.has(5)); // expected output: true\n\nconsole.log(set1.has(6)); // expected output:false\n\nconsole.log(Array.from(set1)) // Array [1, 2, 3, 4, NaN, 5]\n```\n\n## Array.from()\n\n从一个类似数组或可迭代对象中创建一个新的数组实例。\n\n## super\n\nsuper 关键字用于访问和调用一个对象的父对象的函数。( 只能在 class 内部用 )\n\n在构造函数中使用时，super 关键字将单独出现，并且必须在使用 this 之前使用。\n\nsuper 关键字也可以用来调用父对象上的函数。\n\n```javascript\nsuper([arguments]);\n// 调用 父对象/父类 的构造函数\n\nsuper.functionOnParent([arguments]);\n// 调用 父对象/父类 上的方法\n```\n\n```javascript\nclass Polygon {\n  construector(height, width) {\n    this.name = 'Polygon'\n    this.height = height\n    this.width = width\n  }\n  sayName() {\n    console.log('Hi,I am a', this.name + '.')\n  }\n  class Square extends Polygon{\n    constructor(length){\n      this.height;\n      // ReferenceError ,super 需要先被调用！\n\n      /*\n       这里，它调用父类的构造函数的length,\n       作为Polygon 的 width 和 height\n       */\n       super(length,length)\n       /*\n       注意，在派生的类中，在你可以使用this之前，必须 先调用super()。忽略这，这将导致引用错误。\n       */\n       this.name = 'Square'\n    }\n    get area(){\n      return this.height * this.width\n    }\n    set area(value){\n      this.area = value\n    }\n  }\n}\n```\n\n**使用 super 调用父类的静态方法。**\n\n```javascript\nclass Human{}\n  constructor(){}\n    static ping(){\n      return 'ping'\n  }\n}\n\nclass computer eatends Human{\n  constructor(){}\n  static pingpong(){\n    return super.ping()+'pong'\n  }\n}\n\nComputer.pingpong()\n```\n\n**原始 class 实现方式**\n\n```javascript\nfunction Parent(name) {\n  this.name = name\n}\nParent.prototype.getName = function() {\n  return this.name\n}\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n//实现继承\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\nChild.prototype.getAge = function() {\n  return this.Age\n}\nvar people = new Child('lily', 20)\nconsole.log(people.getName())\n```\n\n**语法糖**\n\n```javascript\nclass Parent {\n  construtor(name) {\n    this.name = name\n  }\n  getAge() {\n    return this.age\n  }\n  const people = new Child(\"lily\",20);\n  console.log(people.getName())\n}\n```\n\n## 异步函数\n\n除了 javascript Promise , 异步函数进一步重写了传统的异步代码结构。\n\n### 一个以 async 为前缀的常规函数\n\n```javascript\nasync function fetchdata(url) {}\n```\n\n### 在异步函数（Async function ）内，使用 await 关键字调用异步操作函数\n\n```javascript\nfunction getaSync(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.open('GET', url)\n    xhr.onload = () => resolve(xhr.responseText)\n    xhr.onerror = () => reject(xhr.statusText)\n    xhr.send()\n  })\n}\n\nasync function fetchdata(){\n  var text1 = await getasync('test.txt')\n  console.logtex(text1)\n  var text2 = await getasync('test2.text')\n  console.log(text2)\n  var text3 = await getasync('text3.text)\n  console.log(text3)\n  return 'Finished'\n}\n\nfetchdata().then((msg)=>{\n  console.log(msg) //“test.txt”，“test2.txt”，“test3.txt”\n})\n```\n\n在异步函数中，我们把异步函数 getasync() 当做是同步函数，没有 then() 方法或回调函数通知下一步。无论何时遇到关键字 await , 执行都会停止，直到 getasync() 解决，然后再转到异步函数中的下一行。结果与纯粹的基于 Promise , 使用一串 then 方法的方式一样\n\n## 解构\n\nES6 解构并非一个新的功能，而是一个新的复制语法，可以快速解压缩对象属性和数组中的值，并将它们分配给各个变量。\n\n```javascript\nvar profile = { name: 'georage', age: 39, hobby: 'Tennis' }\nvar { name, hobby } = profile\nconsole.log(name) //'georage'\nconsole.log(hobby) //'Tennis'\n```\n\n这里我用解构快速提取 profile 对象的 name 和 hobby 属性。\n\n使用别名，你可以使用与你正在提取值的对象属性不同的变量名：\n\n```javascript\nvar profile = { name: 'georage', age: 39, hobby: 'Tennis' }\nvar { name: n, hobby: h } = profile\nconsole.log(n) //'georage'\nconsole.log(h) //'Tennis'\n```\n\n---\n\n### 嵌套对象解构\n\n解构也可以与嵌套对象一起工作，可以使用它来快速解开来自复杂的 JSON 请求的值。\n\n```javascript\nvar jsondata = {\n  title: 'XX',\n  details: {\n    data: {\n      created: '2017/09/19',\n      modified: '2017/09/20'\n    },\n    catrgory: 'js'\n  },\n  url: '/baidu/'\n};\nvar {title,details:{data:{created.modified}}} = jsondata\nconsole.log(title)\nconsole.log(created)\nconsole.log(modified)\n```\n\n---\n\n### 解构数组\n\n数组的解构与对象上的工作方式类似，除了左边的花括号使用**方括号**代替：\n\n```javascript\nvar soccerteam = ['George', 'Dennis', 'Sandy']\nvar [a, b] = soccerteam\nconsole.log(a) // \"George\"\nconsole.log(b) // \"Dennis\"\n```\n\n你可以跳过某些数组元素，通过使用 (,)\n\n```javascript\nvar var soccerteam = ['George', 'Dennis', 'Sandy']\nvar [a,,b] = soccerteam\nconsole.log(a) // \"George\"\nconsole.log(b) // \"Sandy\"\n```\n\n---\n\n## 默认和剩余参数\n\n### 默认参数\n\n在这之前我们都使用：\n\n```javascript\nfunction getarea(w, h) {\n  var w = w || 10\n  var h = h || 15\n  return w * h\n}\n```\n\n有了 ES6 对默认参数的支持后\n\n```javascript\nfunction getarea(w = 10, h = 15) {\n  return w * h\n}\ngetarea(5) //75\n```\n\n### 剩余参数 （Rest Parameters ）\n\nES6 中的 Rest Parameters 使得将函数参数转换成数组的操作变得简单。\n\n```javascript\nfunction addit(...theNumber) {\n  //get the sum of the array elements\n  return theNumber.reduce( (prevnum.curnum)=>prevnu+curnum,0)\n}\naddit(1,2,3,4)//10\n```\n\n通过在命名参数前添加 3 个点。在该位置和之后输入到函数中的参数将自动转换为数组。\n\n没有 Rest Parameters 则会手动将参数转换为数组 :\n\n```javascript\nfunction addit(theNumbers) {\n  // force arguments object into array\n  var numArray = Array.prototype.slice.call(arguments)\n  return numArray.reduce((prevnum, curnum) => prevnum + curnum, 0)\n}\n\naddit(1, 2, 3, 4) // returns 10\n```\n\n```javascript\nfunction f(...[a, b, c]) {\n  return a + b + c\n}\n\nf(1) // NaN (b and c are undefined)\nf(1, 2, 3) // 6\nf(1, 2, 3, 4) //6 (the fourth parameter is not destructured)\n```\n","source":"_posts/JS原生-ES6.md","raw":"---\ntitle: JS原生-ES6\ndate: 2018-01-24 10:51:11\ncategories: 原生JS\n---\n\n发现自己对于 javascript 的底层 API 所知甚少，在这里记录一下所遇到的有趣又是在的 API。\n\n<!--more-->\n\n## set 对象 （可用于去重）\n\nset 独享允许你存储任何类型唯一值，无论是原始值或是对象。NaN 之间视为相同的值。\n\n```javascript\n引用 const set1 = new Set([1,1, 2, NaN, NaN, 5]);\n\nconsole.log(set1.has(1)); // expected output: true\n\nconsole.log(set1.has(5)); // expected output: true\n\nconsole.log(set1.has(6)); // expected output:false\n\nconsole.log(Array.from(set1)) // Array [1, 2, 3, 4, NaN, 5]\n```\n\n## Array.from()\n\n从一个类似数组或可迭代对象中创建一个新的数组实例。\n\n## super\n\nsuper 关键字用于访问和调用一个对象的父对象的函数。( 只能在 class 内部用 )\n\n在构造函数中使用时，super 关键字将单独出现，并且必须在使用 this 之前使用。\n\nsuper 关键字也可以用来调用父对象上的函数。\n\n```javascript\nsuper([arguments]);\n// 调用 父对象/父类 的构造函数\n\nsuper.functionOnParent([arguments]);\n// 调用 父对象/父类 上的方法\n```\n\n```javascript\nclass Polygon {\n  construector(height, width) {\n    this.name = 'Polygon'\n    this.height = height\n    this.width = width\n  }\n  sayName() {\n    console.log('Hi,I am a', this.name + '.')\n  }\n  class Square extends Polygon{\n    constructor(length){\n      this.height;\n      // ReferenceError ,super 需要先被调用！\n\n      /*\n       这里，它调用父类的构造函数的length,\n       作为Polygon 的 width 和 height\n       */\n       super(length,length)\n       /*\n       注意，在派生的类中，在你可以使用this之前，必须 先调用super()。忽略这，这将导致引用错误。\n       */\n       this.name = 'Square'\n    }\n    get area(){\n      return this.height * this.width\n    }\n    set area(value){\n      this.area = value\n    }\n  }\n}\n```\n\n**使用 super 调用父类的静态方法。**\n\n```javascript\nclass Human{}\n  constructor(){}\n    static ping(){\n      return 'ping'\n  }\n}\n\nclass computer eatends Human{\n  constructor(){}\n  static pingpong(){\n    return super.ping()+'pong'\n  }\n}\n\nComputer.pingpong()\n```\n\n**原始 class 实现方式**\n\n```javascript\nfunction Parent(name) {\n  this.name = name\n}\nParent.prototype.getName = function() {\n  return this.name\n}\nfunction Child(name, age) {\n  Parent.call(this, name)\n  this.age = age\n}\n//实现继承\nChild.prototype = new Parent()\nChild.prototype.constructor = Child\n\nChild.prototype.getAge = function() {\n  return this.Age\n}\nvar people = new Child('lily', 20)\nconsole.log(people.getName())\n```\n\n**语法糖**\n\n```javascript\nclass Parent {\n  construtor(name) {\n    this.name = name\n  }\n  getAge() {\n    return this.age\n  }\n  const people = new Child(\"lily\",20);\n  console.log(people.getName())\n}\n```\n\n## 异步函数\n\n除了 javascript Promise , 异步函数进一步重写了传统的异步代码结构。\n\n### 一个以 async 为前缀的常规函数\n\n```javascript\nasync function fetchdata(url) {}\n```\n\n### 在异步函数（Async function ）内，使用 await 关键字调用异步操作函数\n\n```javascript\nfunction getaSync(url) {\n  return new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest()\n    xhr.open('GET', url)\n    xhr.onload = () => resolve(xhr.responseText)\n    xhr.onerror = () => reject(xhr.statusText)\n    xhr.send()\n  })\n}\n\nasync function fetchdata(){\n  var text1 = await getasync('test.txt')\n  console.logtex(text1)\n  var text2 = await getasync('test2.text')\n  console.log(text2)\n  var text3 = await getasync('text3.text)\n  console.log(text3)\n  return 'Finished'\n}\n\nfetchdata().then((msg)=>{\n  console.log(msg) //“test.txt”，“test2.txt”，“test3.txt”\n})\n```\n\n在异步函数中，我们把异步函数 getasync() 当做是同步函数，没有 then() 方法或回调函数通知下一步。无论何时遇到关键字 await , 执行都会停止，直到 getasync() 解决，然后再转到异步函数中的下一行。结果与纯粹的基于 Promise , 使用一串 then 方法的方式一样\n\n## 解构\n\nES6 解构并非一个新的功能，而是一个新的复制语法，可以快速解压缩对象属性和数组中的值，并将它们分配给各个变量。\n\n```javascript\nvar profile = { name: 'georage', age: 39, hobby: 'Tennis' }\nvar { name, hobby } = profile\nconsole.log(name) //'georage'\nconsole.log(hobby) //'Tennis'\n```\n\n这里我用解构快速提取 profile 对象的 name 和 hobby 属性。\n\n使用别名，你可以使用与你正在提取值的对象属性不同的变量名：\n\n```javascript\nvar profile = { name: 'georage', age: 39, hobby: 'Tennis' }\nvar { name: n, hobby: h } = profile\nconsole.log(n) //'georage'\nconsole.log(h) //'Tennis'\n```\n\n---\n\n### 嵌套对象解构\n\n解构也可以与嵌套对象一起工作，可以使用它来快速解开来自复杂的 JSON 请求的值。\n\n```javascript\nvar jsondata = {\n  title: 'XX',\n  details: {\n    data: {\n      created: '2017/09/19',\n      modified: '2017/09/20'\n    },\n    catrgory: 'js'\n  },\n  url: '/baidu/'\n};\nvar {title,details:{data:{created.modified}}} = jsondata\nconsole.log(title)\nconsole.log(created)\nconsole.log(modified)\n```\n\n---\n\n### 解构数组\n\n数组的解构与对象上的工作方式类似，除了左边的花括号使用**方括号**代替：\n\n```javascript\nvar soccerteam = ['George', 'Dennis', 'Sandy']\nvar [a, b] = soccerteam\nconsole.log(a) // \"George\"\nconsole.log(b) // \"Dennis\"\n```\n\n你可以跳过某些数组元素，通过使用 (,)\n\n```javascript\nvar var soccerteam = ['George', 'Dennis', 'Sandy']\nvar [a,,b] = soccerteam\nconsole.log(a) // \"George\"\nconsole.log(b) // \"Sandy\"\n```\n\n---\n\n## 默认和剩余参数\n\n### 默认参数\n\n在这之前我们都使用：\n\n```javascript\nfunction getarea(w, h) {\n  var w = w || 10\n  var h = h || 15\n  return w * h\n}\n```\n\n有了 ES6 对默认参数的支持后\n\n```javascript\nfunction getarea(w = 10, h = 15) {\n  return w * h\n}\ngetarea(5) //75\n```\n\n### 剩余参数 （Rest Parameters ）\n\nES6 中的 Rest Parameters 使得将函数参数转换成数组的操作变得简单。\n\n```javascript\nfunction addit(...theNumber) {\n  //get the sum of the array elements\n  return theNumber.reduce( (prevnum.curnum)=>prevnu+curnum,0)\n}\naddit(1,2,3,4)//10\n```\n\n通过在命名参数前添加 3 个点。在该位置和之后输入到函数中的参数将自动转换为数组。\n\n没有 Rest Parameters 则会手动将参数转换为数组 :\n\n```javascript\nfunction addit(theNumbers) {\n  // force arguments object into array\n  var numArray = Array.prototype.slice.call(arguments)\n  return numArray.reduce((prevnum, curnum) => prevnum + curnum, 0)\n}\n\naddit(1, 2, 3, 4) // returns 10\n```\n\n```javascript\nfunction f(...[a, b, c]) {\n  return a + b + c\n}\n\nf(1) // NaN (b and c are undefined)\nf(1, 2, 3) // 6\nf(1, 2, 3, 4) //6 (the fourth parameter is not destructured)\n```\n","slug":"JS原生-ES6","published":1,"updated":"2018-03-20T03:29:41.815Z","_id":"cjepksjlp00038gv6gjxaqzn6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>发现自己对于 javascript 的底层 API 所知甚少，在这里记录一下所遇到的有趣又是在的 API。</p>\n<a id=\"more\"></a>\n<h2 id=\"set-对象-（可用于去重）\"><a href=\"#set-对象-（可用于去重）\" class=\"headerlink\" title=\"set 对象 （可用于去重）\"></a>set 对象 （可用于去重）</h2><p>set 独享允许你存储任何类型唯一值，无论是原始值或是对象。NaN 之间视为相同的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引用 <span class=\"keyword\">const</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.has(<span class=\"number\">1</span>)); <span class=\"comment\">// expected output: true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.has(<span class=\"number\">5</span>)); <span class=\"comment\">// expected output: true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.has(<span class=\"number\">6</span>)); <span class=\"comment\">// expected output:false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(set1)) <span class=\"comment\">// Array [1, 2, 3, 4, NaN, 5]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>从一个类似数组或可迭代对象中创建一个新的数组实例。</p>\n<h2 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h2><p>super 关键字用于访问和调用一个对象的父对象的函数。( 只能在 class 内部用 )</p>\n<p>在构造函数中使用时，super 关键字将单独出现，并且必须在使用 this 之前使用。</p>\n<p>super 关键字也可以用来调用父对象上的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">super</span>([<span class=\"built_in\">arguments</span>]);</span><br><span class=\"line\"><span class=\"comment\">// 调用 父对象/父类 的构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">super</span>.functionOnParent([<span class=\"built_in\">arguments</span>]);</span><br><span class=\"line\"><span class=\"comment\">// 调用 父对象/父类 上的方法</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span> </span>&#123;</span><br><span class=\"line\">  construector(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Polygon'</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayName() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi,I am a'</span>, <span class=\"keyword\">this</span>.name + <span class=\"string\">'.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polygon</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(length)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.height;</span><br><span class=\"line\">      <span class=\"comment\">// ReferenceError ,super 需要先被调用！</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       这里，它调用父类的构造函数的length,</span></span><br><span class=\"line\"><span class=\"comment\">       作为Polygon 的 width 和 height</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">       <span class=\"keyword\">super</span>(length,length)</span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       注意，在派生的类中，在你可以使用this之前，必须 先调用super()。忽略这，这将导致引用错误。</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = <span class=\"string\">'Square'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get area()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set area(value)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.area = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用 super 调用父类的静态方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span></span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ping()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'ping'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">computer</span> <span class=\"title\">eatends</span> <span class=\"title\">Human</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> pingpong()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.ping()+<span class=\"string\">'pong'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Computer.pingpong()</span><br></pre></td></tr></table></figure>\n<p><strong>原始 class 实现方式</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.Age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> people = <span class=\"keyword\">new</span> Child(<span class=\"string\">'lily'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(people.getName())</span><br></pre></td></tr></table></figure>\n<p><strong>语法糖</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  construtor(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getAge() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> people = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"lily\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(people.getName())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><p>除了 javascript Promise , 异步函数进一步重写了传统的异步代码结构。</p>\n<h3 id=\"一个以-async-为前缀的常规函数\"><a href=\"#一个以-async-为前缀的常规函数\" class=\"headerlink\" title=\"一个以 async 为前缀的常规函数\"></a>一个以 async 为前缀的常规函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchdata</span>(<span class=\"params\">url</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在异步函数（Async-function-）内，使用-await-关键字调用异步操作函数\"><a href=\"#在异步函数（Async-function-）内，使用-await-关键字调用异步操作函数\" class=\"headerlink\" title=\"在异步函数（Async function ）内，使用 await 关键字调用异步操作函数\"></a>在异步函数（Async function ）内，使用 await 关键字调用异步操作函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getaSync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">    xhr.open(<span class=\"string\">'GET'</span>, url)</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(xhr.responseText)</span><br><span class=\"line\">    xhr.onerror = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(xhr.statusText)</span><br><span class=\"line\">    xhr.send()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchdata</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> text1 = <span class=\"keyword\">await</span> getasync(<span class=\"string\">'test.txt'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.logtex(text1)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> text2 = <span class=\"keyword\">await</span> getasync(<span class=\"string\">'test2.text'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(text2)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> text3 = <span class=\"keyword\">await</span> getasync(<span class=\"string\">'text3.text)</span></span><br><span class=\"line\"><span class=\"string\">  console.log(text3)</span></span><br><span class=\"line\"><span class=\"string\">  return '</span>Finished<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">fetchdata().then((msg)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  console.log(msg) //“test.txt”，“test2.txt”，“test3.txt”</span></span><br><span class=\"line\"><span class=\"string\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>在异步函数中，我们把异步函数 getasync() 当做是同步函数，没有 then() 方法或回调函数通知下一步。无论何时遇到关键字 await , 执行都会停止，直到 getasync() 解决，然后再转到异步函数中的下一行。结果与纯粹的基于 Promise , 使用一串 then 方法的方式一样</p>\n<h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><p>ES6 解构并非一个新的功能，而是一个新的复制语法，可以快速解压缩对象属性和数组中的值，并将它们分配给各个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> profile = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'georage'</span>, <span class=\"attr\">age</span>: <span class=\"number\">39</span>, <span class=\"attr\">hobby</span>: <span class=\"string\">'Tennis'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; name, hobby &#125; = profile</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//'georage'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hobby) <span class=\"comment\">//'Tennis'</span></span><br></pre></td></tr></table></figure>\n<p>这里我用解构快速提取 profile 对象的 name 和 hobby 属性。</p>\n<p>使用别名，你可以使用与你正在提取值的对象属性不同的变量名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> profile = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'georage'</span>, <span class=\"attr\">age</span>: <span class=\"number\">39</span>, <span class=\"attr\">hobby</span>: <span class=\"string\">'Tennis'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">name</span>: n, <span class=\"attr\">hobby</span>: h &#125; = profile</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n) <span class=\"comment\">//'georage'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(h) <span class=\"comment\">//'Tennis'</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"嵌套对象解构\"><a href=\"#嵌套对象解构\" class=\"headerlink\" title=\"嵌套对象解构\"></a>嵌套对象解构</h3><p>解构也可以与嵌套对象一起工作，可以使用它来快速解开来自复杂的 JSON 请求的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jsondata = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">'XX'</span>,</span><br><span class=\"line\">  details: &#123;</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      created: <span class=\"string\">'2017/09/19'</span>,</span><br><span class=\"line\">      modified: <span class=\"string\">'2017/09/20'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    catrgory: <span class=\"string\">'js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  url: <span class=\"string\">'/baidu/'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;title,<span class=\"attr\">details</span>:&#123;<span class=\"attr\">data</span>:&#123;created.modified&#125;&#125;&#125; = jsondata</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(title)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(created)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(modified)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"解构数组\"><a href=\"#解构数组\" class=\"headerlink\" title=\"解构数组\"></a>解构数组</h3><p>数组的解构与对象上的工作方式类似，除了左边的花括号使用<strong>方括号</strong>代替：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> soccerteam = [<span class=\"string\">'George'</span>, <span class=\"string\">'Dennis'</span>, <span class=\"string\">'Sandy'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> [a, b] = soccerteam</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// \"George\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// \"Dennis\"</span></span><br></pre></td></tr></table></figure>\n<p>你可以跳过某些数组元素，通过使用 (,)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> soccerteam = [<span class=\"string\">'George'</span>, <span class=\"string\">'Dennis'</span>, <span class=\"string\">'Sandy'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> [a,,b] = soccerteam</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// \"George\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// \"Sandy\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"默认和剩余参数\"><a href=\"#默认和剩余参数\" class=\"headerlink\" title=\"默认和剩余参数\"></a>默认和剩余参数</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在这之前我们都使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getarea</span>(<span class=\"params\">w, h</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = w || <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> h = h || <span class=\"number\">15</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> w * h</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了 ES6 对默认参数的支持后</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getarea</span>(<span class=\"params\">w = <span class=\"number\">10</span>, h = <span class=\"number\">15</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> w * h</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getarea(<span class=\"number\">5</span>) <span class=\"comment\">//75</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"剩余参数-（Rest-Parameters-）\"><a href=\"#剩余参数-（Rest-Parameters-）\" class=\"headerlink\" title=\"剩余参数 （Rest Parameters ）\"></a>剩余参数 （Rest Parameters ）</h3><p>ES6 中的 Rest Parameters 使得将函数参数转换成数组的操作变得简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addit</span>(<span class=\"params\">...theNumber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//get the sum of the array elements</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> theNumber.reduce( <span class=\"function\">(<span class=\"params\">prevnum.curnum</span>)=&gt;</span>prevnu+curnum,<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addit(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)<span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>通过在命名参数前添加 3 个点。在该位置和之后输入到函数中的参数将自动转换为数组。</p>\n<p>没有 Rest Parameters 则会手动将参数转换为数组 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addit</span>(<span class=\"params\">theNumbers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// force arguments object into array</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> numArray = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> numArray.reduce(<span class=\"function\">(<span class=\"params\">prevnum, curnum</span>) =&gt;</span> prevnum + curnum, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addit(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// returns 10</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">...[a, b, c]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>) <span class=\"comment\">// NaN (b and c are undefined)</span></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">//6 (the fourth parameter is not destructured)</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>发现自己对于 javascript 的底层 API 所知甚少，在这里记录一下所遇到的有趣又是在的 API。</p>","more":"<h2 id=\"set-对象-（可用于去重）\"><a href=\"#set-对象-（可用于去重）\" class=\"headerlink\" title=\"set 对象 （可用于去重）\"></a>set 对象 （可用于去重）</h2><p>set 独享允许你存储任何类型唯一值，无论是原始值或是对象。NaN 之间视为相同的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">引用 <span class=\"keyword\">const</span> set1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Set</span>([<span class=\"number\">1</span>,<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"literal\">NaN</span>, <span class=\"literal\">NaN</span>, <span class=\"number\">5</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.has(<span class=\"number\">1</span>)); <span class=\"comment\">// expected output: true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.has(<span class=\"number\">5</span>)); <span class=\"comment\">// expected output: true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(set1.has(<span class=\"number\">6</span>)); <span class=\"comment\">// expected output:false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(set1)) <span class=\"comment\">// Array [1, 2, 3, 4, NaN, 5]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h2><p>从一个类似数组或可迭代对象中创建一个新的数组实例。</p>\n<h2 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h2><p>super 关键字用于访问和调用一个对象的父对象的函数。( 只能在 class 内部用 )</p>\n<p>在构造函数中使用时，super 关键字将单独出现，并且必须在使用 this 之前使用。</p>\n<p>super 关键字也可以用来调用父对象上的函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">super</span>([<span class=\"built_in\">arguments</span>]);</span><br><span class=\"line\"><span class=\"comment\">// 调用 父对象/父类 的构造函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">super</span>.functionOnParent([<span class=\"built_in\">arguments</span>]);</span><br><span class=\"line\"><span class=\"comment\">// 调用 父对象/父类 上的方法</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Polygon</span> </span>&#123;</span><br><span class=\"line\">  construector(height, width) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'Polygon'</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.height = height</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.width = width</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayName() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Hi,I am a'</span>, <span class=\"keyword\">this</span>.name + <span class=\"string\">'.'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Square</span> <span class=\"keyword\">extends</span> <span class=\"title\">Polygon</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span>(length)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.height;</span><br><span class=\"line\">      <span class=\"comment\">// ReferenceError ,super 需要先被调用！</span></span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       这里，它调用父类的构造函数的length,</span></span><br><span class=\"line\"><span class=\"comment\">       作为Polygon 的 width 和 height</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">       <span class=\"keyword\">super</span>(length,length)</span><br><span class=\"line\">       <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">       注意，在派生的类中，在你可以使用this之前，必须 先调用super()。忽略这，这将导致引用错误。</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">       <span class=\"keyword\">this</span>.name = <span class=\"string\">'Square'</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get area()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.height * <span class=\"keyword\">this</span>.width</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set area(value)&#123;</span><br><span class=\"line\">      <span class=\"keyword\">this</span>.area = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>使用 super 调用父类的静态方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Human</span></span>&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> ping()&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"string\">'ping'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">computer</span> <span class=\"title\">eatends</span> <span class=\"title\">Human</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>()&#123;&#125;</span><br><span class=\"line\">  <span class=\"keyword\">static</span> pingpong()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">super</span>.ping()+<span class=\"string\">'pong'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Computer.pingpong()</span><br></pre></td></tr></table></figure>\n<p><strong>原始 class 实现方式</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Parent.prototype.getName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  Parent.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//实现继承</span></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype.getAge = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.Age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> people = <span class=\"keyword\">new</span> Child(<span class=\"string\">'lily'</span>, <span class=\"number\">20</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(people.getName())</span><br></pre></td></tr></table></figure>\n<p><strong>语法糖</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Parent</span> </span>&#123;</span><br><span class=\"line\">  construtor(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  getAge() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.age</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> people = <span class=\"keyword\">new</span> Child(<span class=\"string\">\"lily\"</span>,<span class=\"number\">20</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(people.getName())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"异步函数\"><a href=\"#异步函数\" class=\"headerlink\" title=\"异步函数\"></a>异步函数</h2><p>除了 javascript Promise , 异步函数进一步重写了传统的异步代码结构。</p>\n<h3 id=\"一个以-async-为前缀的常规函数\"><a href=\"#一个以-async-为前缀的常规函数\" class=\"headerlink\" title=\"一个以 async 为前缀的常规函数\"></a>一个以 async 为前缀的常规函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchdata</span>(<span class=\"params\">url</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"在异步函数（Async-function-）内，使用-await-关键字调用异步操作函数\"><a href=\"#在异步函数（Async-function-）内，使用-await-关键字调用异步操作函数\" class=\"headerlink\" title=\"在异步函数（Async function ）内，使用 await 关键字调用异步操作函数\"></a>在异步函数（Async function ）内，使用 await 关键字调用异步操作函数</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getaSync</span>(<span class=\"params\">url</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> xhr = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\">    xhr.open(<span class=\"string\">'GET'</span>, url)</span><br><span class=\"line\">    xhr.onload = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve(xhr.responseText)</span><br><span class=\"line\">    xhr.onerror = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(xhr.statusText)</span><br><span class=\"line\">    xhr.send()</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fetchdata</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> text1 = <span class=\"keyword\">await</span> getasync(<span class=\"string\">'test.txt'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.logtex(text1)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> text2 = <span class=\"keyword\">await</span> getasync(<span class=\"string\">'test2.text'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(text2)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> text3 = <span class=\"keyword\">await</span> getasync(<span class=\"string\">'text3.text)</span></span><br><span class=\"line\"><span class=\"string\">  console.log(text3)</span></span><br><span class=\"line\"><span class=\"string\">  return '</span>Finished<span class=\"string\">'</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">fetchdata().then((msg)=&gt;&#123;</span></span><br><span class=\"line\"><span class=\"string\">  console.log(msg) //“test.txt”，“test2.txt”，“test3.txt”</span></span><br><span class=\"line\"><span class=\"string\">&#125;)</span></span><br></pre></td></tr></table></figure>\n<p>在异步函数中，我们把异步函数 getasync() 当做是同步函数，没有 then() 方法或回调函数通知下一步。无论何时遇到关键字 await , 执行都会停止，直到 getasync() 解决，然后再转到异步函数中的下一行。结果与纯粹的基于 Promise , 使用一串 then 方法的方式一样</p>\n<h2 id=\"解构\"><a href=\"#解构\" class=\"headerlink\" title=\"解构\"></a>解构</h2><p>ES6 解构并非一个新的功能，而是一个新的复制语法，可以快速解压缩对象属性和数组中的值，并将它们分配给各个变量。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> profile = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'georage'</span>, <span class=\"attr\">age</span>: <span class=\"number\">39</span>, <span class=\"attr\">hobby</span>: <span class=\"string\">'Tennis'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; name, hobby &#125; = profile</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//'georage'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(hobby) <span class=\"comment\">//'Tennis'</span></span><br></pre></td></tr></table></figure>\n<p>这里我用解构快速提取 profile 对象的 name 和 hobby 属性。</p>\n<p>使用别名，你可以使用与你正在提取值的对象属性不同的变量名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> profile = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'georage'</span>, <span class=\"attr\">age</span>: <span class=\"number\">39</span>, <span class=\"attr\">hobby</span>: <span class=\"string\">'Tennis'</span> &#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123; <span class=\"attr\">name</span>: n, <span class=\"attr\">hobby</span>: h &#125; = profile</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(n) <span class=\"comment\">//'georage'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(h) <span class=\"comment\">//'Tennis'</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"嵌套对象解构\"><a href=\"#嵌套对象解构\" class=\"headerlink\" title=\"嵌套对象解构\"></a>嵌套对象解构</h3><p>解构也可以与嵌套对象一起工作，可以使用它来快速解开来自复杂的 JSON 请求的值。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jsondata = &#123;</span><br><span class=\"line\">  title: <span class=\"string\">'XX'</span>,</span><br><span class=\"line\">  details: &#123;</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">      created: <span class=\"string\">'2017/09/19'</span>,</span><br><span class=\"line\">      modified: <span class=\"string\">'2017/09/20'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    catrgory: <span class=\"string\">'js'</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  url: <span class=\"string\">'/baidu/'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> &#123;title,<span class=\"attr\">details</span>:&#123;<span class=\"attr\">data</span>:&#123;created.modified&#125;&#125;&#125; = jsondata</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(title)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(created)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(modified)</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"解构数组\"><a href=\"#解构数组\" class=\"headerlink\" title=\"解构数组\"></a>解构数组</h3><p>数组的解构与对象上的工作方式类似，除了左边的花括号使用<strong>方括号</strong>代替：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> soccerteam = [<span class=\"string\">'George'</span>, <span class=\"string\">'Dennis'</span>, <span class=\"string\">'Sandy'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> [a, b] = soccerteam</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// \"George\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// \"Dennis\"</span></span><br></pre></td></tr></table></figure>\n<p>你可以跳过某些数组元素，通过使用 (,)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">var</span> soccerteam = [<span class=\"string\">'George'</span>, <span class=\"string\">'Dennis'</span>, <span class=\"string\">'Sandy'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> [a,,b] = soccerteam</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// \"George\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(b) <span class=\"comment\">// \"Sandy\"</span></span><br></pre></td></tr></table></figure>\n<hr>\n<h2 id=\"默认和剩余参数\"><a href=\"#默认和剩余参数\" class=\"headerlink\" title=\"默认和剩余参数\"></a>默认和剩余参数</h2><h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在这之前我们都使用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getarea</span>(<span class=\"params\">w, h</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> w = w || <span class=\"number\">10</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> h = h || <span class=\"number\">15</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> w * h</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>有了 ES6 对默认参数的支持后</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getarea</span>(<span class=\"params\">w = <span class=\"number\">10</span>, h = <span class=\"number\">15</span></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> w * h</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getarea(<span class=\"number\">5</span>) <span class=\"comment\">//75</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"剩余参数-（Rest-Parameters-）\"><a href=\"#剩余参数-（Rest-Parameters-）\" class=\"headerlink\" title=\"剩余参数 （Rest Parameters ）\"></a>剩余参数 （Rest Parameters ）</h3><p>ES6 中的 Rest Parameters 使得将函数参数转换成数组的操作变得简单。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addit</span>(<span class=\"params\">...theNumber</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//get the sum of the array elements</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> theNumber.reduce( <span class=\"function\">(<span class=\"params\">prevnum.curnum</span>)=&gt;</span>prevnu+curnum,<span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">addit(<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>)<span class=\"comment\">//10</span></span><br></pre></td></tr></table></figure>\n<p>通过在命名参数前添加 3 个点。在该位置和之后输入到函数中的参数将自动转换为数组。</p>\n<p>没有 Rest Parameters 则会手动将参数转换为数组 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addit</span>(<span class=\"params\">theNumbers</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// force arguments object into array</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> numArray = <span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> numArray.reduce(<span class=\"function\">(<span class=\"params\">prevnum, curnum</span>) =&gt;</span> prevnum + curnum, <span class=\"number\">0</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">addit(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// returns 10</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">...[a, b, c]</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b + c</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>) <span class=\"comment\">// NaN (b and c are undefined)</span></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 6</span></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">//6 (the fourth parameter is not destructured)</span></span><br></pre></td></tr></table></figure>"},{"title":"Object.defineProperty","_content":"\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue 是通过数据劫持来做数据绑定的，其中最核心的方法便是通过 Ojbect.defineProperty() 来实现对属性的劫持，达到监听数据变动的目的。\n\n<!--more-->\n\n## Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\n\n在 js 中我们可以通过下面几种方法定义属性 :\n\n```javascript\n// (1) define someOne property name\nsomeOne.name = 'cover'\n//or use (2)\nsomeOne['name'] = 'cover'\n// or use (3) defineProperty\nObject.defineProperty(someOne, 'name', {\n  value: 'cover'\n})\n```\n\n### descriptor\n\n其中 descriptor 的参数值得我们关注下 , 该属性可设置的值有：value 、 writable、configurable 、 enumerable、set 和 get。\n\n#### 【 value】\n\n该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。\n\n#### 【 writable】\n\n该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n```javascript\nvar someOne = {}\nObject.defineProperty(someOne, 'name', {\n  value: 'coverguo', //由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化\n  writable: false\n})\nconsole.log(someOne.name) // 输出 coverguo\nsomeOne.name = 'linkzhu'\nconsole.log(someOne.name) // 输出coverguo\n```\n\n#### 【 configurable】\n\n仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。\n\n如果为 false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable ）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n#### 【 enumerable】\n\n是否能在 for-in 循环中遍历出来或在 Object.keys 中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n```javascript\nvar a = {}\nObject.defineProperty(a, 'b', {\n  value: 3445,\n  enumerable: true\n})\nconsole.log(Object.keys(a)) // 打印[\"b\"]\n//改为false\nvar a = {}\nObject.defineProperty(a, 'b', {\n  value: 3445,\n  enumerable: false //注意咯这里改了\n})\nconsole.log(Object.keys(a)) // 打印[]\n```\n\n#### 注意：\n\n在调用 Object.defineProperty() 方法时，如果不指定， configurable ， enumerable， writable 特性的默认值都是 false, 这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：\n\n```javascript\n//调用Object.defineProperty()方法时，如果不指定\nvar someOne = {}\nsomeOne.name = 'coverguo'\nconsole.log(Object.getOwnPropertyDescriptor(someOne, 'name'))\n//输出 Object {value: \"coverguo\", writable: true, enumerable: true, configurable: true}\n\n//直接在对象上定义的属性，这个特性默认值为为 true\nvar otherOne = {}\nObject.defineProperty(otherOne, 'name', {\n  value: 'coverguo'\n})\nconsole.log(Object.getOwnPropertyDescriptor(otherOne, 'name'))\n//输出 Object {value: \"coverguo\", writable: false, enumerable: false, configurable: false}\n```\n\n#### 【 get】和【set 】\n\n在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用 (get 和 set)，就不能用（wriable 或 value 中的任何一个）\n\n```javascript\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  set:function(newValue){\n    console.log(\"你要赋值给我,我的新值是\"＋newValue)\n    },\n  get:function(){\n    console.log(\"你取我的值\")\n    return 2 //注意这里，我硬编码返回2\n   }\n})\na.b =1 //打印 你要赋值给我,我的新值是1\nconsole.log(a.b)    //打印 你取我的值\n                    //打印 2    注意这里，和我的硬编码相同的\n```\n\n\\** 这个 \"b\" 赋值 或者取值的时候会分别触发 set 和 get 对应的函数，这就是 observe 的关键，是 vue 实现 observe 的实现的基础，也是实现 $watch 的基础。\n\n##### 【 get】\n\n一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 ##### 【 set】 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。\n\n## 兼容性\n\n在 ie8 下只能在 DOM 对象上使用，尝试在原生的对象使用 Object.defineProperty() 会报错。\n","source":"_posts/Object-defineProperty.md","raw":"---\ntitle: Object.defineProperty\ncategories: 数据劫持基石\ntags:\n---\n\nObject.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue 是通过数据劫持来做数据绑定的，其中最核心的方法便是通过 Ojbect.defineProperty() 来实现对属性的劫持，达到监听数据变动的目的。\n\n<!--more-->\n\n## Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\n\n在 js 中我们可以通过下面几种方法定义属性 :\n\n```javascript\n// (1) define someOne property name\nsomeOne.name = 'cover'\n//or use (2)\nsomeOne['name'] = 'cover'\n// or use (3) defineProperty\nObject.defineProperty(someOne, 'name', {\n  value: 'cover'\n})\n```\n\n### descriptor\n\n其中 descriptor 的参数值得我们关注下 , 该属性可设置的值有：value 、 writable、configurable 、 enumerable、set 和 get。\n\n#### 【 value】\n\n该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。\n\n#### 【 writable】\n\n该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n```javascript\nvar someOne = {}\nObject.defineProperty(someOne, 'name', {\n  value: 'coverguo', //由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化\n  writable: false\n})\nconsole.log(someOne.name) // 输出 coverguo\nsomeOne.name = 'linkzhu'\nconsole.log(someOne.name) // 输出coverguo\n```\n\n#### 【 configurable】\n\n仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。\n\n如果为 false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable ）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n#### 【 enumerable】\n\n是否能在 for-in 循环中遍历出来或在 Object.keys 中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。\n\n```javascript\nvar a = {}\nObject.defineProperty(a, 'b', {\n  value: 3445,\n  enumerable: true\n})\nconsole.log(Object.keys(a)) // 打印[\"b\"]\n//改为false\nvar a = {}\nObject.defineProperty(a, 'b', {\n  value: 3445,\n  enumerable: false //注意咯这里改了\n})\nconsole.log(Object.keys(a)) // 打印[]\n```\n\n#### 注意：\n\n在调用 Object.defineProperty() 方法时，如果不指定， configurable ， enumerable， writable 特性的默认值都是 false, 这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：\n\n```javascript\n//调用Object.defineProperty()方法时，如果不指定\nvar someOne = {}\nsomeOne.name = 'coverguo'\nconsole.log(Object.getOwnPropertyDescriptor(someOne, 'name'))\n//输出 Object {value: \"coverguo\", writable: true, enumerable: true, configurable: true}\n\n//直接在对象上定义的属性，这个特性默认值为为 true\nvar otherOne = {}\nObject.defineProperty(otherOne, 'name', {\n  value: 'coverguo'\n})\nconsole.log(Object.getOwnPropertyDescriptor(otherOne, 'name'))\n//输出 Object {value: \"coverguo\", writable: false, enumerable: false, configurable: false}\n```\n\n#### 【 get】和【set 】\n\n在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用 (get 和 set)，就不能用（wriable 或 value 中的任何一个）\n\n```javascript\nvar a= {}\nObject.defineProperty(a,\"b\",{\n  set:function(newValue){\n    console.log(\"你要赋值给我,我的新值是\"＋newValue)\n    },\n  get:function(){\n    console.log(\"你取我的值\")\n    return 2 //注意这里，我硬编码返回2\n   }\n})\na.b =1 //打印 你要赋值给我,我的新值是1\nconsole.log(a.b)    //打印 你取我的值\n                    //打印 2    注意这里，和我的硬编码相同的\n```\n\n\\** 这个 \"b\" 赋值 或者取值的时候会分别触发 set 和 get 对应的函数，这就是 observe 的关键，是 vue 实现 observe 的实现的基础，也是实现 $watch 的基础。\n\n##### 【 get】\n\n一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 ##### 【 set】 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。\n\n## 兼容性\n\n在 ie8 下只能在 DOM 对象上使用，尝试在原生的对象使用 Object.defineProperty() 会报错。\n","slug":"Object-defineProperty","published":1,"date":"2018-03-20T03:29:41.816Z","updated":"2018-03-20T03:29:41.816Z","_id":"cjepksjlu00048gv6oskiz3e3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue 是通过数据劫持来做数据绑定的，其中最核心的方法便是通过 Ojbect.defineProperty() 来实现对属性的劫持，达到监听数据变动的目的。</p>\n<a id=\"more\"></a>\n<h2 id=\"Object-defineProperty-object-propertyname-descriptor-为对象定义属性\"><a href=\"#Object-defineProperty-object-propertyname-descriptor-为对象定义属性\" class=\"headerlink\" title=\"Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\"></a>Object.defineProperty(object, propertyname, descriptor) 为对象定义属性</h2><p>在 js 中我们可以通过下面几种方法定义属性 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) define someOne property name</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">'cover'</span></span><br><span class=\"line\"><span class=\"comment\">//or use (2)</span></span><br><span class=\"line\">someOne[<span class=\"string\">'name'</span>] = <span class=\"string\">'cover'</span></span><br><span class=\"line\"><span class=\"comment\">// or use (3) defineProperty</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">'cover'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"descriptor\"><a href=\"#descriptor\" class=\"headerlink\" title=\"descriptor\"></a>descriptor</h3><p>其中 descriptor 的参数值得我们关注下 , 该属性可设置的值有：value 、 writable、configurable 、 enumerable、set 和 get。</p>\n<h4 id=\"【-value】\"><a href=\"#【-value】\" class=\"headerlink\" title=\"【 value】\"></a>【 value】</h4><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。</p>\n<h4 id=\"【-writable】\"><a href=\"#【-writable】\" class=\"headerlink\" title=\"【 writable】\"></a>【 writable】</h4><p>该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">'coverguo'</span>, <span class=\"comment\">//由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化</span></span><br><span class=\"line\">  writable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name) <span class=\"comment\">// 输出 coverguo</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">'linkzhu'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name) <span class=\"comment\">// 输出coverguo</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"【-configurable】\"><a href=\"#【-configurable】\" class=\"headerlink\" title=\"【 configurable】\"></a>【 configurable】</h4><p>仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。</p>\n<p>如果为 false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable ）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<h4 id=\"【-enumerable】\"><a href=\"#【-enumerable】\" class=\"headerlink\" title=\"【 enumerable】\"></a>【 enumerable】</h4><p>是否能在 for-in 循环中遍历出来或在 Object.keys 中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, <span class=\"string\">'b'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a)) <span class=\"comment\">// 打印[\"b\"]</span></span><br><span class=\"line\"><span class=\"comment\">//改为false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, <span class=\"string\">'b'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable: <span class=\"literal\">false</span> <span class=\"comment\">//注意咯这里改了</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a)) <span class=\"comment\">// 打印[]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>在调用 Object.defineProperty() 方法时，如果不指定， configurable ， enumerable， writable 特性的默认值都是 false, 这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用Object.defineProperty()方法时，如果不指定</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123;&#125;</span><br><span class=\"line\">someOne.name = <span class=\"string\">'coverguo'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(someOne, <span class=\"string\">'name'</span>))</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接在对象上定义的属性，这个特性默认值为为 true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherOne = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(otherOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">'coverguo'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(otherOne, <span class=\"string\">'name'</span>))</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"【-get】和【set-】\"><a href=\"#【-get】和【set-】\" class=\"headerlink\" title=\"【 get】和【set 】\"></a>【 get】和【set 】</h4><p>在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用 (get 和 set)，就不能用（wriable 或 value 中的任何一个）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  set:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你要赋值给我,我的新值是\"</span>＋newValue)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  get:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你取我的值\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">//注意这里，我硬编码返回2</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">a.b =<span class=\"number\">1</span> <span class=\"comment\">//打印 你要赋值给我,我的新值是1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.b)    <span class=\"comment\">//打印 你取我的值</span></span><br><span class=\"line\">                    <span class=\"comment\">//打印 2    注意这里，和我的硬编码相同的</span></span><br></pre></td></tr></table></figure>\n<p>** 这个 “b” 赋值 或者取值的时候会分别触发 set 和 get 对应的函数，这就是 observe 的关键，是 vue 实现 observe 的实现的基础，也是实现 $watch 的基础。</p>\n<h5 id=\"【-get】\"><a href=\"#【-get】\" class=\"headerlink\" title=\"【 get】\"></a>【 get】</h5><p>一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 ##### 【 set】 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。</p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>在 ie8 下只能在 DOM 对象上使用，尝试在原生的对象使用 Object.defineProperty() 会报错。</p>\n","site":{"data":{}},"excerpt":"<p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Vue 是通过数据劫持来做数据绑定的，其中最核心的方法便是通过 Ojbect.defineProperty() 来实现对属性的劫持，达到监听数据变动的目的。</p>","more":"<h2 id=\"Object-defineProperty-object-propertyname-descriptor-为对象定义属性\"><a href=\"#Object-defineProperty-object-propertyname-descriptor-为对象定义属性\" class=\"headerlink\" title=\"Object.defineProperty(object, propertyname, descriptor) 为对象定义属性\"></a>Object.defineProperty(object, propertyname, descriptor) 为对象定义属性</h2><p>在 js 中我们可以通过下面几种方法定义属性 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (1) define someOne property name</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">'cover'</span></span><br><span class=\"line\"><span class=\"comment\">//or use (2)</span></span><br><span class=\"line\">someOne[<span class=\"string\">'name'</span>] = <span class=\"string\">'cover'</span></span><br><span class=\"line\"><span class=\"comment\">// or use (3) defineProperty</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">'cover'</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"descriptor\"><a href=\"#descriptor\" class=\"headerlink\" title=\"descriptor\"></a>descriptor</h3><p>其中 descriptor 的参数值得我们关注下 , 该属性可设置的值有：value 、 writable、configurable 、 enumerable、set 和 get。</p>\n<h4 id=\"【-value】\"><a href=\"#【-value】\" class=\"headerlink\" title=\"【 value】\"></a>【 value】</h4><p>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等），默认为 undefined。</p>\n<h4 id=\"【-writable】\"><a href=\"#【-writable】\" class=\"headerlink\" title=\"【 writable】\"></a>【 writable】</h4><p>该属性是否可写，如果设置成 false，则任何对该属性改写的操作都无效（但不会报错），对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(someOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">'coverguo'</span>, <span class=\"comment\">//由于设定了writable属性为false 导致这个量不可以修改 ，任何修改豆浆无效化</span></span><br><span class=\"line\">  writable: <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name) <span class=\"comment\">// 输出 coverguo</span></span><br><span class=\"line\">someOne.name = <span class=\"string\">'linkzhu'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(someOne.name) <span class=\"comment\">// 输出coverguo</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"【-configurable】\"><a href=\"#【-configurable】\" class=\"headerlink\" title=\"【 configurable】\"></a>【 configurable】</h4><p>仅当该属性的 configurable 为 true 时，该属性才能够被改变，也能够被删除。默认为 false。</p>\n<p>如果为 false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable ）的行为将被无效化，对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<h4 id=\"【-enumerable】\"><a href=\"#【-enumerable】\" class=\"headerlink\" title=\"【 enumerable】\"></a>【 enumerable】</h4><p>是否能在 for-in 循环中遍历出来或在 Object.keys 中列举出来。对于像前面例子中直接在对象上定义的属性，这个属性该特性默认值为为 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, <span class=\"string\">'b'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a)) <span class=\"comment\">// 打印[\"b\"]</span></span><br><span class=\"line\"><span class=\"comment\">//改为false</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a, <span class=\"string\">'b'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"number\">3445</span>,</span><br><span class=\"line\">  enumerable: <span class=\"literal\">false</span> <span class=\"comment\">//注意咯这里改了</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.keys(a)) <span class=\"comment\">// 打印[]</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>在调用 Object.defineProperty() 方法时，如果不指定， configurable ， enumerable， writable 特性的默认值都是 false, 这跟之前所 说的对于像前面例子中直接在对象上定义的属性，这个特性默认值为为 true。并不冲突，如下代码所示：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//调用Object.defineProperty()方法时，如果不指定</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> someOne = &#123;&#125;</span><br><span class=\"line\">someOne.name = <span class=\"string\">'coverguo'</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(someOne, <span class=\"string\">'name'</span>))</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//直接在对象上定义的属性，这个特性默认值为为 true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> otherOne = &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(otherOne, <span class=\"string\">'name'</span>, &#123;</span><br><span class=\"line\">  value: <span class=\"string\">'coverguo'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.getOwnPropertyDescriptor(otherOne, <span class=\"string\">'name'</span>))</span><br><span class=\"line\"><span class=\"comment\">//输出 Object &#123;value: \"coverguo\", writable: false, enumerable: false, configurable: false&#125;</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"【-get】和【set-】\"><a href=\"#【-get】和【set-】\" class=\"headerlink\" title=\"【 get】和【set 】\"></a>【 get】和【set 】</h4><p>在 descriptor 中不能 同时设置访问器 (get 和 set) 和 wriable 或 value，否则会错，就是说想用 (get 和 set)，就不能用（wriable 或 value 中的任何一个）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a= &#123;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.defineProperty(a,<span class=\"string\">\"b\"</span>,&#123;</span><br><span class=\"line\">  set:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你要赋值给我,我的新值是\"</span>＋newValue)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  get:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"你取我的值\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span> <span class=\"comment\">//注意这里，我硬编码返回2</span></span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">a.b =<span class=\"number\">1</span> <span class=\"comment\">//打印 你要赋值给我,我的新值是1</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.b)    <span class=\"comment\">//打印 你取我的值</span></span><br><span class=\"line\">                    <span class=\"comment\">//打印 2    注意这里，和我的硬编码相同的</span></span><br></pre></td></tr></table></figure>\n<p>** 这个 “b” 赋值 或者取值的时候会分别触发 set 和 get 对应的函数，这就是 observe 的关键，是 vue 实现 observe 的实现的基础，也是实现 $watch 的基础。</p>\n<h5 id=\"【-get】\"><a href=\"#【-get】\" class=\"headerlink\" title=\"【 get】\"></a>【 get】</h5><p>一旦目标对象访问该属性，就会调用这个方法，并返回结果。默认为 undefined。 ##### 【 set】 一旦目标对象设置该属性，就会调用这个方法。默认为 undefined。</p>\n<h2 id=\"兼容性\"><a href=\"#兼容性\" class=\"headerlink\" title=\"兼容性\"></a>兼容性</h2><p>在 ie8 下只能在 DOM 对象上使用，尝试在原生的对象使用 Object.defineProperty() 会报错。</p>"},{"title":"JS基础(ES5)","date":"2018-01-18T02:12:34.000Z","_content":"\n感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。\n\n<!--more-->\n\n## 对象\n\n创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。\n\n### 对象直接量\n\n对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候。也会计算它的每个属性值，**也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每次创建的对象的属性值也有可能不同。**\n\n### 通过 new 创建对象\n\nvar obj=new MyClass(); new 运算符创建并初始化一个**新对象** 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向 MyClass.prototype\n\n#### object.creat()\n\n## 原型\n\n原型：每一个对象都从原型继承属性。**每个对象都有 _proto_ 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性**, 但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否是 o 的原型。\n\n### 原型模式\n\n原型模式是 js 对继承的一种实现\n\n* prototype：构造函数中的属性，指向该构造函数的原型对象。\n\n* constructor ：原型对象中的属性，指向该原型对象的构造函数\n\n* *proto*：实例中的属性，指向 new 这个实例的构造函数的原型对象\n\n### prototype 属性的引入\n\n每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个 prototype 属性。\n\n这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享的属性及方法，就放在构造函数里面。\n\n实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是引用的。\n\n```javascript\nfunction DOG(name) {\n  this.name = name\n}\nDOG.prototype = { species: '犬科' }\n\nvar dogA = new DOG('大毛')\nvar dogB = new DOG('二毛')\n\nalert(dogA.species)\n// 其实是通过dogA._proto_.species 来访问DOG.prototype.species\nalert(dogB.species)\n// 犬科\nDOG.prototype\n//{species:''犬科',constructor:fDOG(name),_proto_:Object}\nDOG.prototype.constructor === DOG\n//true\n```\n\n现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。\n\n![img caption](/images/prototype/1.png)\n\n以上就是一个简单的 DOG 类完整的原型链。\n\n#### 原型链的作用：对象属性的访问修改和删除。\n\n* 访问。优先在对象本身查找，没有则顺着原型链向上查找\n* 修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。\n\n### _proto_ （原型指针）\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nperson1.__proto__ == Person.prototype\n//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person\nPerson.__proto__\n//Person.constructor = Function => Person.__proto__  = Function.prototype\nPerson.prototype.__proto__\n// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object => Person.prototype.__proto__ =  Object.prototype\nObject.__proto__\n//普通对象 同上\nObject.prototype.__proto__\n//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端\n```\n\nJS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _proto_ 的内置属性，**用于指向创建它的构造函数的原型对象** ，原型链继承是通过 _proto_ 这个原型指针来完成的\n\n### 原型链图\n\n褐色的线为原型链 ![img caption](/images/prototype/2.png)\n\n够造函数、原型和实例的关系：\n\n1. 每个构造函数都有一个原型对象（x.prototype)\n2. 原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)\n3. 实例都包含一个指向原型对象的内部指针（a._proto_ ）\n\n** 所有函数的默认原型都是 Object 的实例**\n\n### 继承\n\njavascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型链继承 ( 挂载到 prototype 属性上面 )。\n\n## 闭包\n\n创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。\n\n```javascript\nfunction test() {\n  for (var i = 0; i < 4; i++) {\n    console.log('i:' + i)\n    ;(function(e) {\n      setTimeout(function() {\n        console.log(e)\n      }, 0)\n    })(i)\n  }\n}\ntest() //i:0 => i:1 => i:2=> i:3=>  0 => 1=> 2 => 3\n```\n\n循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的引用，它是不会被循环改变的。\n\n```javascript\nfunction makeAdder(x) {\n  console.log('x:' + x)\n  return function(y) {\n    console.log('y:' + y)\n    return x + y\n  }\n}\n\nvar add5 = makeAdder(5)\n//x:5 undefined\nadd5\n//f(y){  console.log('y:' + y) return x + y}\nvar add10 = makeAdder(10)\n\nconsole.log(add5(2)) // y:2 => 7\nconsole.log(add10(2)) // 12\n\n// 释放对闭包的引用\nadd5 = null\nadd10 = null\n```\n\nadd5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后通过 null 释放对闭包的引用。\n\n在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。\n\n**闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量**\n\n```javascript\nfunction test() {\n  var arr = []\n  for (var i = 0; i < 10; i++) {\n    //作用域1\n    arr[i] = function() {\n      //作用域2 声明arr[]()\n      return i\n    }\n  }\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest()\n// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明\n//1.执行完for之后，在for作用域中i的值为10\n```\n\n改动一下\n\n```javascript\nfunction test() {\n  var arr = []\n  //块1作用域\n  for (let i = 0; i < 10; i++) {\n    //块2作用域\n    arr[i] = function() {\n      //块3作用域\n      return i\n    }\n  }\n  //块1作用域\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest() // 连续打印 0 到 9\n```\n\n**实现原因 :**\n\n* 当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr[a]()) 时 i 已经循环完毕，因此 i 全为 10。\n\n- 当使用 let 时，每次迭代 i 都被**重新声明**，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。\n- var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。\n\n### 闭包中的 this 对象\n\n```javascript\nvar name = 'The Window'\n\nvar obj = {\n  name: 'My Object',\n\n  getName: function() {\n    return function() {\n      return this.name\n    }\n  }\n}\n\nconsole.log(obj.getName()()) // The Window\n```\n\nobj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。\n\n### 闭包的应用\n\n**应用闭包的主要场合是：设计私有的方法和变量。** 闭包的作用：\n\n* 访问函数的内部变量\n* 让被引用的变量值始终保存在内存中\n\n```javascript\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\n\nvar a = fun(0) // undefined\na.fun(1) // 0\na.fun(2) // 0\na.fun(3) // 0\n\nvar b = fun(0)\n  .fun(1)\n  .fun(2)\n  .fun(3) // undefined,0,1,2\n\nvar c = fun(0).fun(1) // undefined,0\nc.fun(2) // 1\nc.fun(3) // 1\n```\n\n```javascript\nfunction fn1() {\n  var a = 1\n  return function() {\n    console.log(++a)\n  }\n}\n\nvar fn2 = fn1()\n\nfn2() //输出2\n\nfn2() //输出3\n```\n\n## call、apply 、 bind\n\n参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call ， apply 立即执行，bind 是 return 出一个 this “ 固定 ” 的函数，这也是为什么 bind 是强绑定的一个原因）。\n\n### call()\n\n```javascript\nfunction class1() {\n  this.name = function() {\n    console.log('我是class1内的方法')\n  }\n}\nfunction class2() {\n  class1.call(this) //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）\n}\n\nvar f = new class2()\nf.name() //调用的是class1内的方法，将class1的name方法交给class2使用\n```\n\n```javascript\nfunction eat(x, y) {\n  console.log(x + y)\n}\nfunction drink(x, y) {\n  console.log(x - y)\n}\neat.call(drink, 3, 2) //5\n```\n\n这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2)\n\n```javascript\nfunction Animal() {\n  this.name = 'animal'\n  this.showName = function() {\n    console.log(this.name)\n  }\n}\nfunction Dog() {\n  this.name = 'dog'\n}\nvar animal = new Animal()\nvar dog = new Dog()\n\nanimal.showName.call(dog) //dog\n```\n\n意思是把 animal 的方法放到 dog 上执行，也可以说，把 animal 的 showName() 方法放到 dog 上来执行，所以 this.name 应该是 dog。\n\n#### 继承\n\n```javascript\nfunction Animal(name) {\n  this.name = name\n  this.showName = function() {\n    console.log(this.name)\n  }\n}\nfunction Dog(name) {\n  Animal.call(this, name)\n}\nvar dog = new Dog('Crazy dog')\ndog.showName()\n```\n\nAnimal.call(this) 的意思就是使用 Animal 对象代替 this 对象，那么 Dog 就能直接调用 Animal 的所有属性和方法。\n\n### apply\n\n```javascript\nfunction class1(args1, args2) {\n  this.name = function() {\n    console.log(args, args)\n  }\n}\nfunction class2() {\n  var args1 = '1'\n  var args2 = '2'\n  class1.call(this, args1, args2)\n  /*或*/\n  class1.apply(this, [args1, args2])\n}\n\nvar c = new class2()\nc.name()\n```\n\n### bind\n\nbind 是在 EcmaScript5 中扩展的方法（IE6,7,8 不支持。\n\nbind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n```javascript\nvar bar = function() {\n  console.log(this.x)\n}\nvar foo = {\n  x: 3\n}\nbar()\nbar.bind(foo)() //undefined 3\n/*或*/\nvar func = bar.bind(foo)\nfunc()\n```\n","source":"_posts/JS基础-ES5.md","raw":"---\ntitle: JS基础(ES5)\ndate: 2018-01-18 10:12:34\ncategories: 原生JS\n---\n\n感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。\n\n<!--more-->\n\n## 对象\n\n创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。\n\n### 对象直接量\n\n对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候。也会计算它的每个属性值，**也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每次创建的对象的属性值也有可能不同。**\n\n### 通过 new 创建对象\n\nvar obj=new MyClass(); new 运算符创建并初始化一个**新对象** 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向 MyClass.prototype\n\n#### object.creat()\n\n## 原型\n\n原型：每一个对象都从原型继承属性。**每个对象都有 _proto_ 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性**, 但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否是 o 的原型。\n\n### 原型模式\n\n原型模式是 js 对继承的一种实现\n\n* prototype：构造函数中的属性，指向该构造函数的原型对象。\n\n* constructor ：原型对象中的属性，指向该原型对象的构造函数\n\n* *proto*：实例中的属性，指向 new 这个实例的构造函数的原型对象\n\n### prototype 属性的引入\n\n每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个 prototype 属性。\n\n这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享的属性及方法，就放在构造函数里面。\n\n实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是引用的。\n\n```javascript\nfunction DOG(name) {\n  this.name = name\n}\nDOG.prototype = { species: '犬科' }\n\nvar dogA = new DOG('大毛')\nvar dogB = new DOG('二毛')\n\nalert(dogA.species)\n// 其实是通过dogA._proto_.species 来访问DOG.prototype.species\nalert(dogB.species)\n// 犬科\nDOG.prototype\n//{species:''犬科',constructor:fDOG(name),_proto_:Object}\nDOG.prototype.constructor === DOG\n//true\n```\n\n现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。\n\n![img caption](/images/prototype/1.png)\n\n以上就是一个简单的 DOG 类完整的原型链。\n\n#### 原型链的作用：对象属性的访问修改和删除。\n\n* 访问。优先在对象本身查找，没有则顺着原型链向上查找\n* 修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。\n\n### _proto_ （原型指针）\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nperson1.__proto__ == Person.prototype\n//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person\nPerson.__proto__\n//Person.constructor = Function => Person.__proto__  = Function.prototype\nPerson.prototype.__proto__\n// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object => Person.prototype.__proto__ =  Object.prototype\nObject.__proto__\n//普通对象 同上\nObject.prototype.__proto__\n//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端\n```\n\nJS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 _proto_ 的内置属性，**用于指向创建它的构造函数的原型对象** ，原型链继承是通过 _proto_ 这个原型指针来完成的\n\n### 原型链图\n\n褐色的线为原型链 ![img caption](/images/prototype/2.png)\n\n够造函数、原型和实例的关系：\n\n1. 每个构造函数都有一个原型对象（x.prototype)\n2. 原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)\n3. 实例都包含一个指向原型对象的内部指针（a._proto_ ）\n\n** 所有函数的默认原型都是 Object 的实例**\n\n### 继承\n\njavascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型链继承 ( 挂载到 prototype 属性上面 )。\n\n## 闭包\n\n创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。\n\n```javascript\nfunction test() {\n  for (var i = 0; i < 4; i++) {\n    console.log('i:' + i)\n    ;(function(e) {\n      setTimeout(function() {\n        console.log(e)\n      }, 0)\n    })(i)\n  }\n}\ntest() //i:0 => i:1 => i:2=> i:3=>  0 => 1=> 2 => 3\n```\n\n循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的引用，它是不会被循环改变的。\n\n```javascript\nfunction makeAdder(x) {\n  console.log('x:' + x)\n  return function(y) {\n    console.log('y:' + y)\n    return x + y\n  }\n}\n\nvar add5 = makeAdder(5)\n//x:5 undefined\nadd5\n//f(y){  console.log('y:' + y) return x + y}\nvar add10 = makeAdder(10)\n\nconsole.log(add5(2)) // y:2 => 7\nconsole.log(add10(2)) // 12\n\n// 释放对闭包的引用\nadd5 = null\nadd10 = null\n```\n\nadd5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后通过 null 释放对闭包的引用。\n\n在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。\n\n**闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量**\n\n```javascript\nfunction test() {\n  var arr = []\n  for (var i = 0; i < 10; i++) {\n    //作用域1\n    arr[i] = function() {\n      //作用域2 声明arr[]()\n      return i\n    }\n  }\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest()\n// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明\n//1.执行完for之后，在for作用域中i的值为10\n```\n\n改动一下\n\n```javascript\nfunction test() {\n  var arr = []\n  //块1作用域\n  for (let i = 0; i < 10; i++) {\n    //块2作用域\n    arr[i] = function() {\n      //块3作用域\n      return i\n    }\n  }\n  //块1作用域\n  for (var a = 0; a < 10; a++) {\n    console.log(arr[a]())\n  }\n}\ntest() // 连续打印 0 到 9\n```\n\n**实现原因 :**\n\n* 当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr[a]()) 时 i 已经循环完毕，因此 i 全为 10。\n\n- 当使用 let 时，每次迭代 i 都被**重新声明**，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。\n- var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。\n\n### 闭包中的 this 对象\n\n```javascript\nvar name = 'The Window'\n\nvar obj = {\n  name: 'My Object',\n\n  getName: function() {\n    return function() {\n      return this.name\n    }\n  }\n}\n\nconsole.log(obj.getName()()) // The Window\n```\n\nobj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。\n\n### 闭包的应用\n\n**应用闭包的主要场合是：设计私有的方法和变量。** 闭包的作用：\n\n* 访问函数的内部变量\n* 让被引用的变量值始终保存在内存中\n\n```javascript\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\n\nvar a = fun(0) // undefined\na.fun(1) // 0\na.fun(2) // 0\na.fun(3) // 0\n\nvar b = fun(0)\n  .fun(1)\n  .fun(2)\n  .fun(3) // undefined,0,1,2\n\nvar c = fun(0).fun(1) // undefined,0\nc.fun(2) // 1\nc.fun(3) // 1\n```\n\n```javascript\nfunction fn1() {\n  var a = 1\n  return function() {\n    console.log(++a)\n  }\n}\n\nvar fn2 = fn1()\n\nfn2() //输出2\n\nfn2() //输出3\n```\n\n## call、apply 、 bind\n\n参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call ， apply 立即执行，bind 是 return 出一个 this “ 固定 ” 的函数，这也是为什么 bind 是强绑定的一个原因）。\n\n### call()\n\n```javascript\nfunction class1() {\n  this.name = function() {\n    console.log('我是class1内的方法')\n  }\n}\nfunction class2() {\n  class1.call(this) //此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）\n}\n\nvar f = new class2()\nf.name() //调用的是class1内的方法，将class1的name方法交给class2使用\n```\n\n```javascript\nfunction eat(x, y) {\n  console.log(x + y)\n}\nfunction drink(x, y) {\n  console.log(x - y)\n}\neat.call(drink, 3, 2) //5\n```\n\n这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2)\n\n```javascript\nfunction Animal() {\n  this.name = 'animal'\n  this.showName = function() {\n    console.log(this.name)\n  }\n}\nfunction Dog() {\n  this.name = 'dog'\n}\nvar animal = new Animal()\nvar dog = new Dog()\n\nanimal.showName.call(dog) //dog\n```\n\n意思是把 animal 的方法放到 dog 上执行，也可以说，把 animal 的 showName() 方法放到 dog 上来执行，所以 this.name 应该是 dog。\n\n#### 继承\n\n```javascript\nfunction Animal(name) {\n  this.name = name\n  this.showName = function() {\n    console.log(this.name)\n  }\n}\nfunction Dog(name) {\n  Animal.call(this, name)\n}\nvar dog = new Dog('Crazy dog')\ndog.showName()\n```\n\nAnimal.call(this) 的意思就是使用 Animal 对象代替 this 对象，那么 Dog 就能直接调用 Animal 的所有属性和方法。\n\n### apply\n\n```javascript\nfunction class1(args1, args2) {\n  this.name = function() {\n    console.log(args, args)\n  }\n}\nfunction class2() {\n  var args1 = '1'\n  var args2 = '2'\n  class1.call(this, args1, args2)\n  /*或*/\n  class1.apply(this, [args1, args2])\n}\n\nvar c = new class2()\nc.name()\n```\n\n### bind\n\nbind 是在 EcmaScript5 中扩展的方法（IE6,7,8 不支持。\n\nbind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。\n\n```javascript\nvar bar = function() {\n  console.log(this.x)\n}\nvar foo = {\n  x: 3\n}\nbar()\nbar.bind(foo)() //undefined 3\n/*或*/\nvar func = bar.bind(foo)\nfunc()\n```\n","slug":"JS基础-ES5","published":1,"updated":"2018-03-20T03:29:41.815Z","_id":"cjepksjm200058gv6xafx340f","comments":1,"layout":"post","photos":[],"link":"","content":"<p>感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。</p>\n<a id=\"more\"></a>\n<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。</p>\n<h3 id=\"对象直接量\"><a href=\"#对象直接量\" class=\"headerlink\" title=\"对象直接量\"></a>对象直接量</h3><p>对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候。也会计算它的每个属性值，<strong>也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每次创建的对象的属性值也有可能不同。</strong></p>\n<h3 id=\"通过-new-创建对象\"><a href=\"#通过-new-创建对象\" class=\"headerlink\" title=\"通过 new 创建对象\"></a>通过 new 创建对象</h3><p>var obj=new MyClass(); new 运算符创建并初始化一个<strong>新对象</strong> 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向 MyClass.prototype</p>\n<h4 id=\"object-creat\"><a href=\"#object-creat\" class=\"headerlink\" title=\"object.creat()\"></a>object.creat()</h4><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><p>原型：每一个对象都从原型继承属性。<strong>每个对象都有 <em>proto</em> 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性</strong>, 但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否是 o 的原型。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>原型模式是 js 对继承的一种实现</p>\n<ul>\n<li><p>prototype：构造函数中的属性，指向该构造函数的原型对象。</p>\n</li>\n<li><p>constructor ：原型对象中的属性，指向该原型对象的构造函数</p>\n</li>\n<li><p><em>proto</em>：实例中的属性，指向 new 这个实例的构造函数的原型对象</p>\n</li>\n</ul>\n<h3 id=\"prototype-属性的引入\"><a href=\"#prototype-属性的引入\" class=\"headerlink\" title=\"prototype 属性的引入\"></a>prototype 属性的引入</h3><p>每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个 prototype 属性。</p>\n<p>这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享的属性及方法，就放在构造函数里面。</p>\n<p>实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是引用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DOG</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">DOG.prototype = &#123; <span class=\"attr\">species</span>: <span class=\"string\">'犬科'</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dogA = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'大毛'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> dogB = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'二毛'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">alert(dogA.species)</span><br><span class=\"line\"><span class=\"comment\">// 其实是通过dogA._proto_.species 来访问DOG.prototype.species</span></span><br><span class=\"line\">alert(dogB.species)</span><br><span class=\"line\"><span class=\"comment\">// 犬科</span></span><br><span class=\"line\">DOG.prototype</span><br><span class=\"line\"><span class=\"comment\">//&#123;species:''犬科',constructor:fDOG(name),_proto_:Object&#125;</span></span><br><span class=\"line\">DOG.prototype.constructor === DOG</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。</p>\n<p><img src=\"/images/prototype/1.png\" alt=\"img caption\"></p>\n<p>以上就是一个简单的 DOG 类完整的原型链。</p>\n<h4 id=\"原型链的作用：对象属性的访问修改和删除。\"><a href=\"#原型链的作用：对象属性的访问修改和删除。\" class=\"headerlink\" title=\"原型链的作用：对象属性的访问修改和删除。\"></a>原型链的作用：对象属性的访问修改和删除。</h4><ul>\n<li>访问。优先在对象本身查找，没有则顺着原型链向上查找</li>\n<li>修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。</li>\n</ul>\n<h3 id=\"proto-（原型指针）\"><a href=\"#proto-（原型指针）\" class=\"headerlink\" title=\"proto （原型指针）\"></a><em>proto</em> （原型指针）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1.__proto__ == Person.prototype</span><br><span class=\"line\"><span class=\"comment\">//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person</span></span><br><span class=\"line\">Person.__proto__</span><br><span class=\"line\"><span class=\"comment\">//Person.constructor = Function =&gt; Person.__proto__  = Function.prototype</span></span><br><span class=\"line\">Person.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object =&gt; Person.prototype.__proto__ =  Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__</span><br><span class=\"line\"><span class=\"comment\">//普通对象 同上</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端</span></span><br></pre></td></tr></table></figure>\n<p>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 <em>proto</em> 的内置属性，<strong>用于指向创建它的构造函数的原型对象</strong> ，原型链继承是通过 <em>proto</em> 这个原型指针来完成的</p>\n<h3 id=\"原型链图\"><a href=\"#原型链图\" class=\"headerlink\" title=\"原型链图\"></a>原型链图</h3><p>褐色的线为原型链 <img src=\"/images/prototype/2.png\" alt=\"img caption\"></p>\n<p>够造函数、原型和实例的关系：</p>\n<ol>\n<li>每个构造函数都有一个原型对象（x.prototype)</li>\n<li>原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)</li>\n<li>实例都包含一个指向原型对象的内部指针（a.<em>proto</em> ）</li>\n</ol>\n<p><strong> 所有函数的默认原型都是 Object 的实例</strong></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>javascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型链继承 ( 挂载到 prototype 属性上面 )。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i:'</span> + i)</span><br><span class=\"line\">    ;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test() <span class=\"comment\">//i:0 =&gt; i:1 =&gt; i:2=&gt; i:3=&gt;  0 =&gt; 1=&gt; 2 =&gt; 3</span></span><br></pre></td></tr></table></figure>\n<p>循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的引用，它是不会被循环改变的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'x:'</span> + x)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'y:'</span> + y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//x:5 undefined</span></span><br><span class=\"line\">add5</span><br><span class=\"line\"><span class=\"comment\">//f(y)&#123;  console.log('y:' + y) return x + y&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>)) <span class=\"comment\">// y:2 =&gt; 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)) <span class=\"comment\">// 12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放对闭包的引用</span></span><br><span class=\"line\">add5 = <span class=\"literal\">null</span></span><br><span class=\"line\">add10 = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>add5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后通过 null 释放对闭包的引用。</p>\n<p>在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>\n<p><strong>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//作用域1</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//作用域2 声明arr[]()</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br><span class=\"line\"><span class=\"comment\">// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明</span></span><br><span class=\"line\"><span class=\"comment\">//1.执行完for之后，在for作用域中i的值为10</span></span><br></pre></td></tr></table></figure>\n<p>改动一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//块2作用域</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//块3作用域</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test() <span class=\"comment\">// 连续打印 0 到 9</span></span><br></pre></td></tr></table></figure>\n<p><strong>实现原因 :</strong></p>\n<ul>\n<li>当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr<a href=\"\">a</a>) 时 i 已经循环完毕，因此 i 全为 10。</li>\n</ul>\n<ul>\n<li>当使用 let 时，每次迭代 i 都被<strong>重新声明</strong>，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。</li>\n<li>var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。</li>\n</ul>\n<h3 id=\"闭包中的-this-对象\"><a href=\"#闭包中的-this-对象\" class=\"headerlink\" title=\"闭包中的 this 对象\"></a>闭包中的 this 对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'The Window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'My Object'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getName()()) <span class=\"comment\">// The Window</span></span><br></pre></td></tr></table></figure>\n<p>obj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><p><strong>应用闭包的主要场合是：设计私有的方法和变量。</strong> 闭包的作用：</p>\n<ul>\n<li>访问函数的内部变量</li>\n<li>让被引用的变量值始终保存在内存中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">3</span>) <span class=\"comment\">// undefined,0,1,2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>) <span class=\"comment\">// undefined,0</span></span><br><span class=\"line\">c.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">c.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = fn1()</span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出2</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"call、apply-、-bind\"><a href=\"#call、apply-、-bind\" class=\"headerlink\" title=\"call、apply 、 bind\"></a>call、apply 、 bind</h2><p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call ， apply 立即执行，bind 是 return 出一个 this “ 固定 ” 的函数，这也是为什么 bind 是强绑定的一个原因）。</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'我是class1内的方法'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  class1.call(<span class=\"keyword\">this</span>) <span class=\"comment\">//此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> class2()</span><br><span class=\"line\">f.name() <span class=\"comment\">//调用的是class1内的方法，将class1的name方法交给class2使用</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eat</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drink</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x - y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">eat.call(drink, <span class=\"number\">3</span>, <span class=\"number\">2</span>) <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'animal'</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'dog'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog()</span><br><span class=\"line\"></span><br><span class=\"line\">animal.showName.call(dog) <span class=\"comment\">//dog</span></span><br></pre></td></tr></table></figure>\n<p>意思是把 animal 的方法放到 dog 上执行，也可以说，把 animal 的 showName() 方法放到 dog 上来执行，所以 this.name 应该是 dog。</p>\n<h4 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">'Crazy dog'</span>)</span><br><span class=\"line\">dog.showName()</span><br></pre></td></tr></table></figure>\n<p>Animal.call(this) 的意思就是使用 Animal 对象代替 this 对象，那么 Dog 就能直接调用 Animal 的所有属性和方法。</p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class1</span>(<span class=\"params\">args1, args2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args1 = <span class=\"string\">'1'</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args2 = <span class=\"string\">'2'</span></span><br><span class=\"line\">  class1.call(<span class=\"keyword\">this</span>, args1, args2)</span><br><span class=\"line\">  <span class=\"comment\">/*或*/</span></span><br><span class=\"line\">  class1.apply(<span class=\"keyword\">this</span>, [args1, args2])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> class2()</span><br><span class=\"line\">c.name()</span><br></pre></td></tr></table></figure>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><p>bind 是在 EcmaScript5 中扩展的方法（IE6,7,8 不支持。</p>\n<p>bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()</span><br><span class=\"line\">bar.bind(foo)() <span class=\"comment\">//undefined 3</span></span><br><span class=\"line\"><span class=\"comment\">/*或*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo)</span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>感觉自己的 ES5 掌握的比较杂乱，在此整理一下自己的思路，总结、归纳原生 JS 的知识。</p>","more":"<h2 id=\"对象\"><a href=\"#对象\" class=\"headerlink\" title=\"对象\"></a>对象</h2><p>创建对象可以通过对象直接量，关键字 new 和 object.creat() 函数来创建对象。每一个对象都有与知相关的原型，类和可扩展性。可分为普通对象和函数对象。凡是通过 new function() 创建的都是函数对象。其他都是普通对象。</p>\n<h3 id=\"对象直接量\"><a href=\"#对象直接量\" class=\"headerlink\" title=\"对象直接量\"></a>对象直接量</h3><p>对象直接量是类似于 var a = {x:0,y:0} 的映射表。对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候。也会计算它的每个属性值，<strong>也就是说在一个循环体内使用了对象直接量，他将会创建很对新对象，并且每次创建的对象的属性值也有可能不同。</strong></p>\n<h3 id=\"通过-new-创建对象\"><a href=\"#通过-new-创建对象\" class=\"headerlink\" title=\"通过 new 创建对象\"></a>通过 new 创建对象</h3><p>var obj=new MyClass(); new 运算符创建并初始化一个<strong>新对象</strong> 用 new 调用时，this 会指向空的对象，并且这个对象的原型指向 MyClass.prototype</p>\n<h4 id=\"object-creat\"><a href=\"#object-creat\" class=\"headerlink\" title=\"object.creat()\"></a>object.creat()</h4><h2 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h2><p>原型：每一个对象都从原型继承属性。<strong>每个对象都有 <em>proto</em> 属性 , 每个对象都有原对象，但只有函数对象才有 prototype 属性</strong>, 但是除却 function.prototype,function.prototype 也是函数对象，但是没有 prototype。可以使用 p.isPrototype(o) 来检查 p 是否是 o 的原型。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><p>原型模式是 js 对继承的一种实现</p>\n<ul>\n<li><p>prototype：构造函数中的属性，指向该构造函数的原型对象。</p>\n</li>\n<li><p>constructor ：原型对象中的属性，指向该原型对象的构造函数</p>\n</li>\n<li><p><em>proto</em>：实例中的属性，指向 new 这个实例的构造函数的原型对象</p>\n</li>\n</ul>\n<h3 id=\"prototype-属性的引入\"><a href=\"#prototype-属性的引入\" class=\"headerlink\" title=\"prototype 属性的引入\"></a>prototype 属性的引入</h3><p>每一个 new 出的实例都有自己的属性和方法的副本，无法做到属性、方法共享，因此 Brendan Eich 决定为构造函数设置一个 prototype 属性。</p>\n<p>这个对象包含一个对象（以下简称 “prototype 对象 ”），所有实例对象需要共享的属性及方法，都放在这个对象里面，那些不需要共享的属性及方法，就放在构造函数里面。</p>\n<p>实例对象一旦创建，就自动引用 prototype 对象的属性和方法。也就是说。实例对象的属性和方法，分成两种，一种是本地的，一种是引用的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">DOG</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">DOG.prototype = &#123; <span class=\"attr\">species</span>: <span class=\"string\">'犬科'</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> dogA = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'大毛'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> dogB = <span class=\"keyword\">new</span> DOG(<span class=\"string\">'二毛'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">alert(dogA.species)</span><br><span class=\"line\"><span class=\"comment\">// 其实是通过dogA._proto_.species 来访问DOG.prototype.species</span></span><br><span class=\"line\">alert(dogB.species)</span><br><span class=\"line\"><span class=\"comment\">// 犬科</span></span><br><span class=\"line\">DOG.prototype</span><br><span class=\"line\"><span class=\"comment\">//&#123;species:''犬科',constructor:fDOG(name),_proto_:Object&#125;</span></span><br><span class=\"line\">DOG.prototype.constructor === DOG</span><br><span class=\"line\"><span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>现在，species 属性放在 prototype 对象里，是两个实例对象共享的。只要修改了 prototype 对象，就会同时影响到两个实例对象。</p>\n<p><img src=\"/images/prototype/1.png\" alt=\"img caption\"></p>\n<p>以上就是一个简单的 DOG 类完整的原型链。</p>\n<h4 id=\"原型链的作用：对象属性的访问修改和删除。\"><a href=\"#原型链的作用：对象属性的访问修改和删除。\" class=\"headerlink\" title=\"原型链的作用：对象属性的访问修改和删除。\"></a>原型链的作用：对象属性的访问修改和删除。</h4><ul>\n<li>访问。优先在对象本身查找，没有则顺着原型链向上查找</li>\n<li>修改。只能修改跟删除自身属性，不会影响到原型链上的其他对象。</li>\n</ul>\n<h3 id=\"proto-（原型指针）\"><a href=\"#proto-（原型指针）\" class=\"headerlink\" title=\"proto （原型指针）\"></a><em>proto</em> （原型指针）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1.__proto__ == Person.prototype</span><br><span class=\"line\"><span class=\"comment\">//person1.__proto__  = person1.constructor.prototype , person1.constructor = Person</span></span><br><span class=\"line\">Person.__proto__</span><br><span class=\"line\"><span class=\"comment\">//Person.constructor = Function =&gt; Person.__proto__  = Function.prototype</span></span><br><span class=\"line\">Person.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">// Person.prototype 是一个普通对象（原型对象），普通函数的构造函数是Object =&gt; Person.prototype.__proto__ =  Object.prototype</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.__proto__</span><br><span class=\"line\"><span class=\"comment\">//普通对象 同上</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.__proto__</span><br><span class=\"line\"><span class=\"comment\">//对象也有proto属性，但它比较特殊，为null,因为null处于原型链的顶端</span></span><br></pre></td></tr></table></figure>\n<p>JS 在创建对象（不论是普通对象还是函数对象）的时候，都有一个叫做 <em>proto</em> 的内置属性，<strong>用于指向创建它的构造函数的原型对象</strong> ，原型链继承是通过 <em>proto</em> 这个原型指针来完成的</p>\n<h3 id=\"原型链图\"><a href=\"#原型链图\" class=\"headerlink\" title=\"原型链图\"></a>原型链图</h3><p>褐色的线为原型链 <img src=\"/images/prototype/2.png\" alt=\"img caption\"></p>\n<p>够造函数、原型和实例的关系：</p>\n<ol>\n<li>每个构造函数都有一个原型对象（x.prototype)</li>\n<li>原型对象都包含一个指向构造函数的指针（x.prototype.constructor === x)</li>\n<li>实例都包含一个指向原型对象的内部指针（a.<em>proto</em> ）</li>\n</ol>\n<p><strong> 所有函数的默认原型都是 Object 的实例</strong></p>\n<h3 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h3><p>javascript 对象具有 “ 自有属性 ” 也有一些属性是从原型对象继承来的。有两种继承方式：1. 构造函数继承 (call/apply)，2. 原型链继承 ( 挂载到 prototype 属性上面 )。</p>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>创建闭包最常见的方式就是在一个函数内部创建另一个函数。通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。但是，在创建了一个闭包以后，这个函数的作用域就会一直保存到闭包不存在为止。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">4</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'i:'</span> + i)</span><br><span class=\"line\">    ;(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">      setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(e)</span><br><span class=\"line\">      &#125;, <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#125;)(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test() <span class=\"comment\">//i:0 =&gt; i:1 =&gt; i:2=&gt; i:3=&gt;  0 =&gt; 1=&gt; 2 =&gt; 3</span></span><br></pre></td></tr></table></figure>\n<p>循环当中，匿名函数会立即执行，并且会将循环当前的 i 作为参数传入，将其作为当前匿名函数中的形参 e 的指向，即会保存对 i 的引用，它是不会被循环改变的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">makeAdder</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'x:'</span> + x)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'y:'</span> + y)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> add5 = makeAdder(<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"comment\">//x:5 undefined</span></span><br><span class=\"line\">add5</span><br><span class=\"line\"><span class=\"comment\">//f(y)&#123;  console.log('y:' + y) return x + y&#125;</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add10 = makeAdder(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add5(<span class=\"number\">2</span>)) <span class=\"comment\">// y:2 =&gt; 7</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(add10(<span class=\"number\">2</span>)) <span class=\"comment\">// 12</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 释放对闭包的引用</span></span><br><span class=\"line\">add5 = <span class=\"literal\">null</span></span><br><span class=\"line\">add10 = <span class=\"literal\">null</span></span><br></pre></td></tr></table></figure>\n<p>add5 和 add10 都是闭包。他们共享相同的函数定义，但是保存了不同的环境。在 add5 中，x 为 5，在 add10 中，x 则为 10 ，最后通过 null 释放对闭包的引用。</p>\n<p>在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收； 如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。</p>\n<p><strong>闭包只能取得包含函数中任何变量的最后一个值，这是因为闭包所保存的是整个变量对象，而不是某个特殊的变量</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//作用域1</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//作用域2 声明arr[]()</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br><span class=\"line\"><span class=\"comment\">// 毫无疑问连续打印 10 个 10。因为在for循环中 a[i] 为一个函数声明</span></span><br><span class=\"line\"><span class=\"comment\">//1.执行完for之后，在for作用域中i的值为10</span></span><br></pre></td></tr></table></figure>\n<p>改动一下</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = []</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//块2作用域</span></span><br><span class=\"line\">    arr[i] = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//块3作用域</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> i</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//块1作用域</span></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> a = <span class=\"number\">0</span>; a &lt; <span class=\"number\">10</span>; a++) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(arr[a]())</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test() <span class=\"comment\">// 连续打印 0 到 9</span></span><br></pre></td></tr></table></figure>\n<p><strong>实现原因 :</strong></p>\n<ul>\n<li>当用 var 的时候 函数 2 作用域中没有 i 就向函数作用域 1 中去找，而执行到 console.log(arr<a href=\"\">a</a>) 时 i 已经循环完毕，因此 i 全为 10。</li>\n</ul>\n<ul>\n<li>当使用 let 时，每次迭代 i 都被<strong>重新声明</strong>，即每层迭代会生成一个块作用域，并且变量 i 被定义为上一次结算的值。</li>\n<li>var 是函数作用域，for 循环无论执行多少次，都是去最近的函数里面找，而不是块中找，所以只有一个 i，现在的 i 是 10。</li>\n</ul>\n<h3 id=\"闭包中的-this-对象\"><a href=\"#闭包中的-this-对象\" class=\"headerlink\" title=\"闭包中的 this 对象\"></a>闭包中的 this 对象</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'The Window'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'My Object'</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  getName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj.getName()()) <span class=\"comment\">// The Window</span></span><br></pre></td></tr></table></figure>\n<p>obj.getName()() 实际上是在全局作用域中调用了匿名函数，this 指向了 window。这里要理解函数名与函数功能（或者称函数值）是分割开的，不要认为函数在哪里，其内部的 this 就指向哪里。匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。</p>\n<h3 id=\"闭包的应用\"><a href=\"#闭包的应用\" class=\"headerlink\" title=\"闭包的应用\"></a>闭包的应用</h3><p><strong>应用闭包的主要场合是：设计私有的方法和变量。</strong> 闭包的作用：</p>\n<ul>\n<li>访问函数的内部变量</li>\n<li>让被引用的变量值始终保存在内存中</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>) <span class=\"comment\">// undefined</span></span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">3</span>) <span class=\"comment\">// undefined,0,1,2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>) <span class=\"comment\">// undefined,0</span></span><br><span class=\"line\">c.fun(<span class=\"number\">2</span>) <span class=\"comment\">// 1</span></span><br><span class=\"line\">c.fun(<span class=\"number\">3</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(++a)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> fn2 = fn1()</span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出2</span></span><br><span class=\"line\"></span><br><span class=\"line\">fn2() <span class=\"comment\">//输出3</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"call、apply-、-bind\"><a href=\"#call、apply-、-bind\" class=\"headerlink\" title=\"call、apply 、 bind\"></a>call、apply 、 bind</h2><p>参数、绑定规则（显示绑定和强绑定），运行效率（最终都会转换成一个一个的参数去运行）、运行情况（call ， apply 立即执行，bind 是 return 出一个 this “ 固定 ” 的函数，这也是为什么 bind 是强绑定的一个原因）。</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'我是class1内的方法'</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  class1.call(<span class=\"keyword\">this</span>) <span class=\"comment\">//此行代码执行后，当前的this指向了class1（也可以说class2继承了class1）</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> class2()</span><br><span class=\"line\">f.name() <span class=\"comment\">//调用的是class1内的方法，将class1的name方法交给class2使用</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">eat</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x + y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">drink</span>(<span class=\"params\">x, y</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x - y)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">eat.call(drink, <span class=\"number\">3</span>, <span class=\"number\">2</span>) <span class=\"comment\">//5</span></span><br></pre></td></tr></table></figure>\n<p>这个例子中的意思就是用 eat 来替换 drink，eat.call(drink,3,2) == eat(3,2)</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'animal'</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">'dog'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> animal = <span class=\"keyword\">new</span> Animal()</span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog()</span><br><span class=\"line\"></span><br><span class=\"line\">animal.showName.call(dog) <span class=\"comment\">//dog</span></span><br></pre></td></tr></table></figure>\n<p>意思是把 animal 的方法放到 dog 上执行，也可以说，把 animal 的 showName() 方法放到 dog 上来执行，所以 this.name 应该是 dog。</p>\n<h4 id=\"继承-1\"><a href=\"#继承-1\" class=\"headerlink\" title=\"继承\"></a>继承</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Animal</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.showName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Dog</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Animal.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> dog = <span class=\"keyword\">new</span> Dog(<span class=\"string\">'Crazy dog'</span>)</span><br><span class=\"line\">dog.showName()</span><br></pre></td></tr></table></figure>\n<p>Animal.call(this) 的意思就是使用 Animal 对象代替 this 对象，那么 Dog 就能直接调用 Animal 的所有属性和方法。</p>\n<h3 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply\"></a>apply</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class1</span>(<span class=\"params\">args1, args2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(args, args)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">class2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> args1 = <span class=\"string\">'1'</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> args2 = <span class=\"string\">'2'</span></span><br><span class=\"line\">  class1.call(<span class=\"keyword\">this</span>, args1, args2)</span><br><span class=\"line\">  <span class=\"comment\">/*或*/</span></span><br><span class=\"line\">  class1.apply(<span class=\"keyword\">this</span>, [args1, args2])</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = <span class=\"keyword\">new</span> class2()</span><br><span class=\"line\">c.name()</span><br></pre></td></tr></table></figure>\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><p>bind 是在 EcmaScript5 中扩展的方法（IE6,7,8 不支持。</p>\n<p>bind() 方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind() 方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.x)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">  x: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bar()</span><br><span class=\"line\">bar.bind(foo)() <span class=\"comment\">//undefined 3</span></span><br><span class=\"line\"><span class=\"comment\">/*或*/</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> func = bar.bind(foo)</span><br><span class=\"line\">func()</span><br></pre></td></tr></table></figure>"},{"title":"Observable","_content":"\n观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer ）完美的将观察者和被观察的对象分离开。\n\n<!--more-->\n\nObservable 只是一个普通函数，要想让他有所作为，就需要跟 observer 一起使用；而这个 observer（后面我们会介绍）只是一个带有 next、error 、 complete 的简单对象而已。最后，还需要通过 subscribe 订阅来 **启动** Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在 RxJS 里叫 unsubscribe）。\n\n* Observer Pattern - ( 观察者模式 / 发布订阅模式 )\n* Iterator Pattern - ( 迭代器模式 )\n\n这两种模式是 Observable 的基础。\n\n## 观察者模式\n\n一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。\n\nObservables 与 Observer 之间的订阅发布关系 ( 观察者模式 ) 如下：\n\n* 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。\n* 发布：Observable 通过回调 next 方法向 Observer 发布事件。\n\n当 Observable 设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是 DOM 中的 click 事件、input 事件、或者更加复杂的 HTTP 通信。\n\n```javascript\nimport { Component } from '@angular/core'\nimport { Observable, Subscription } from 'rxjs'\n\n@Component({\n  selector: 'app-home',\n  template: `<input type=\"text\"> `\n})\nexport class HomeComponent {\n  ngOnInit() {\n    const node = document.querySelector('input[type=text]')\n\n    // 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入\n    const input$ = Observable.fromEvent(node, 'input')\n    input$.subscribe({\n      next: (event: any) => console.log(`You just typed ${event.target.value}!`),\n      error: err => console.log(`Oops... ${err}`),\n      complete: () => console.log(`Complete!`)\n    })\n  }\n}\n```\n\n**Observable.fromEvent() 会返回一个 Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的 observer 观察者。**\n\n## 一、observer\n\n**subscribe 订阅就是接收一个 observer 方法。**\n\n```javascript\ninput$.subscribe((event: any) => {})\n```\n\n从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当 Observable 产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。\n\n当 Observable 被订阅后，除非调用 observer 的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。\n\nObservable 的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式 operator 来完成的，每一个 operator 都会产生一个新的 Observable。而我们也称这一序列过程为：**流**。\n\n---\n\n## 二、operator\n\nObservable 可以链式写法，这意味着我们可以这样：\n\n```javascript\nObservable.fromEvent(node, 'input')\n  .map((event: any) => event.target.value)\n  .filter(value => value.length >= 2)\n  .subscribe(value => {\n    console.log(value)\n  })\n```\n\n下面是顺序步骤：\n\n* 假设用户输入：a\n* Observable 对触发 oninput 事件作出反应，将值以参数的形式传递给 observer 的 next()。\n* map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个 observer。\n* filter() 如果值长度 >=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个 observer。\n* 最后，将结果传递给 subscribe 订阅块。\n\n#### 取消订阅\n\nObservable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在 Angular 里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在 SPA 世界里懂得擦屁股是一件必须的事。\n\n##### unsubscribe\n\n前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。\n\n```javascript\n    ngOnDestroy() {\n        this.inputSubscription.unsubscribe();\n    }\n```\n\n##### takeWhile\n\n如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：\n\n使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。\n\n```javascript\nprivate alive: boolean = true;\nngOnInit() {\n  const node = document.querySelector('input[type=text]');\n\n  this.s = Observable.fromEvent(node, 'input')\n    .takeWhile(() => this.alive)\n    .map((event: any) => event.target.value)\n    .filter(value => value.length >= 2)\n    .subscribe(value => { console.log(value) });\n}\n\nngOnDestroy() {\n  this.alive = false;\n}\n```\n\n## Subject\n\n我们在写一个 Service 用于数据传递时，总是使用 new Subject。\n\n```javascript\n@Injectable()\nexport class MessageService {\n    private subject = new Subject<any>();\n\n    send(message: any) {\n        this.subject.next(message);\n    }\n\n    get(): Observable<any> {\n        return this.subject.asObservable();\n    }\n}\n```\n\n当 F 组件需要向 M 组件传递数据时，我们可以在 F 组件中使用 send()。\n\n```javascript\n    constructor(public srv: MessageService) { }\n\n    ngOnInit() {\n        this.srv.send('w s k f m?')\n    }\n```\n\n而 M 组件只需要订阅内容就行：\n\n```javascript\n    constructor(private srv: MessageService) {}\n\n    message: any;\n    ngOnInit() {\n        this.srv.get().subscribe((result) => {\n            this.message = result;\n        })\n    }\n```\n\n## EventEmitter\n\n其实 EventEmitter 跟 RxJS 没有直接关系，因为他是 Angular 的产物，而非 RxJS 的东西。或者我们压根没必要去谈，因为 EventEmitter 就是 Subject。\n\n**EventEmitter 的作用是使指令或组件能自定义事件。**\n\n```javascript\n@Output() changed = new EventEmitter<string>();\n\nclick() {\n    this.changed.emit('hi~');\n}\n```\n\n```javascript\n@Component({\n  template: `<comp (changed)=\"subscribe($event)\"></comp>`\n})\nexport class HomeComponent {\n  subscribe(message: string) {\n    // 接收：hi~\n  }\n}\n```\n\n上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。\n\n## 结论\n\n#### 创建数据流：\n\n* 单值：of, empty, never\n* 多值：from\n* 定时：interval, timer\n* 从事件创建：fromEvent\n* 从 Promise 创建：fromPromise\n* 自定义创建：create\n\n#### 转换操作：\n\n* 改变数据形态：map, mapTo, pluck\n* 过滤一些值：filter, skip, first, last, take\n* 时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime\n* 累加：reduce, scan\n* 异常处理：throw, catch, retry, finally\n* 条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn\n* 转接：switch\n\n#### 组合数据流：\n\n* concat ，保持原来的序列顺序连接两个数据流\n* merge，合并序列\n* race，预设条件为其中一个数据流完成\n* forkJoin，预设条件为所有数据流都完成\n* zip，取各来源数据流最后一个值合并为对象\n* combineLatest，取各来源数据流最后一个值合并为数组另，最好使用 $ 结尾的命名方式来表示 Observable，例：input$ 。\n","source":"_posts/Observable.md","raw":"---\ntitle: Observable\ncategories: rx.js\n---\n\n观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer ）完美的将观察者和被观察的对象分离开。\n\n<!--more-->\n\nObservable 只是一个普通函数，要想让他有所作为，就需要跟 observer 一起使用；而这个 observer（后面我们会介绍）只是一个带有 next、error 、 complete 的简单对象而已。最后，还需要通过 subscribe 订阅来 **启动** Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在 RxJS 里叫 unsubscribe）。\n\n* Observer Pattern - ( 观察者模式 / 发布订阅模式 )\n* Iterator Pattern - ( 迭代器模式 )\n\n这两种模式是 Observable 的基础。\n\n## 观察者模式\n\n一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。\n\nObservables 与 Observer 之间的订阅发布关系 ( 观察者模式 ) 如下：\n\n* 订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。\n* 发布：Observable 通过回调 next 方法向 Observer 发布事件。\n\n当 Observable 设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是 DOM 中的 click 事件、input 事件、或者更加复杂的 HTTP 通信。\n\n```javascript\nimport { Component } from '@angular/core'\nimport { Observable, Subscription } from 'rxjs'\n\n@Component({\n  selector: 'app-home',\n  template: `<input type=\"text\"> `\n})\nexport class HomeComponent {\n  ngOnInit() {\n    const node = document.querySelector('input[type=text]')\n\n    // 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入\n    const input$ = Observable.fromEvent(node, 'input')\n    input$.subscribe({\n      next: (event: any) => console.log(`You just typed ${event.target.value}!`),\n      error: err => console.log(`Oops... ${err}`),\n      complete: () => console.log(`Complete!`)\n    })\n  }\n}\n```\n\n**Observable.fromEvent() 会返回一个 Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的 observer 观察者。**\n\n## 一、observer\n\n**subscribe 订阅就是接收一个 observer 方法。**\n\n```javascript\ninput$.subscribe((event: any) => {})\n```\n\n从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当 Observable 产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。\n\n当 Observable 被订阅后，除非调用 observer 的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。\n\nObservable 的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式 operator 来完成的，每一个 operator 都会产生一个新的 Observable。而我们也称这一序列过程为：**流**。\n\n---\n\n## 二、operator\n\nObservable 可以链式写法，这意味着我们可以这样：\n\n```javascript\nObservable.fromEvent(node, 'input')\n  .map((event: any) => event.target.value)\n  .filter(value => value.length >= 2)\n  .subscribe(value => {\n    console.log(value)\n  })\n```\n\n下面是顺序步骤：\n\n* 假设用户输入：a\n* Observable 对触发 oninput 事件作出反应，将值以参数的形式传递给 observer 的 next()。\n* map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个 observer。\n* filter() 如果值长度 >=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个 observer。\n* 最后，将结果传递给 subscribe 订阅块。\n\n#### 取消订阅\n\nObservable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在 Angular 里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在 SPA 世界里懂得擦屁股是一件必须的事。\n\n##### unsubscribe\n\n前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。\n\n```javascript\n    ngOnDestroy() {\n        this.inputSubscription.unsubscribe();\n    }\n```\n\n##### takeWhile\n\n如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：\n\n使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。\n\n```javascript\nprivate alive: boolean = true;\nngOnInit() {\n  const node = document.querySelector('input[type=text]');\n\n  this.s = Observable.fromEvent(node, 'input')\n    .takeWhile(() => this.alive)\n    .map((event: any) => event.target.value)\n    .filter(value => value.length >= 2)\n    .subscribe(value => { console.log(value) });\n}\n\nngOnDestroy() {\n  this.alive = false;\n}\n```\n\n## Subject\n\n我们在写一个 Service 用于数据传递时，总是使用 new Subject。\n\n```javascript\n@Injectable()\nexport class MessageService {\n    private subject = new Subject<any>();\n\n    send(message: any) {\n        this.subject.next(message);\n    }\n\n    get(): Observable<any> {\n        return this.subject.asObservable();\n    }\n}\n```\n\n当 F 组件需要向 M 组件传递数据时，我们可以在 F 组件中使用 send()。\n\n```javascript\n    constructor(public srv: MessageService) { }\n\n    ngOnInit() {\n        this.srv.send('w s k f m?')\n    }\n```\n\n而 M 组件只需要订阅内容就行：\n\n```javascript\n    constructor(private srv: MessageService) {}\n\n    message: any;\n    ngOnInit() {\n        this.srv.get().subscribe((result) => {\n            this.message = result;\n        })\n    }\n```\n\n## EventEmitter\n\n其实 EventEmitter 跟 RxJS 没有直接关系，因为他是 Angular 的产物，而非 RxJS 的东西。或者我们压根没必要去谈，因为 EventEmitter 就是 Subject。\n\n**EventEmitter 的作用是使指令或组件能自定义事件。**\n\n```javascript\n@Output() changed = new EventEmitter<string>();\n\nclick() {\n    this.changed.emit('hi~');\n}\n```\n\n```javascript\n@Component({\n  template: `<comp (changed)=\"subscribe($event)\"></comp>`\n})\nexport class HomeComponent {\n  subscribe(message: string) {\n    // 接收：hi~\n  }\n}\n```\n\n上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。\n\n## 结论\n\n#### 创建数据流：\n\n* 单值：of, empty, never\n* 多值：from\n* 定时：interval, timer\n* 从事件创建：fromEvent\n* 从 Promise 创建：fromPromise\n* 自定义创建：create\n\n#### 转换操作：\n\n* 改变数据形态：map, mapTo, pluck\n* 过滤一些值：filter, skip, first, last, take\n* 时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime\n* 累加：reduce, scan\n* 异常处理：throw, catch, retry, finally\n* 条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn\n* 转接：switch\n\n#### 组合数据流：\n\n* concat ，保持原来的序列顺序连接两个数据流\n* merge，合并序列\n* race，预设条件为其中一个数据流完成\n* forkJoin，预设条件为所有数据流都完成\n* zip，取各来源数据流最后一个值合并为对象\n* combineLatest，取各来源数据流最后一个值合并为数组另，最好使用 $ 结尾的命名方式来表示 Observable，例：input$ 。\n","slug":"Observable","published":1,"date":"2018-03-20T03:29:41.816Z","updated":"2018-03-20T03:29:41.816Z","_id":"cjepksjm600078gv69tjpwpwc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer ）完美的将观察者和被观察的对象分离开。</p>\n<a id=\"more\"></a>\n<p>Observable 只是一个普通函数，要想让他有所作为，就需要跟 observer 一起使用；而这个 observer（后面我们会介绍）只是一个带有 next、error 、 complete 的简单对象而已。最后，还需要通过 subscribe 订阅来 <strong>启动</strong> Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在 RxJS 里叫 unsubscribe）。</p>\n<ul>\n<li>Observer Pattern - ( 观察者模式 / 发布订阅模式 )</li>\n<li>Iterator Pattern - ( 迭代器模式 )</li>\n</ul>\n<p>这两种模式是 Observable 的基础。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>\n<p>Observables 与 Observer 之间的订阅发布关系 ( 观察者模式 ) 如下：</p>\n<ul>\n<li>订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。</li>\n<li>发布：Observable 通过回调 next 方法向 Observer 发布事件。</li>\n</ul>\n<p>当 Observable 设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是 DOM 中的 click 事件、input 事件、或者更加复杂的 HTTP 通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable, Subscription &#125; <span class=\"keyword\">from</span> <span class=\"string\">'rxjs'</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'app-home'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;input type=\"text\"&gt; `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> input$ = Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">    input$.subscribe(&#123;</span><br><span class=\"line\">      next: <span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`You just typed <span class=\"subst\">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class=\"line\">      error: <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Oops... <span class=\"subst\">$&#123;err&#125;</span>`</span>),</span><br><span class=\"line\">      complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Complete!`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Observable.fromEvent() 会返回一个 Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的 observer 观察者。</strong></p>\n<h2 id=\"一、observer\"><a href=\"#一、observer\" class=\"headerlink\" title=\"一、observer\"></a>一、observer</h2><p><strong>subscribe 订阅就是接收一个 observer 方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input$.subscribe(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当 Observable 产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。</p>\n<p>当 Observable 被订阅后，除非调用 observer 的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。</p>\n<p>Observable 的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式 operator 来完成的，每一个 operator 都会产生一个新的 Observable。而我们也称这一序列过程为：<strong>流</strong>。</p>\n<hr>\n<h2 id=\"二、operator\"><a href=\"#二、operator\" class=\"headerlink\" title=\"二、operator\"></a>二、operator</h2><p>Observable 可以链式写法，这意味着我们可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">  .map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">  .filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">  .subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>下面是顺序步骤：</p>\n<ul>\n<li>假设用户输入：a</li>\n<li>Observable 对触发 oninput 事件作出反应，将值以参数的形式传递给 observer 的 next()。</li>\n<li>map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个 observer。</li>\n<li>filter() 如果值长度 &gt;=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个 observer。</li>\n<li>最后，将结果传递给 subscribe 订阅块。</li>\n</ul>\n<h4 id=\"取消订阅\"><a href=\"#取消订阅\" class=\"headerlink\" title=\"取消订阅\"></a>取消订阅</h4><p>Observable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在 Angular 里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在 SPA 世界里懂得擦屁股是一件必须的事。</p>\n<h5 id=\"unsubscribe\"><a href=\"#unsubscribe\" class=\"headerlink\" title=\"unsubscribe\"></a>unsubscribe</h5><p>前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.inputSubscription.unsubscribe();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"takeWhile\"><a href=\"#takeWhile\" class=\"headerlink\" title=\"takeWhile\"></a>takeWhile</h5><p>如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：</p>\n<p>使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private alive: boolean = <span class=\"literal\">true</span>;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.s = Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">    .takeWhile(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.alive)</span><br><span class=\"line\">    .map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    .subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(value) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>我们在写一个 Service 用于数据传递时，总是使用 new Subject。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageService</span> </span>&#123;</span><br><span class=\"line\">    private subject = <span class=\"keyword\">new</span> Subject&lt;any&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    send(message: any) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject.next(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    get(): Observable&lt;any&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subject.asObservable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 F 组件需要向 M 组件传递数据时，我们可以在 F 组件中使用 send()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(public srv: MessageService) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.send(<span class=\"string\">'w s k f m?'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 M 组件只需要订阅内容就行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(private srv: MessageService) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message: any;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.get().subscribe(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = result;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"EventEmitter\"><a href=\"#EventEmitter\" class=\"headerlink\" title=\"EventEmitter\"></a>EventEmitter</h2><p>其实 EventEmitter 跟 RxJS 没有直接关系，因为他是 Angular 的产物，而非 RxJS 的东西。或者我们压根没必要去谈，因为 EventEmitter 就是 Subject。</p>\n<p><strong>EventEmitter 的作用是使指令或组件能自定义事件。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Output() changed = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.changed.emit(<span class=\"string\">'hi~'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;comp (changed)=\"subscribe($event)\"&gt;&lt;/comp&gt;`</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  subscribe(message: string) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收：hi~</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><h4 id=\"创建数据流：\"><a href=\"#创建数据流：\" class=\"headerlink\" title=\"创建数据流：\"></a>创建数据流：</h4><ul>\n<li>单值：of, empty, never</li>\n<li>多值：from</li>\n<li>定时：interval, timer</li>\n<li>从事件创建：fromEvent</li>\n<li>从 Promise 创建：fromPromise</li>\n<li>自定义创建：create</li>\n</ul>\n<h4 id=\"转换操作：\"><a href=\"#转换操作：\" class=\"headerlink\" title=\"转换操作：\"></a>转换操作：</h4><ul>\n<li>改变数据形态：map, mapTo, pluck</li>\n<li>过滤一些值：filter, skip, first, last, take</li>\n<li>时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime</li>\n<li>累加：reduce, scan</li>\n<li>异常处理：throw, catch, retry, finally</li>\n<li>条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn</li>\n<li>转接：switch</li>\n</ul>\n<h4 id=\"组合数据流：\"><a href=\"#组合数据流：\" class=\"headerlink\" title=\"组合数据流：\"></a>组合数据流：</h4><ul>\n<li>concat ，保持原来的序列顺序连接两个数据流</li>\n<li>merge，合并序列</li>\n<li>race，预设条件为其中一个数据流完成</li>\n<li>forkJoin，预设条件为所有数据流都完成</li>\n<li>zip，取各来源数据流最后一个值合并为对象</li>\n<li>combineLatest，取各来源数据流最后一个值合并为数组另，最好使用 $ 结尾的命名方式来表示 Observable，例：input$ 。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>观察者模式又称发布订阅模式，在此种模式中，一个目标物件管理所有相依于它的观察者物件。并且在它本身的状态改变时主动发出通知。观察者模式（Observer ）完美的将观察者和被观察的对象分离开。</p>","more":"<p>Observable 只是一个普通函数，要想让他有所作为，就需要跟 observer 一起使用；而这个 observer（后面我们会介绍）只是一个带有 next、error 、 complete 的简单对象而已。最后，还需要通过 subscribe 订阅来 <strong>启动</strong> Observable；否则它是不会有任何反应；而订阅也会返回一个可用于取消操作（在 RxJS 里叫 unsubscribe）。</p>\n<ul>\n<li>Observer Pattern - ( 观察者模式 / 发布订阅模式 )</li>\n<li>Iterator Pattern - ( 迭代器模式 )</li>\n</ul>\n<p>这两种模式是 Observable 的基础。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>一个目标对象管理所有相依于它的观察者对象，并且在它本身的状态改变时主动发出通知。它定义了一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使得它们能够自动更新自己。</p>\n<p>Observables 与 Observer 之间的订阅发布关系 ( 观察者模式 ) 如下：</p>\n<ul>\n<li>订阅：Observer 通过 Observable 提供的 subscribe() 方法订阅 Observable。</li>\n<li>发布：Observable 通过回调 next 方法向 Observer 发布事件。</li>\n</ul>\n<p>当 Observable 设置观察者后，而连接并获取原始数据的这个过程叫生产者，可能是 DOM 中的 click 事件、input 事件、或者更加复杂的 HTTP 通信。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; Component &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; Observable, Subscription &#125; <span class=\"keyword\">from</span> <span class=\"string\">'rxjs'</span></span><br><span class=\"line\"></span><br><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  selector: <span class=\"string\">'app-home'</span>,</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;input type=\"text\"&gt; `</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 第二个参数 input 是事件名，对于input元素有一个 oninput 事件用于接受用户输入</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> input$ = Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">    input$.subscribe(&#123;</span><br><span class=\"line\">      next: <span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`You just typed <span class=\"subst\">$&#123;event.target.value&#125;</span>!`</span>),</span><br><span class=\"line\">      error: <span class=\"function\"><span class=\"params\">err</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Oops... <span class=\"subst\">$&#123;err&#125;</span>`</span>),</span><br><span class=\"line\">      complete: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"built_in\">console</span>.log(<span class=\"string\">`Complete!`</span>)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Observable.fromEvent() 会返回一个 Observable，并且监听 input 事件，当事件被触发后会发送一个 Event 给对应的 observer 观察者。</strong></p>\n<h2 id=\"一、observer\"><a href=\"#一、observer\" class=\"headerlink\" title=\"一、observer\"></a>一、observer</h2><p><strong>subscribe 订阅就是接收一个 observer 方法。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input$.subscribe(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>\n<p>从语法角度来讲和 subscribe({ next, error, complete }) 是一样的。当 Observable 产生一个新值时，会通知 observer 的 next()，而当捕获失败可以调用 error()。</p>\n<p>当 Observable 被订阅后，除非调用 observer 的 complete() 或 unsubscribe() 取消订阅两情况以外；会一直将值传递给 observer。</p>\n<p>Observable 的生产的值允许经过一序列格式化或操作，最终得到一个有价值的数据给观察者，而这一切是由一序列链式 operator 来完成的，每一个 operator 都会产生一个新的 Observable。而我们也称这一序列过程为：<strong>流</strong>。</p>\n<hr>\n<h2 id=\"二、operator\"><a href=\"#二、operator\" class=\"headerlink\" title=\"二、operator\"></a>二、operator</h2><p>Observable 可以链式写法，这意味着我们可以这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">  .map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">  .filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">  .subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>下面是顺序步骤：</p>\n<ul>\n<li>假设用户输入：a</li>\n<li>Observable 对触发 oninput 事件作出反应，将值以参数的形式传递给 observer 的 next()。</li>\n<li>map() 根据 event.target.value 的内容返回一个新的 Observable，并调用 next() 传递给下一个 observer。</li>\n<li>filter() 如果值长度 &gt;=2 的话，则返回一个新的 Observable，并调用 next() 传递给下一个 observer。</li>\n<li>最后，将结果传递给 subscribe 订阅块。</li>\n</ul>\n<h4 id=\"取消订阅\"><a href=\"#取消订阅\" class=\"headerlink\" title=\"取消订阅\"></a>取消订阅</h4><p>Observable 当有数据产生时才会推送给订阅者，所以它可能会无限次向订阅者推送数据。正因为如此，在 Angular 里面创建组件的时候务必要取消订阅操作，以避免内存泄漏，要知道在 SPA 世界里懂得擦屁股是一件必须的事。</p>\n<h5 id=\"unsubscribe\"><a href=\"#unsubscribe\" class=\"headerlink\" title=\"unsubscribe\"></a>unsubscribe</h5><p>前面示例讲过，调用 subscribe() 后，会返回一个 Subscription 可用于取消操作 unsubscribe()。最合理的方式在 ngOnDestroy 调用它。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.inputSubscription.unsubscribe();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"takeWhile\"><a href=\"#takeWhile\" class=\"headerlink\" title=\"takeWhile\"></a>takeWhile</h5><p>如果组件有很多订阅者的话，则需要将这些订阅者存储在数组中，并组件被销毁时再逐个取消订阅。但，我们有更好的办法：</p>\n<p>使用 takeWhile() operator，它会在你传递一个布尔值是调用 next() 还是 complete()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">private alive: boolean = <span class=\"literal\">true</span>;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> node = <span class=\"built_in\">document</span>.querySelector(<span class=\"string\">'input[type=text]'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.s = Observable.fromEvent(node, <span class=\"string\">'input'</span>)</span><br><span class=\"line\">    .takeWhile(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">this</span>.alive)</span><br><span class=\"line\">    .map(<span class=\"function\">(<span class=\"params\">event: any</span>) =&gt;</span> event.target.value)</span><br><span class=\"line\">    .filter(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value.length &gt;= <span class=\"number\">2</span>)</span><br><span class=\"line\">    .subscribe(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123; <span class=\"built_in\">console</span>.log(value) &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnDestroy() &#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.alive = <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Subject\"><a href=\"#Subject\" class=\"headerlink\" title=\"Subject\"></a>Subject</h2><p>我们在写一个 Service 用于数据传递时，总是使用 new Subject。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Injectable()</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MessageService</span> </span>&#123;</span><br><span class=\"line\">    private subject = <span class=\"keyword\">new</span> Subject&lt;any&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    send(message: any) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.subject.next(message);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    get(): Observable&lt;any&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.subject.asObservable();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>当 F 组件需要向 M 组件传递数据时，我们可以在 F 组件中使用 send()。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(public srv: MessageService) &#123; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.send(<span class=\"string\">'w s k f m?'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>而 M 组件只需要订阅内容就行：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">constructor</span>(private srv: MessageService) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">message: any;</span><br><span class=\"line\">ngOnInit() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.srv.get().subscribe(<span class=\"function\">(<span class=\"params\">result</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.message = result;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"EventEmitter\"><a href=\"#EventEmitter\" class=\"headerlink\" title=\"EventEmitter\"></a>EventEmitter</h2><p>其实 EventEmitter 跟 RxJS 没有直接关系，因为他是 Angular 的产物，而非 RxJS 的东西。或者我们压根没必要去谈，因为 EventEmitter 就是 Subject。</p>\n<p><strong>EventEmitter 的作用是使指令或组件能自定义事件。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Output() changed = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">click() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.changed.emit(<span class=\"string\">'hi~'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component(&#123;</span><br><span class=\"line\">  template: <span class=\"string\">`&lt;comp (changed)=\"subscribe($event)\"&gt;&lt;/comp&gt;`</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeComponent</span> </span>&#123;</span><br><span class=\"line\">  subscribe(message: string) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 接收：hi~</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面示例其实和上一个示例中 MessageService 如出一辙，只不过是将 next() 换成 emit() 仅此而已。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><h4 id=\"创建数据流：\"><a href=\"#创建数据流：\" class=\"headerlink\" title=\"创建数据流：\"></a>创建数据流：</h4><ul>\n<li>单值：of, empty, never</li>\n<li>多值：from</li>\n<li>定时：interval, timer</li>\n<li>从事件创建：fromEvent</li>\n<li>从 Promise 创建：fromPromise</li>\n<li>自定义创建：create</li>\n</ul>\n<h4 id=\"转换操作：\"><a href=\"#转换操作：\" class=\"headerlink\" title=\"转换操作：\"></a>转换操作：</h4><ul>\n<li>改变数据形态：map, mapTo, pluck</li>\n<li>过滤一些值：filter, skip, first, last, take</li>\n<li>时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime</li>\n<li>累加：reduce, scan</li>\n<li>异常处理：throw, catch, retry, finally</li>\n<li>条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn</li>\n<li>转接：switch</li>\n</ul>\n<h4 id=\"组合数据流：\"><a href=\"#组合数据流：\" class=\"headerlink\" title=\"组合数据流：\"></a>组合数据流：</h4><ul>\n<li>concat ，保持原来的序列顺序连接两个数据流</li>\n<li>merge，合并序列</li>\n<li>race，预设条件为其中一个数据流完成</li>\n<li>forkJoin，预设条件为所有数据流都完成</li>\n<li>zip，取各来源数据流最后一个值合并为对象</li>\n<li>combineLatest，取各来源数据流最后一个值合并为数组另，最好使用 $ 结尾的命名方式来表示 Observable，例：input$ 。</li>\n</ul>"},{"title":"PWA 离线缓存","_content":"\n## PWA (Progressive Web App) 特点\n\n1. installability( 可安装性 )，可被添加自主屏与全屏运行。\n2. app shell: 第一次渲染个壳，等异步数据来了在填充。\n3. offline( 离线能力 )：离线和弱网环境也能秒开，server worker 给了 web 一个可以跑后台的线程，它可以搭配非常靠谱的 cache Api 做缓存、可以拦截所有 Http 请求并使用 Fetch API 进行 response ，一个非常完备哦的 proxy 就这么诞生了\n4. re-engageable：推送通知的能力，依赖 service Worker 与 http push，不过默认支持的可是 GCM\n5. 推送是指服务器向服务工作线程提供信息的操作\n6. 通知是指服务工作线程或网页脚本向用户信息的操作。\n\n<!--more-->\n\n## service Worker 有以下功能和特性\n\n* 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n* 一旦被 install，就永远存在，除非被 uninstall\n* 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n* 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n* 离线内容开发者可控\n* 能向客户端推送消息\n* 不能直接操作 DOM\n* 出于安全的考虑，必须在 HTTPS 环境下才能工作\n* 异步实现，内部大都是通过 Promise 实现\n\n### service Worker 前提条件\n\n* 要求 HTTPS 的环境\n* 缓存机制是依赖 cache API 实现的 (cacheStorage)\n* 依赖 HTML5 fetchAPI\n* 依赖 Promise\n\n### 注册\n\n````javascript\n      if ('serviceWorker' in navigator) {\n            navigator.serviceWorker\n                .register('./pwa/sw.js', {scope: '/pwa'})\n                /* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否\n                 已注册，并作出相应的处理*/\n                /* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受\n                 scope指定网域目录上所有事项的fetch事件。\n                 scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能\n                 捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/\n                .then(function (registration) {\n                    console.log('Service Worker 注册成功，域名: ', registration.scope);\n                })\n                .catch(function (err) {\n                    console.log('Service Worker 注册失败: ', err);\n                });\n\n        }\n\n```\n\n### 安装\n\ninstall事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。**install事件一般是被用来填充你的浏览器的离线缓存能力。**为了达到这个目的，我们使用了service worker 新的标志性的存储**cache API** ——一个service worker上的全局对象，**它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key**。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。\n\n```javascript\n    self.addEventListener('install', function (e) {\n        console.log('[ServiceWorker] Install');\n        /*ExtendableEvent.waitUntil():\n         延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。\n         当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，\n         直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/\n        e.waitUntil(\n            caches.open(chache_name).then(function (cache) {\n                console.log('[ServiceWorker] Caching app shell');\n                console.log(cache);\n                return cache.addAll(filesToCache);\n            })\n        );\n    });\n    /*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法\n      这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/\n    /*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,\n      当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，\n      这个数组就是你想缓存的资源的列表*/\n```\n\n### 自定义请求响应\n\n``` javascript\n    self.addEventListener('fetch', function (e) {\n     console.log('[service worker] fetch',e.request.url);\n    /*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/\n        e.resondWith(\n            caches.match(e.request).then(function () {\n                //如果sw有自己的返回，就直接返回，减少一次http请求。\n               if (response) {\n                   return response;\n               }\n\n               //如果没有返回，就直接请求真实远程服务\n                var request = e.request.clone(); //拷贝原始请求\n                //clone()允许多次请求body()对象。\n                return fetch(request).then(function (httpRes) {\n                   //http请求的返回已经抓到，可以进行设置\n\n                    //请求失败，直接返回失败的结果\n                    if(!httpRes||httpRes.status!==200){\n                        return httpRes;\n                    }\n                    //  请求成功，将请求缓存\n                    var responseClone = httpRes.clone();\n                    caches.open(cache_name).then(function (cache) {\n                        cache.put(e.request,responseClone);\n                    });\n                    return httpRes;\n                });\n\n            })\n        );\n\n    });\n    /*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的\n      html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/\n      ```\n\n我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:\n\n- on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。\n- on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。\n\n#### Service Worker 生命周期 （也许翻译的不好，尽量去看原文）\n\n- installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.\n    - 用 **event.waitUntil()** 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。\n    - 用 **self.skipWaiting()** self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。\n- installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。\n- activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。\n- activated:现在可以处理方法事件。\n- message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。\n\n## manifest.json\npwa 添加至桌面的功能实现依赖于manifest.json。\n\n### 基本功能\n- name:{string} 应用名称，用于安装横幅、启动画面显示\n- short_name:{string} 应用短名称，用于主屏幕显示\n- icon:img 应用图标列表，其中包括:\n    - src:{string}  图标URL\n    - type:图标的mime 类型\n    - size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。\n- start_url:{string=} 应用启动地址\n- background_color:{color} css色值\n- display: {string} 显示类型\n    - fullScreen: 应用的显示界面将占满整个屏幕\n    - standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏\n    - minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\n    - browser: 浏览器模式，与普通网页在浏览器中打开的显示一致\n- orientation: string 应用显示方向\n- theme_color: 主题颜色\n\n### 设置作用域\n\n- 如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；\n- **start_url 必须在作用域范围之内**;\n- 如果start_url 为相对地址，其根路径收scope所影响;\n- 如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；\n\n### 添加启动动画\n\n当PWA添加到主屏幕点击打开时，幕后执行了若干操作：\n1. 启动浏览器\n2. 启动显示页面的渲染器\n3. 加载资源\n\n在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。\n\n目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。\n````\n","source":"_posts/PWA-offline.md","raw":"---\ntitle: PWA 离线缓存\ncategories: PWA\n---\n\n## PWA (Progressive Web App) 特点\n\n1. installability( 可安装性 )，可被添加自主屏与全屏运行。\n2. app shell: 第一次渲染个壳，等异步数据来了在填充。\n3. offline( 离线能力 )：离线和弱网环境也能秒开，server worker 给了 web 一个可以跑后台的线程，它可以搭配非常靠谱的 cache Api 做缓存、可以拦截所有 Http 请求并使用 Fetch API 进行 response ，一个非常完备哦的 proxy 就这么诞生了\n4. re-engageable：推送通知的能力，依赖 service Worker 与 http push，不过默认支持的可是 GCM\n5. 推送是指服务器向服务工作线程提供信息的操作\n6. 通知是指服务工作线程或网页脚本向用户信息的操作。\n\n<!--more-->\n\n## service Worker 有以下功能和特性\n\n* 一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。\n* 一旦被 install，就永远存在，除非被 uninstall\n* 需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）\n* 可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）\n* 离线内容开发者可控\n* 能向客户端推送消息\n* 不能直接操作 DOM\n* 出于安全的考虑，必须在 HTTPS 环境下才能工作\n* 异步实现，内部大都是通过 Promise 实现\n\n### service Worker 前提条件\n\n* 要求 HTTPS 的环境\n* 缓存机制是依赖 cache API 实现的 (cacheStorage)\n* 依赖 HTML5 fetchAPI\n* 依赖 Promise\n\n### 注册\n\n````javascript\n      if ('serviceWorker' in navigator) {\n            navigator.serviceWorker\n                .register('./pwa/sw.js', {scope: '/pwa'})\n                /* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否\n                 已注册，并作出相应的处理*/\n                /* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受\n                 scope指定网域目录上所有事项的fetch事件。\n                 scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能\n                 捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/\n                .then(function (registration) {\n                    console.log('Service Worker 注册成功，域名: ', registration.scope);\n                })\n                .catch(function (err) {\n                    console.log('Service Worker 注册失败: ', err);\n                });\n\n        }\n\n```\n\n### 安装\n\ninstall事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。**install事件一般是被用来填充你的浏览器的离线缓存能力。**为了达到这个目的，我们使用了service worker 新的标志性的存储**cache API** ——一个service worker上的全局对象，**它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key**。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。\n\n```javascript\n    self.addEventListener('install', function (e) {\n        console.log('[ServiceWorker] Install');\n        /*ExtendableEvent.waitUntil():\n         延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。\n         当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，\n         直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/\n        e.waitUntil(\n            caches.open(chache_name).then(function (cache) {\n                console.log('[ServiceWorker] Caching app shell');\n                console.log(cache);\n                return cache.addAll(filesToCache);\n            })\n        );\n    });\n    /*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法\n      这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/\n    /*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,\n      当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，\n      这个数组就是你想缓存的资源的列表*/\n```\n\n### 自定义请求响应\n\n``` javascript\n    self.addEventListener('fetch', function (e) {\n     console.log('[service worker] fetch',e.request.url);\n    /*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/\n        e.resondWith(\n            caches.match(e.request).then(function () {\n                //如果sw有自己的返回，就直接返回，减少一次http请求。\n               if (response) {\n                   return response;\n               }\n\n               //如果没有返回，就直接请求真实远程服务\n                var request = e.request.clone(); //拷贝原始请求\n                //clone()允许多次请求body()对象。\n                return fetch(request).then(function (httpRes) {\n                   //http请求的返回已经抓到，可以进行设置\n\n                    //请求失败，直接返回失败的结果\n                    if(!httpRes||httpRes.status!==200){\n                        return httpRes;\n                    }\n                    //  请求成功，将请求缓存\n                    var responseClone = httpRes.clone();\n                    caches.open(cache_name).then(function (cache) {\n                        cache.put(e.request,responseClone);\n                    });\n                    return httpRes;\n                });\n\n            })\n        );\n\n    });\n    /*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的\n      html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/\n      ```\n\n我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:\n\n- on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。\n- on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。\n\n#### Service Worker 生命周期 （也许翻译的不好，尽量去看原文）\n\n- installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.\n    - 用 **event.waitUntil()** 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。\n    - 用 **self.skipWaiting()** self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。\n- installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。\n- activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。\n- activated:现在可以处理方法事件。\n- message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。\n\n## manifest.json\npwa 添加至桌面的功能实现依赖于manifest.json。\n\n### 基本功能\n- name:{string} 应用名称，用于安装横幅、启动画面显示\n- short_name:{string} 应用短名称，用于主屏幕显示\n- icon:img 应用图标列表，其中包括:\n    - src:{string}  图标URL\n    - type:图标的mime 类型\n    - size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。\n- start_url:{string=} 应用启动地址\n- background_color:{color} css色值\n- display: {string} 显示类型\n    - fullScreen: 应用的显示界面将占满整个屏幕\n    - standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏\n    - minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\n    - browser: 浏览器模式，与普通网页在浏览器中打开的显示一致\n- orientation: string 应用显示方向\n- theme_color: 主题颜色\n\n### 设置作用域\n\n- 如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；\n- **start_url 必须在作用域范围之内**;\n- 如果start_url 为相对地址，其根路径收scope所影响;\n- 如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；\n\n### 添加启动动画\n\n当PWA添加到主屏幕点击打开时，幕后执行了若干操作：\n1. 启动浏览器\n2. 启动显示页面的渲染器\n3. 加载资源\n\n在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。\n\n目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。\n````\n","slug":"PWA-offline","published":1,"date":"2018-03-12T15:29:22.786Z","updated":"2018-03-12T15:29:22.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjm800088gv6ifrjwfpk","content":"<h2 id=\"PWA-Progressive-Web-App-特点\"><a href=\"#PWA-Progressive-Web-App-特点\" class=\"headerlink\" title=\"PWA (Progressive Web App) 特点\"></a>PWA (Progressive Web App) 特点</h2><ol>\n<li>installability( 可安装性 )，可被添加自主屏与全屏运行。</li>\n<li>app shell: 第一次渲染个壳，等异步数据来了在填充。</li>\n<li>offline( 离线能力 )：离线和弱网环境也能秒开，server worker 给了 web 一个可以跑后台的线程，它可以搭配非常靠谱的 cache Api 做缓存、可以拦截所有 Http 请求并使用 Fetch API 进行 response ，一个非常完备哦的 proxy 就这么诞生了</li>\n<li>re-engageable：推送通知的能力，依赖 service Worker 与 http push，不过默认支持的可是 GCM</li>\n<li>推送是指服务器向服务工作线程提供信息的操作</li>\n<li>通知是指服务工作线程或网页脚本向用户信息的操作。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"service-Worker-有以下功能和特性\"><a href=\"#service-Worker-有以下功能和特性\" class=\"headerlink\" title=\"service Worker 有以下功能和特性\"></a>service Worker 有以下功能和特性</h2><ul>\n<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>\n<li>一旦被 install，就永远存在，除非被 uninstall</li>\n<li>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</li>\n<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</li>\n<li>离线内容开发者可控</li>\n<li>能向客户端推送消息</li>\n<li>不能直接操作 DOM</li>\n<li>出于安全的考虑，必须在 HTTPS 环境下才能工作</li>\n<li>异步实现，内部大都是通过 Promise 实现</li>\n</ul>\n<h3 id=\"service-Worker-前提条件\"><a href=\"#service-Worker-前提条件\" class=\"headerlink\" title=\"service Worker 前提条件\"></a>service Worker 前提条件</h3><ul>\n<li>要求 HTTPS 的环境</li>\n<li>缓存机制是依赖 cache API 实现的 (cacheStorage)</li>\n<li>依赖 HTML5 fetchAPI</li>\n<li>依赖 Promise</li>\n</ul>\n<h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">            navigator.serviceWorker</span><br><span class=\"line\">                .register(<span class=\"string\">'./pwa/sw.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'/pwa'</span>&#125;)</span><br><span class=\"line\">                <span class=\"comment\">/* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否</span></span><br><span class=\"line\"><span class=\"comment\">                 已注册，并作出相应的处理*/</span></span><br><span class=\"line\">                <span class=\"comment\">/* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受</span></span><br><span class=\"line\"><span class=\"comment\">                 scope指定网域目录上所有事项的fetch事件。</span></span><br><span class=\"line\"><span class=\"comment\">                 scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能</span></span><br><span class=\"line\"><span class=\"comment\">                 捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册成功，域名: '</span>, registration.scope);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册失败: '</span>, err);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 安装</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">install事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。**install事件一般是被用来填充你的浏览器的离线缓存能力。**为了达到这个目的，我们使用了service worker 新的标志性的存储**cache API** ——一个service worker上的全局对象，**它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key**。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">    self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Install'</span>);</span><br><span class=\"line\">        <span class=\"comment\">/*ExtendableEvent.waitUntil():</span></span><br><span class=\"line\"><span class=\"comment\">         延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。</span></span><br><span class=\"line\"><span class=\"comment\">         当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，</span></span><br><span class=\"line\"><span class=\"comment\">         直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/</span></span><br><span class=\"line\">        e.waitUntil(</span><br><span class=\"line\">            caches.open(chache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Caching app shell'</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(cache);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cache.addAll(filesToCache);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">/*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法</span></span><br><span class=\"line\"><span class=\"comment\">      这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,</span></span><br><span class=\"line\"><span class=\"comment\">      当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，</span></span><br><span class=\"line\"><span class=\"comment\">      这个数组就是你想缓存的资源的列表*/</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 自定义请求响应</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</span><br><span class=\"line\">    self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">'[service worker] fetch'</span>,e.request.url);</span><br><span class=\"line\">    <span class=\"comment\">/*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/</span></span><br><span class=\"line\">        e.resondWith(</span><br><span class=\"line\">            caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果sw有自己的返回，就直接返回，减少一次http请求。</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (response) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">//如果没有返回，就直接请求真实远程服务</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> request = e.request.clone(); <span class=\"comment\">//拷贝原始请求</span></span><br><span class=\"line\">                <span class=\"comment\">//clone()允许多次请求body()对象。</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> fetch(request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">httpRes</span>) </span>&#123;</span><br><span class=\"line\">                   <span class=\"comment\">//http请求的返回已经抓到，可以进行设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//请求失败，直接返回失败的结果</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!httpRes||httpRes.status!==<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//  请求成功，将请求缓存</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> responseClone = httpRes.clone();</span><br><span class=\"line\">                    caches.open(cache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                        cache.put(e.request,responseClone);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">/*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的</span></span><br><span class=\"line\"><span class=\"comment\">      html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/</span></span><br><span class=\"line\">      <span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。</span></span><br><span class=\"line\"><span class=\"string\">- on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### Service Worker 生命周期 （也许翻译的不好，尽量去看原文）</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.</span></span><br><span class=\"line\"><span class=\"string\">    - 用 **event.waitUntil()** 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。</span></span><br><span class=\"line\"><span class=\"string\">    - 用 **self.skipWaiting()** self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。</span></span><br><span class=\"line\"><span class=\"string\">- installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。</span></span><br><span class=\"line\"><span class=\"string\">- activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。</span></span><br><span class=\"line\"><span class=\"string\">- activated:现在可以处理方法事件。</span></span><br><span class=\"line\"><span class=\"string\">- message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## manifest.json</span></span><br><span class=\"line\"><span class=\"string\">pwa 添加至桌面的功能实现依赖于manifest.json。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 基本功能</span></span><br><span class=\"line\"><span class=\"string\">- name:&#123;string&#125; 应用名称，用于安装横幅、启动画面显示</span></span><br><span class=\"line\"><span class=\"string\">- short_name:&#123;string&#125; 应用短名称，用于主屏幕显示</span></span><br><span class=\"line\"><span class=\"string\">- icon:img 应用图标列表，其中包括:</span></span><br><span class=\"line\"><span class=\"string\">    - src:&#123;string&#125;  图标URL</span></span><br><span class=\"line\"><span class=\"string\">    - type:图标的mime 类型</span></span><br><span class=\"line\"><span class=\"string\">    - size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。</span></span><br><span class=\"line\"><span class=\"string\">- start_url:&#123;string=&#125; 应用启动地址</span></span><br><span class=\"line\"><span class=\"string\">- background_color:&#123;color&#125; css色值</span></span><br><span class=\"line\"><span class=\"string\">- display: &#123;string&#125; 显示类型</span></span><br><span class=\"line\"><span class=\"string\">    - fullScreen: 应用的显示界面将占满整个屏幕</span></span><br><span class=\"line\"><span class=\"string\">    - standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏</span></span><br><span class=\"line\"><span class=\"string\">    - minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同</span></span><br><span class=\"line\"><span class=\"string\">    - browser: 浏览器模式，与普通网页在浏览器中打开的显示一致</span></span><br><span class=\"line\"><span class=\"string\">- orientation: string 应用显示方向</span></span><br><span class=\"line\"><span class=\"string\">- theme_color: 主题颜色</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 设置作用域</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；</span></span><br><span class=\"line\"><span class=\"string\">- **start_url 必须在作用域范围之内**;</span></span><br><span class=\"line\"><span class=\"string\">- 如果start_url 为相对地址，其根路径收scope所影响;</span></span><br><span class=\"line\"><span class=\"string\">- 如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 添加启动动画</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">当PWA添加到主屏幕点击打开时，幕后执行了若干操作：</span></span><br><span class=\"line\"><span class=\"string\">1. 启动浏览器</span></span><br><span class=\"line\"><span class=\"string\">2. 启动显示页面的渲染器</span></span><br><span class=\"line\"><span class=\"string\">3. 加载资源</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"PWA-Progressive-Web-App-特点\"><a href=\"#PWA-Progressive-Web-App-特点\" class=\"headerlink\" title=\"PWA (Progressive Web App) 特点\"></a>PWA (Progressive Web App) 特点</h2><ol>\n<li>installability( 可安装性 )，可被添加自主屏与全屏运行。</li>\n<li>app shell: 第一次渲染个壳，等异步数据来了在填充。</li>\n<li>offline( 离线能力 )：离线和弱网环境也能秒开，server worker 给了 web 一个可以跑后台的线程，它可以搭配非常靠谱的 cache Api 做缓存、可以拦截所有 Http 请求并使用 Fetch API 进行 response ，一个非常完备哦的 proxy 就这么诞生了</li>\n<li>re-engageable：推送通知的能力，依赖 service Worker 与 http push，不过默认支持的可是 GCM</li>\n<li>推送是指服务器向服务工作线程提供信息的操作</li>\n<li>通知是指服务工作线程或网页脚本向用户信息的操作。</li>\n</ol>","more":"<h2 id=\"service-Worker-有以下功能和特性\"><a href=\"#service-Worker-有以下功能和特性\" class=\"headerlink\" title=\"service Worker 有以下功能和特性\"></a>service Worker 有以下功能和特性</h2><ul>\n<li>一个独立的 worker 线程，独立于当前网页进程，有自己独立的 worker context。</li>\n<li>一旦被 install，就永远存在，除非被 uninstall</li>\n<li>需要的时候可以直接唤醒，不需要的时候自动睡眠（有效利用资源，此处有坑）</li>\n<li>可编程拦截代理请求和返回，缓存文件，缓存的文件可以被网页进程取到（包括网络离线状态）</li>\n<li>离线内容开发者可控</li>\n<li>能向客户端推送消息</li>\n<li>不能直接操作 DOM</li>\n<li>出于安全的考虑，必须在 HTTPS 环境下才能工作</li>\n<li>异步实现，内部大都是通过 Promise 实现</li>\n</ul>\n<h3 id=\"service-Worker-前提条件\"><a href=\"#service-Worker-前提条件\" class=\"headerlink\" title=\"service Worker 前提条件\"></a>service Worker 前提条件</h3><ul>\n<li>要求 HTTPS 的环境</li>\n<li>缓存机制是依赖 cache API 实现的 (cacheStorage)</li>\n<li>依赖 HTML5 fetchAPI</li>\n<li>依赖 Promise</li>\n</ul>\n<h3 id=\"注册\"><a href=\"#注册\" class=\"headerlink\" title=\"注册\"></a>注册</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator) &#123;</span><br><span class=\"line\">            navigator.serviceWorker</span><br><span class=\"line\">                .register(<span class=\"string\">'./pwa/sw.js'</span>, &#123;<span class=\"attr\">scope</span>: <span class=\"string\">'/pwa'</span>&#125;)</span><br><span class=\"line\">                <span class=\"comment\">/* 每次页面加载成功后，就会调用register()方法。浏览器会判断service Worker线程是否</span></span><br><span class=\"line\"><span class=\"comment\">                 已注册，并作出相应的处理*/</span></span><br><span class=\"line\">                <span class=\"comment\">/* scope 方法是可选的，用于指定你想让service worker 控制内容的子目录。service worker 线程将接受</span></span><br><span class=\"line\"><span class=\"comment\">                 scope指定网域目录上所有事项的fetch事件。</span></span><br><span class=\"line\"><span class=\"comment\">                 scope的意义在于如果sw.js在/a/b/sw.js下，那么scope默认是/a/b,那么service worker 线程只能</span></span><br><span class=\"line\"><span class=\"comment\">                 捕捉到path为/a/b开头的（/a/b/page1,/a/b/page2,..)下的fetch事件*/</span></span><br><span class=\"line\">                .then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">registration</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册成功，域名: '</span>, registration.scope);</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">                .catch(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">err</span>) </span>&#123;</span><br><span class=\"line\">                    <span class=\"built_in\">console</span>.log(<span class=\"string\">'Service Worker 注册失败: '</span>, err);</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 安装</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">install事件我们会绑定在service worker 文件中，在service worker 安装成功后，install事件被触发。**install事件一般是被用来填充你的浏览器的离线缓存能力。**为了达到这个目的，我们使用了service worker 新的标志性的存储**cache API** ——一个service worker上的全局对象，**它使我们可以存储网络响应发来的资源，并且根据他们的请求来生成key**。这个 API 和浏览器的标准的缓存工作原理很相似，但是是只对应你的站点的域的。它会一直持久存在，直到你告诉它不再存储，你拥有全部的控制权。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">    self.addEventListener(<span class=\"string\">'install'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Install'</span>);</span><br><span class=\"line\">        <span class=\"comment\">/*ExtendableEvent.waitUntil():</span></span><br><span class=\"line\"><span class=\"comment\">         延长了时间的生命周期。在服务工作中，延长事件的生命周期阻止浏览器在事件中的一部操作完成之前终止service worker。</span></span><br><span class=\"line\"><span class=\"comment\">         当在与安装事件相关联的EventHandler中调用时，它会延时将已安装的工作程序视为安装，</span></span><br><span class=\"line\"><span class=\"comment\">         直到传递的promise成功解析为止。这主要用于确保service worker在其依赖的所有核心高速缓存填充之前不会被考虑安装*/</span></span><br><span class=\"line\">        e.waitUntil(</span><br><span class=\"line\">            caches.open(chache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(<span class=\"string\">'[ServiceWorker] Caching app shell'</span>);</span><br><span class=\"line\">                <span class=\"built_in\">console</span>.log(cache);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> cache.addAll(filesToCache);</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        );</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">/*这里我们新增了install 事件监听器，接着在事件上接了一个ExtendableEvent.waitUntil()方法</span></span><br><span class=\"line\"><span class=\"comment\">      这会确保service worker不会在waitUntil()里面的代码执行完毕之前安装完成*/</span></span><br><span class=\"line\">    <span class=\"comment\">/*我们使用caches.open()方法创建了一个yu的新缓存，将会是我们站点资源的缓存的第一个版本。它返回了一个创建缓存的promise,</span></span><br><span class=\"line\"><span class=\"comment\">      当它resolved 的时候，我们接着会调用在创建的缓存上的一个方法addALL()，这个方法的参数是一个由一组相对于origin的URL组成的数组，</span></span><br><span class=\"line\"><span class=\"comment\">      这个数组就是你想缓存的资源的列表*/</span></span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 自定义请求响应</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span> javascript</span><br><span class=\"line\">    self.addEventListener(<span class=\"string\">'fetch'</span>, <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(<span class=\"string\">'[service worker] fetch'</span>,e.request.url);</span><br><span class=\"line\">    <span class=\"comment\">/*respondWith()方法旨在包裹代码，这些代码为来自受控页面的request生成的自定义的response。用来劫持我们的http响应*/</span></span><br><span class=\"line\">        e.resondWith(</span><br><span class=\"line\">            caches.match(e.request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//如果sw有自己的返回，就直接返回，减少一次http请求。</span></span><br><span class=\"line\">               <span class=\"keyword\">if</span> (response) &#123;</span><br><span class=\"line\">                   <span class=\"keyword\">return</span> response;</span><br><span class=\"line\">               &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">               <span class=\"comment\">//如果没有返回，就直接请求真实远程服务</span></span><br><span class=\"line\">                <span class=\"keyword\">var</span> request = e.request.clone(); <span class=\"comment\">//拷贝原始请求</span></span><br><span class=\"line\">                <span class=\"comment\">//clone()允许多次请求body()对象。</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> fetch(request).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">httpRes</span>) </span>&#123;</span><br><span class=\"line\">                   <span class=\"comment\">//http请求的返回已经抓到，可以进行设置</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//请求失败，直接返回失败的结果</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!httpRes||httpRes.status!==<span class=\"number\">200</span>)&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"comment\">//  请求成功，将请求缓存</span></span><br><span class=\"line\">                    <span class=\"keyword\">var</span> responseClone = httpRes.clone();</span><br><span class=\"line\">                    caches.open(cache_name).then(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">cache</span>) </span>&#123;</span><br><span class=\"line\">                        cache.put(e.request,responseClone);</span><br><span class=\"line\">                    &#125;);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> httpRes;</span><br><span class=\"line\">                &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        );</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"comment\">/*每次任何被service worker 控制的资源被请求到时，都会触发fetch事件，这些资源包括了指定的scope内的</span></span><br><span class=\"line\"><span class=\"comment\">      html 文档，和这些html文档内引用的其他任何资源（比如index.html发起了一个跨域的请求来嵌入一张图片，这个也会通过service worker*/</span></span><br><span class=\"line\">      <span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">我们可以在install 的时候进行静态资源缓存。也可以通过fetch事件回调来代理页面请求从而实现动态资源缓存:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- on install 的优点是第二次访问就可以离线访问，缺点是需要缓存的URL在编译时插入到脚本中，增加代码量和降低可维护性。</span></span><br><span class=\"line\"><span class=\"string\">- on fetch 的优点是无需变更编译过程，也不会产生额外的流量，缺点是需要多一次访问才能离线访问。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">#### Service Worker 生命周期 （也许翻译的不好，尽量去看原文）</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- installing: 这一阶段标志着开始注册。它想要允许设置worker-specific 的资源,例如离线模式的caches.</span></span><br><span class=\"line\"><span class=\"string\">    - 用 **event.waitUntil()** 通过一个promise 去延长安装service worker阶段直到e.waitUntil()里的代码执行完毕。如果所有资源安装成功缓存则安装成功，否则安装失败，则无法激活service worker。</span></span><br><span class=\"line\"><span class=\"string\">    - 用 **self.skipWaiting()** self 是当前context 的 global 变量。强制当前处于waiting 状态的脚本进入activate状态。</span></span><br><span class=\"line\"><span class=\"string\">- installed:service worker 已经完成了它的安装，在等待其他service Workers 线程被关闭。</span></span><br><span class=\"line\"><span class=\"string\">- activating: 这时没有被其他workers 控制的客户端。这个阶段允许workers 去完成安装并且清理其他 worker以及关联缓存的就缓存资源，等待新的service worker线程被激活。</span></span><br><span class=\"line\"><span class=\"string\">- activated:现在可以处理方法事件。</span></span><br><span class=\"line\"><span class=\"string\">- message: service worker 运行于独立context 中，无法直接访问当前页面主线程的DOM信息，但是通过postMessageAPI ,可以实现他们之间的消息传递，这样主线程就可以接受service worker 的指令操作DOM。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">## manifest.json</span></span><br><span class=\"line\"><span class=\"string\">pwa 添加至桌面的功能实现依赖于manifest.json。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 基本功能</span></span><br><span class=\"line\"><span class=\"string\">- name:&#123;string&#125; 应用名称，用于安装横幅、启动画面显示</span></span><br><span class=\"line\"><span class=\"string\">- short_name:&#123;string&#125; 应用短名称，用于主屏幕显示</span></span><br><span class=\"line\"><span class=\"string\">- icon:img 应用图标列表，其中包括:</span></span><br><span class=\"line\"><span class=\"string\">    - src:&#123;string&#125;  图标URL</span></span><br><span class=\"line\"><span class=\"string\">    - type:图标的mime 类型</span></span><br><span class=\"line\"><span class=\"string\">    - size:图标尺寸。当PWA添加到主屏幕时，浏览器会根据有效图标的size 字段进行选择，如果匹配到的图标路径错误，将会显示浏览器默认icon。</span></span><br><span class=\"line\"><span class=\"string\">- start_url:&#123;string=&#125; 应用启动地址</span></span><br><span class=\"line\"><span class=\"string\">- background_color:&#123;color&#125; css色值</span></span><br><span class=\"line\"><span class=\"string\">- display: &#123;string&#125; 显示类型</span></span><br><span class=\"line\"><span class=\"string\">    - fullScreen: 应用的显示界面将占满整个屏幕</span></span><br><span class=\"line\"><span class=\"string\">    - standalone: 浏览器相关UI（导航栏、工具栏等）将会被隐藏</span></span><br><span class=\"line\"><span class=\"string\">    - minimal-ui: 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同</span></span><br><span class=\"line\"><span class=\"string\">    - browser: 浏览器模式，与普通网页在浏览器中打开的显示一致</span></span><br><span class=\"line\"><span class=\"string\">- orientation: string 应用显示方向</span></span><br><span class=\"line\"><span class=\"string\">- theme_color: 主题颜色</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 设置作用域</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 如果没有在manifest中设置scope，则默认的作用域为manifest.json所在的文件夹；</span></span><br><span class=\"line\"><span class=\"string\">- **start_url 必须在作用域范围之内**;</span></span><br><span class=\"line\"><span class=\"string\">- 如果start_url 为相对地址，其根路径收scope所影响;</span></span><br><span class=\"line\"><span class=\"string\">- 如果start_url 为绝对地址（以/开头）,则该地址将永远以/作为跟地址；</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 添加启动动画</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">当PWA添加到主屏幕点击打开时，幕后执行了若干操作：</span></span><br><span class=\"line\"><span class=\"string\">1. 启动浏览器</span></span><br><span class=\"line\"><span class=\"string\">2. 启动显示页面的渲染器</span></span><br><span class=\"line\"><span class=\"string\">3. 加载资源</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">在这个过程中，由于页面未加载完毕，因此屏幕将显示空白并且看似停滞。如果是从网络加载的页面资源，白屏过程将会变得更加明显。因此 PWA 提供了启动画面功能，用标题、颜色和图像组成的画面来替代白屏，提升用户体验。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">目前，如果修改了manifest.json 的应用的名称，已经添加到主屏幕的名称并不会改变，只有当用户重新添加到桌面时，更改后的名称才会显示出来。但是未来版本的chrome 支持自动更新。</span></span><br></pre></td></tr></table></figure>"},{"title":"PWA-pushMessage","comments":1,"_content":"\n## 消息推送介绍\n\n消息推送通知目前整体支持度并不高，在手机端更只有安卓 chrome57 支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。都是通过 serviceWorker 去实现的。\n\n<!--more-->\n\n基本原理是，你的客户端和推送服务进行绑定，会生成一个绑定后的推送服务 API 接口，服务端调用此接口，发送消息。同时浏览器也需要支持这个功能，在注册 sw 时，加上推送功能的判断。\n\n```javascript\nif ('serviceWorker' in navigator && 'PushManager' in window) {\n  navigator.serviceWorker\n    .register(sw.js)\n    .then(function(swReg) {\n      swRegistration = swReg\n    })\n    .catch(function(error) {\n      console.error('Service Worker Error', error)\n    })\n} else {\n  console.warn('Push messaging is not supported')\n}\n```\n\nPushManager 注册好之后，那么要做的就是浏览器和服务器的绑定了。\n\n## 获取授权\n\n* 在订阅之前先获取用户授权，\\*\\* 使用 Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。\n* 如果不选择 1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。\n* <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。\n* <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\">push API</a> 允许 web 应用程序接受从服务器推送到它们的消息的能力，无论 WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。\n\n## 订阅消息的具体实现\n\n* 在订阅之前先获取用户授权\n* 使用 pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。\n  * userVisibleOnly, 不允许静默的推出，所有推出都对用户可见，所以值为 true\n  * applicationServerKey, 服务器生成的公钥\n* 得到推送服务成功响应后，浏览器将推送服务返回的 endpoint 加入推送订阅对象，向服务器发送这个对象供其存储。\n\n消息推送的安全性 :\n\n* 推送服务确保调用来自可靠的服务端。\n* 推送消息内容只有浏览器能够解密，就算是推送服务也不行\n\n## 使用 web-push 服务器发送信息\n\n 这是谷歌自己实现的一个推送功能的服务器\n \n服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用 web-push 可以解决大部分问题。\n\n* 使用 web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的 applicationServerKey 吗，我们需要公钥 publicKey 传递到订阅脚本所在的页面中。。\n* 调用 setVapidDetails 为 web-push 设置生成的公私钥。\n* 之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。\n* 调用 sendNotification 向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。\n* 所有推送服务都遵循同意的调用标准，**所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。**\n\n## 推送服务的响应\n\n* 429 too many requests\n* 400 invalid request\n* 404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。\n* 410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的 unsubscribe() 方法\n* 413 Payload size too large\n","source":"_posts/PWA-pushMessage.md","raw":"---\ntitle: PWA-pushMessage\ncategories: PWA\ncomments: true\n---\n\n## 消息推送介绍\n\n消息推送通知目前整体支持度并不高，在手机端更只有安卓 chrome57 支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。都是通过 serviceWorker 去实现的。\n\n<!--more-->\n\n基本原理是，你的客户端和推送服务进行绑定，会生成一个绑定后的推送服务 API 接口，服务端调用此接口，发送消息。同时浏览器也需要支持这个功能，在注册 sw 时，加上推送功能的判断。\n\n```javascript\nif ('serviceWorker' in navigator && 'PushManager' in window) {\n  navigator.serviceWorker\n    .register(sw.js)\n    .then(function(swReg) {\n      swRegistration = swReg\n    })\n    .catch(function(error) {\n      console.error('Service Worker Error', error)\n    })\n} else {\n  console.warn('Push messaging is not supported')\n}\n```\n\nPushManager 注册好之后，那么要做的就是浏览器和服务器的绑定了。\n\n## 获取授权\n\n* 在订阅之前先获取用户授权，\\*\\* 使用 Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。\n* 如果不选择 1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。\n* <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。\n* <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\">push API</a> 允许 web 应用程序接受从服务器推送到它们的消息的能力，无论 WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。\n\n## 订阅消息的具体实现\n\n* 在订阅之前先获取用户授权\n* 使用 pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。\n  * userVisibleOnly, 不允许静默的推出，所有推出都对用户可见，所以值为 true\n  * applicationServerKey, 服务器生成的公钥\n* 得到推送服务成功响应后，浏览器将推送服务返回的 endpoint 加入推送订阅对象，向服务器发送这个对象供其存储。\n\n消息推送的安全性 :\n\n* 推送服务确保调用来自可靠的服务端。\n* 推送消息内容只有浏览器能够解密，就算是推送服务也不行\n\n## 使用 web-push 服务器发送信息\n\n 这是谷歌自己实现的一个推送功能的服务器\n \n服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用 web-push 可以解决大部分问题。\n\n* 使用 web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的 applicationServerKey 吗，我们需要公钥 publicKey 传递到订阅脚本所在的页面中。。\n* 调用 setVapidDetails 为 web-push 设置生成的公私钥。\n* 之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。\n* 调用 sendNotification 向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。\n* 所有推送服务都遵循同意的调用标准，**所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。**\n\n## 推送服务的响应\n\n* 429 too many requests\n* 400 invalid request\n* 404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。\n* 410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的 unsubscribe() 方法\n* 413 Payload size too large\n","slug":"PWA-pushMessage","published":1,"date":"2018-03-12T15:29:22.786Z","updated":"2018-03-12T15:29:22.787Z","layout":"post","photos":[],"link":"","_id":"cjepksjmc000b8gv6iv7jxqwd","content":"<h2 id=\"消息推送介绍\"><a href=\"#消息推送介绍\" class=\"headerlink\" title=\"消息推送介绍\"></a>消息推送介绍</h2><p>消息推送通知目前整体支持度并不高，在手机端更只有安卓 chrome57 支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。都是通过 serviceWorker 去实现的。</p>\n<a id=\"more\"></a>\n<p>基本原理是，你的客户端和推送服务进行绑定，会生成一个绑定后的推送服务 API 接口，服务端调用此接口，发送消息。同时浏览器也需要支持这个功能，在注册 sw 时，加上推送功能的判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator &amp;&amp; <span class=\"string\">'PushManager'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>) &#123;</span><br><span class=\"line\">  navigator.serviceWorker</span><br><span class=\"line\">    .register(sw.js)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">swReg</span>) </span>&#123;</span><br><span class=\"line\">      swRegistration = swReg</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'Service Worker Error'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.warn(<span class=\"string\">'Push messaging is not supported'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PushManager 注册好之后，那么要做的就是浏览器和服务器的绑定了。</p>\n<h2 id=\"获取授权\"><a href=\"#获取授权\" class=\"headerlink\" title=\"获取授权\"></a>获取授权</h2><ul>\n<li>在订阅之前先获取用户授权，** 使用 Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。</li>\n<li>如果不选择 1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\" target=\"_blank\" rel=\"noopener\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\" target=\"_blank\" rel=\"noopener\">push API</a> 允许 web 应用程序接受从服务器推送到它们的消息的能力，无论 WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。</li>\n</ul>\n<h2 id=\"订阅消息的具体实现\"><a href=\"#订阅消息的具体实现\" class=\"headerlink\" title=\"订阅消息的具体实现\"></a>订阅消息的具体实现</h2><ul>\n<li>在订阅之前先获取用户授权</li>\n<li>使用 pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。<ul>\n<li>userVisibleOnly, 不允许静默的推出，所有推出都对用户可见，所以值为 true</li>\n<li>applicationServerKey, 服务器生成的公钥</li>\n</ul>\n</li>\n<li>得到推送服务成功响应后，浏览器将推送服务返回的 endpoint 加入推送订阅对象，向服务器发送这个对象供其存储。</li>\n</ul>\n<p>消息推送的安全性 :</p>\n<ul>\n<li>推送服务确保调用来自可靠的服务端。</li>\n<li>推送消息内容只有浏览器能够解密，就算是推送服务也不行</li>\n</ul>\n<h2 id=\"使用-web-push-服务器发送信息\"><a href=\"#使用-web-push-服务器发送信息\" class=\"headerlink\" title=\"使用 web-push 服务器发送信息\"></a>使用 web-push 服务器发送信息</h2><p> 这是谷歌自己实现的一个推送功能的服务器</p>\n<p>服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用 web-push 可以解决大部分问题。</p>\n<ul>\n<li>使用 web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的 applicationServerKey 吗，我们需要公钥 publicKey 传递到订阅脚本所在的页面中。。</li>\n<li>调用 setVapidDetails 为 web-push 设置生成的公私钥。</li>\n<li>之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。</li>\n<li>调用 sendNotification 向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。</li>\n<li>所有推送服务都遵循同意的调用标准，<strong>所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。</strong></li>\n</ul>\n<h2 id=\"推送服务的响应\"><a href=\"#推送服务的响应\" class=\"headerlink\" title=\"推送服务的响应\"></a>推送服务的响应</h2><ul>\n<li>429 too many requests</li>\n<li>400 invalid request</li>\n<li>404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。</li>\n<li>410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的 unsubscribe() 方法</li>\n<li>413 Payload size too large</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"消息推送介绍\"><a href=\"#消息推送介绍\" class=\"headerlink\" title=\"消息推送介绍\"></a>消息推送介绍</h2><p>消息推送通知目前整体支持度并不高，在手机端更只有安卓 chrome57 支持。在订阅消息之前，浏览器主要得到用户授权，同意后才能使用消息推送服务。都是通过 serviceWorker 去实现的。</p>","more":"<p>基本原理是，你的客户端和推送服务进行绑定，会生成一个绑定后的推送服务 API 接口，服务端调用此接口，发送消息。同时浏览器也需要支持这个功能，在注册 sw 时，加上推送功能的判断。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'serviceWorker'</span> <span class=\"keyword\">in</span> navigator &amp;&amp; <span class=\"string\">'PushManager'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>) &#123;</span><br><span class=\"line\">  navigator.serviceWorker</span><br><span class=\"line\">    .register(sw.js)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">swReg</span>) </span>&#123;</span><br><span class=\"line\">      swRegistration = swReg</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .catch(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">error</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.error(<span class=\"string\">'Service Worker Error'</span>, error)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.warn(<span class=\"string\">'Push messaging is not supported'</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>PushManager 注册好之后，那么要做的就是浏览器和服务器的绑定了。</p>\n<h2 id=\"获取授权\"><a href=\"#获取授权\" class=\"headerlink\" title=\"获取授权\"></a>获取授权</h2><ul>\n<li>在订阅之前先获取用户授权，** 使用 Notification.requestPermission。当用户允许或者拒绝授权之后，后续都不会重复询问。</li>\n<li>如果不选择 1，在正式订阅时，浏览器也会自动弹出。对于开发者而言不需要显示调用。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/notification\" target=\"_blank\" rel=\"noopener\">Notifications API</a> 的通知接口用于向用户配置和显示桌面通知。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Push_API\" target=\"_blank\" rel=\"noopener\">push API</a> 允许 web 应用程序接受从服务器推送到它们的消息的能力，无论 WEB 应用程序是否在用户代理的前台，或者甚至当前加载。这样。开发人员就可以向选择启用的用户投放异步通知和更新，从而更及时的吸引新内容。</li>\n</ul>\n<h2 id=\"订阅消息的具体实现\"><a href=\"#订阅消息的具体实现\" class=\"headerlink\" title=\"订阅消息的具体实现\"></a>订阅消息的具体实现</h2><ul>\n<li>在订阅之前先获取用户授权</li>\n<li>使用 pushManager 添加订阅，浏览器向推送服务发送请求，轻重传递参数对象包含两个属性。<ul>\n<li>userVisibleOnly, 不允许静默的推出，所有推出都对用户可见，所以值为 true</li>\n<li>applicationServerKey, 服务器生成的公钥</li>\n</ul>\n</li>\n<li>得到推送服务成功响应后，浏览器将推送服务返回的 endpoint 加入推送订阅对象，向服务器发送这个对象供其存储。</li>\n</ul>\n<p>消息推送的安全性 :</p>\n<ul>\n<li>推送服务确保调用来自可靠的服务端。</li>\n<li>推送消息内容只有浏览器能够解密，就算是推送服务也不行</li>\n</ul>\n<h2 id=\"使用-web-push-服务器发送信息\"><a href=\"#使用-web-push-服务器发送信息\" class=\"headerlink\" title=\"使用 web-push 服务器发送信息\"></a>使用 web-push 服务器发送信息</h2><p> 这是谷歌自己实现的一个推送功能的服务器</p>\n<p>服务器端请求推送服务器，需要涉及加密，设置请求头等复杂操作。使用 web-push 可以解决大部分问题。</p>\n<ul>\n<li>使用 web-push 生成一对公私钥，还记得 pushManager 订阅时需要用到的 applicationServerKey 吗，我们需要公钥 publicKey 传递到订阅脚本所在的页面中。。</li>\n<li>调用 setVapidDetails 为 web-push 设置生成的公私钥。</li>\n<li>之前订阅时浏览器已经将推送订阅对象发送到了服务端，此时从数据库中取出。</li>\n<li>调用 sendNotification 向推送服务发起调用请求，如果返回错误状态码，从数据库中删除保存的推送订阅对象。</li>\n<li>所有推送服务都遵循同意的调用标准，<strong>所有推送服务都遵循统一的调用标准，推送服务如果接到了服务器的调用请求，向设备推送消息，如果处于离线状态，消息将进入待发送队列，过期后队列清空，消息将被丢弃。</strong></li>\n</ul>\n<h2 id=\"推送服务的响应\"><a href=\"#推送服务的响应\" class=\"headerlink\" title=\"推送服务的响应\"></a>推送服务的响应</h2><ul>\n<li>429 too many requests</li>\n<li>400 invalid request</li>\n<li>404 not found 订阅过期，需要在服务端删除保存的推送订阅对象。</li>\n<li>410 Gone 订阅失效，需要在服务端删除保存的推送订阅对象，并调用推送订阅对象的 unsubscribe() 方法</li>\n<li>413 Payload size too large</li>\n</ul>"},{"title":"angular form 表单","comments":1,"_content":"## checkbox\n\nmodule：import &#123;CheckboxControlValueAccessor &#125; from '@abgular/forms';\n\n- input[type=checkbox][formCtontrolName]\n- input[type=checkbox][formControl]\n- input[type=checkbox][ngModel]\n\n用于写入值并在复选框输入元素上监听更改的访问器\n\n```html\n<input type=\"checkbox\" name = \"rememberLogin\" ngModel>\n```\n<!--more-->\n### 数据驱动\n响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName F\n\n- formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据\n- formBuilder :表单数据构建工具[构建初始表单]\n- formContlName :同步与formGrop 构建表单内相同字段的值\n\n### 响应式表单验证\n响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。\n响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。\n\nreactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和\ninternalFormSharedModule模板里的指令。\n- formControlDirective 描述表单的一个字段\n- formGroupDirective 描述表单分组\n- formControlName 描述变淡字段名\n- formArrayaName 描述同类型的一组数据的名称，与表单分组无关","source":"_posts/angular-form.md","raw":"---\ntitle: angular form 表单\ncategories: angular\ncomments: true\n---\n## checkbox\n\nmodule：import &#123;CheckboxControlValueAccessor &#125; from '@abgular/forms';\n\n- input[type=checkbox][formCtontrolName]\n- input[type=checkbox][formControl]\n- input[type=checkbox][ngModel]\n\n用于写入值并在复选框输入元素上监听更改的访问器\n\n```html\n<input type=\"checkbox\" name = \"rememberLogin\" ngModel>\n```\n<!--more-->\n### 数据驱动\n响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName F\n\n- formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据\n- formBuilder :表单数据构建工具[构建初始表单]\n- formContlName :同步与formGrop 构建表单内相同字段的值\n\n### 响应式表单验证\n响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。\n响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。\n\nreactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和\ninternalFormSharedModule模板里的指令。\n- formControlDirective 描述表单的一个字段\n- formGroupDirective 描述表单分组\n- formControlName 描述变淡字段名\n- formArrayaName 描述同类型的一组数据的名称，与表单分组无关","slug":"angular-form","published":1,"date":"2018-03-20T03:29:41.818Z","updated":"2018-03-20T03:29:41.818Z","_id":"cjepksjmf000c8gv68kz728eg","layout":"post","photos":[],"link":"","content":"<h2 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h2><p>module：import &#123;CheckboxControlValueAccessor &#125; from ‘@abgular/forms’;</p>\n<ul>\n<li>input[type=checkbox][formCtontrolName]</li>\n<li>input[type=checkbox][formControl]</li>\n<li>input[type=checkbox][ngModel]</li>\n</ul>\n<p>用于写入值并在复选框输入元素上监听更改的访问器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">name</span> = <span class=\"string\">\"rememberLogin\"</span> <span class=\"attr\">ngModel</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"数据驱动\"><a href=\"#数据驱动\" class=\"headerlink\" title=\"数据驱动\"></a>数据驱动</h3><p>响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName F</p>\n<ul>\n<li>formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据</li>\n<li>formBuilder :表单数据构建工具[构建初始表单]</li>\n<li>formContlName :同步与formGrop 构建表单内相同字段的值</li>\n</ul>\n<h3 id=\"响应式表单验证\"><a href=\"#响应式表单验证\" class=\"headerlink\" title=\"响应式表单验证\"></a>响应式表单验证</h3><p>响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。<br>响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。</p>\n<p>reactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和<br>internalFormSharedModule模板里的指令。</p>\n<ul>\n<li>formControlDirective 描述表单的一个字段</li>\n<li>formGroupDirective 描述表单分组</li>\n<li>formControlName 描述变淡字段名</li>\n<li>formArrayaName 描述同类型的一组数据的名称，与表单分组无关</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"checkbox\"><a href=\"#checkbox\" class=\"headerlink\" title=\"checkbox\"></a>checkbox</h2><p>module：import &#123;CheckboxControlValueAccessor &#125; from ‘@abgular/forms’;</p>\n<ul>\n<li>input[type=checkbox][formCtontrolName]</li>\n<li>input[type=checkbox][formControl]</li>\n<li>input[type=checkbox][ngModel]</li>\n</ul>\n<p>用于写入值并在复选框输入元素上监听更改的访问器</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"checkbox\"</span> <span class=\"attr\">name</span> = <span class=\"string\">\"rememberLogin\"</span> <span class=\"attr\">ngModel</span>&gt;</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"数据驱动\"><a href=\"#数据驱动\" class=\"headerlink\" title=\"数据驱动\"></a>数据驱动</h3><p>响应式表单：原理是一开始就构建整个表单，表单的值通过特殊指令formControlName F</p>\n<ul>\n<li>formGroup :用来追踪表单控件有效状态及值，可以理解为获取且可以操作整个表单的数据</li>\n<li>formBuilder :表单数据构建工具[构建初始表单]</li>\n<li>formContlName :同步与formGrop 构建表单内相同字段的值</li>\n</ul>\n<h3 id=\"响应式表单验证\"><a href=\"#响应式表单验证\" class=\"headerlink\" title=\"响应式表单验证\"></a>响应式表单验证</h3><p>响应式表单与模板驱动表单不同的是，响应式表单在组件类中创建表单控制模型，可在组件中随意控制校验规则。<br>响应式表单使用ReactiveFormsModule,而非普通的formModule,需要在app.module。ts里导入。</p>\n<p>reactiveFormsModule 包含formControlDirective、formGroupDirective、formControlName、formArrayName和<br>internalFormSharedModule模板里的指令。</p>\n<ul>\n<li>formControlDirective 描述表单的一个字段</li>\n<li>formGroupDirective 描述表单分组</li>\n<li>formControlName 描述变淡字段名</li>\n<li>formArrayaName 描述同类型的一组数据的名称，与表单分组无关</li>\n</ul>"},{"title":"angular 数据绑定详解","comments":1,"_content":"\n## 绑定\n\n1. 绑定表达式的指令 ngBind\n\n```html\n    <div ng-Bind = \"vm.info\"></div>\n```\n\n这样就把控制器中额 vm.info 的值绑定在 div 标签中，这样页面在网速不好的时候就不会出现 angular 中 &#123;&#123;&#125;&#125; 的解析符，它隐藏了 angular 解析表达式的过程\n\n2. ngBindTemplate ngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式 `html <div ng-bind-template=\"{{vm.info}}{{vm.msg}}\"></div>`\n\n<!--more-->\n\n## 数据绑定\n\n数据绑定可以分为 3 种：\n\n1. 属性绑定和插值表达式 组件类 -> 模板\n2. 事件绑定：模板 -> 组件类\n3. 双向绑定： 模板 <-> 组件类\n\n#### 事件绑定\n\n```html\n    <a (click)=\"test()\"></a>\n     (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法\n```\n\n#### 属性绑定和插值表达式\n\n属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定 , 例如下面的两种写法是一样的\n\n    ```javascript\n    <img src=\"{{ingURL}}\" />\n    <img [src]=\"imgUrl\">\n    ```\n\n属性绑定又分为 HTML 属性绑定和 DOM 绑定， 例如：\n\n```javascript\n<input type =\"text\" value = \"hello\" (input) = \"doInput($event)\" >\n doInput(event:any){\n     console.log(event.target.value);\n     console.log(event.target.getAttribute('value'));\n }\n```\n\n其中 event.target.value 是获取的 DOM 属性，是可变的，表示当前元素的状态。而 event.target.getAttribute(\"value\") 获取的是 HTML 属性，是不可变的。只负责初始化 HTML 元素，不可改变。\n\n<strong>注意：</strong>\n\n1. 有的 DOM 属性没有映射的 HTML 属性，同样有些 HTML 属性也没有映射的 DOM 属性。\n2. 模板绑定的是 DOM 属性。\n\n##### HTML 属性绑定\n\n1. 基本 HTML 属性绑定\n\n```javascript\n    <td [attr.colspan]=\"表达式\"></td>\n```\n\n2. css 绑定\n\n```html\n    <div class =\"a\" [class]=\"b\"></div> //b会完全替代a\n    <div [class.a]=\"fn()\"></div>//fn()返回true、false,如果true则添加.a\n    <div [ngClass]=\"{a:isA,b:isB}\"></div>// b会完全替代a\n```\n\n3. 样式绑定\n\n   ```javascript\n       <button [style.color]=\"a?red:green\">button</button>\n       <button [ngStyle] = \"{'font-style':a?'red':'green'}\">button</button>\n   ```\n\n4. 双向绑定双向绑定可以从组件类 -> 模板，也可以模板 -> 组件类，利用[(ngModel)]可以实现双向数据绑定\n","source":"_posts/angular-数据绑定.md","raw":"---\ntitle: angular 数据绑定详解\ncategories: angular\ncomments: true\n---\n\n## 绑定\n\n1. 绑定表达式的指令 ngBind\n\n```html\n    <div ng-Bind = \"vm.info\"></div>\n```\n\n这样就把控制器中额 vm.info 的值绑定在 div 标签中，这样页面在网速不好的时候就不会出现 angular 中 &#123;&#123;&#125;&#125; 的解析符，它隐藏了 angular 解析表达式的过程\n\n2. ngBindTemplate ngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式 `html <div ng-bind-template=\"{{vm.info}}{{vm.msg}}\"></div>`\n\n<!--more-->\n\n## 数据绑定\n\n数据绑定可以分为 3 种：\n\n1. 属性绑定和插值表达式 组件类 -> 模板\n2. 事件绑定：模板 -> 组件类\n3. 双向绑定： 模板 <-> 组件类\n\n#### 事件绑定\n\n```html\n    <a (click)=\"test()\"></a>\n     (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法\n```\n\n#### 属性绑定和插值表达式\n\n属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定 , 例如下面的两种写法是一样的\n\n    ```javascript\n    <img src=\"{{ingURL}}\" />\n    <img [src]=\"imgUrl\">\n    ```\n\n属性绑定又分为 HTML 属性绑定和 DOM 绑定， 例如：\n\n```javascript\n<input type =\"text\" value = \"hello\" (input) = \"doInput($event)\" >\n doInput(event:any){\n     console.log(event.target.value);\n     console.log(event.target.getAttribute('value'));\n }\n```\n\n其中 event.target.value 是获取的 DOM 属性，是可变的，表示当前元素的状态。而 event.target.getAttribute(\"value\") 获取的是 HTML 属性，是不可变的。只负责初始化 HTML 元素，不可改变。\n\n<strong>注意：</strong>\n\n1. 有的 DOM 属性没有映射的 HTML 属性，同样有些 HTML 属性也没有映射的 DOM 属性。\n2. 模板绑定的是 DOM 属性。\n\n##### HTML 属性绑定\n\n1. 基本 HTML 属性绑定\n\n```javascript\n    <td [attr.colspan]=\"表达式\"></td>\n```\n\n2. css 绑定\n\n```html\n    <div class =\"a\" [class]=\"b\"></div> //b会完全替代a\n    <div [class.a]=\"fn()\"></div>//fn()返回true、false,如果true则添加.a\n    <div [ngClass]=\"{a:isA,b:isB}\"></div>// b会完全替代a\n```\n\n3. 样式绑定\n\n   ```javascript\n       <button [style.color]=\"a?red:green\">button</button>\n       <button [ngStyle] = \"{'font-style':a?'red':'green'}\">button</button>\n   ```\n\n4. 双向绑定双向绑定可以从组件类 -> 模板，也可以模板 -> 组件类，利用[(ngModel)]可以实现双向数据绑定\n","slug":"angular-数据绑定","published":1,"date":"2018-03-20T03:29:41.818Z","updated":"2018-03-20T03:29:41.818Z","_id":"cjepksjmk000f8gv64hkeogsz","layout":"post","photos":[],"link":"","content":"<h2 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h2><ol>\n<li>绑定表达式的指令 ngBind</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-Bind</span> = <span class=\"string\">\"vm.info\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样就把控制器中额 vm.info 的值绑定在 div 标签中，这样页面在网速不好的时候就不会出现 angular 中 &#123;&#123;&#125;&#125; 的解析符，它隐藏了 angular 解析表达式的过程</p>\n<ol>\n<li>ngBindTemplate ngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式 <code>html &lt;div ng-bind-template=&quot;&quot;&gt;&lt;/div&gt;</code></li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><p>数据绑定可以分为 3 种：</p>\n<ol>\n<li>属性绑定和插值表达式 组件类 -&gt; 模板</li>\n<li>事件绑定：模板 -&gt; 组件类</li>\n<li>双向绑定： 模板 &lt;-&gt; 组件类</li>\n</ol>\n<h4 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"test()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"> (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性绑定和插值表达式\"><a href=\"#属性绑定和插值表达式\" class=\"headerlink\" title=\"属性绑定和插值表达式\"></a>属性绑定和插值表达式</h4><p>属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定 , 例如下面的两种写法是一样的</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">\"&#123;&#123;ingURL&#125;&#125;\"</span> /&gt;</span><br><span class=\"line\">&lt;img [src]=<span class=\"string\">\"imgUrl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><p>属性绑定又分为 HTML 属性绑定和 DOM 绑定， 例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type =<span class=\"string\">\"text\"</span> value = <span class=\"string\">\"hello\"</span> (input) = <span class=\"string\">\"doInput($event)\"</span> &gt;</span><br><span class=\"line\"> doInput(event:any)&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.value);</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.getAttribute(<span class=\"string\">'value'</span>));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 event.target.value 是获取的 DOM 属性，是可变的，表示当前元素的状态。而 event.target.getAttribute(“value”) 获取的是 HTML 属性，是不可变的。只负责初始化 HTML 元素，不可改变。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>有的 DOM 属性没有映射的 HTML 属性，同样有些 HTML 属性也没有映射的 DOM 属性。</li>\n<li>模板绑定的是 DOM 属性。</li>\n</ol>\n<h5 id=\"HTML-属性绑定\"><a href=\"#HTML-属性绑定\" class=\"headerlink\" title=\"HTML 属性绑定\"></a>HTML 属性绑定</h5><ol>\n<li>基本 HTML 属性绑定</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td [attr.colspan]=<span class=\"string\">\"表达式\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>css 绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> =<span class=\"string\">\"a\"</span> [<span class=\"attr\">class</span>]=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> //b会完全替代a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">class.a</span>]=<span class=\"string\">\"fn()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>//fn()返回true、false,如果true则添加.a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">ngClass</span>]=<span class=\"string\">\"&#123;a:isA,b:isB&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// b会完全替代a</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>样式绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button [style.color]=<span class=\"string\">\"a?red:green\"</span>&gt;button&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;button [ngStyle] = \"&#123;'font-style':a?'red':'green'&#125;\"&gt;button&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>双向绑定双向绑定可以从组件类 -&gt; 模板，也可以模板 -&gt; 组件类，利用[(ngModel)]可以实现双向数据绑定</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h2><ol>\n<li>绑定表达式的指令 ngBind</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">ng-Bind</span> = <span class=\"string\">\"vm.info\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这样就把控制器中额 vm.info 的值绑定在 div 标签中，这样页面在网速不好的时候就不会出现 angular 中 &#123;&#123;&#125;&#125; 的解析符，它隐藏了 angular 解析表达式的过程</p>\n<ol>\n<li>ngBindTemplate ngBindTemplate 这个指令与上一个指令的不同之处在于它可以绑定多个表达式 <code>html &lt;div ng-bind-template=&quot;&quot;&gt;&lt;/div&gt;</code></li>\n</ol>","more":"<h2 id=\"数据绑定\"><a href=\"#数据绑定\" class=\"headerlink\" title=\"数据绑定\"></a>数据绑定</h2><p>数据绑定可以分为 3 种：</p>\n<ol>\n<li>属性绑定和插值表达式 组件类 -&gt; 模板</li>\n<li>事件绑定：模板 -&gt; 组件类</li>\n<li>双向绑定： 模板 &lt;-&gt; 组件类</li>\n</ol>\n<h4 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"test()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br><span class=\"line\"> (click) 表示要进行的操作，当用户点击时就会执行组件类中的test()方法</span><br></pre></td></tr></table></figure>\n<h4 id=\"属性绑定和插值表达式\"><a href=\"#属性绑定和插值表达式\" class=\"headerlink\" title=\"属性绑定和插值表达式\"></a>属性绑定和插值表达式</h4><p>属性绑定和插值表达式是同一种东西，因为在解析代码的时候，插值表达式会转换为属性绑定 , 例如下面的两种写法是一样的</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;img src=<span class=\"string\">\"&#123;&#123;ingURL&#125;&#125;\"</span> /&gt;</span><br><span class=\"line\">&lt;img [src]=<span class=\"string\">\"imgUrl\"</span>&gt;</span><br></pre></td></tr></table></figure>\n</code></pre><p>属性绑定又分为 HTML 属性绑定和 DOM 绑定， 例如：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type =<span class=\"string\">\"text\"</span> value = <span class=\"string\">\"hello\"</span> (input) = <span class=\"string\">\"doInput($event)\"</span> &gt;</span><br><span class=\"line\"> doInput(event:any)&#123;</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.value);</span><br><span class=\"line\">     <span class=\"built_in\">console</span>.log(event.target.getAttribute(<span class=\"string\">'value'</span>));</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>其中 event.target.value 是获取的 DOM 属性，是可变的，表示当前元素的状态。而 event.target.getAttribute(“value”) 获取的是 HTML 属性，是不可变的。只负责初始化 HTML 元素，不可改变。</p>\n<p><strong>注意：</strong></p>\n<ol>\n<li>有的 DOM 属性没有映射的 HTML 属性，同样有些 HTML 属性也没有映射的 DOM 属性。</li>\n<li>模板绑定的是 DOM 属性。</li>\n</ol>\n<h5 id=\"HTML-属性绑定\"><a href=\"#HTML-属性绑定\" class=\"headerlink\" title=\"HTML 属性绑定\"></a>HTML 属性绑定</h5><ol>\n<li>基本 HTML 属性绑定</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;td [attr.colspan]=<span class=\"string\">\"表达式\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>css 绑定</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span> =<span class=\"string\">\"a\"</span> [<span class=\"attr\">class</span>]=<span class=\"string\">\"b\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> //b会完全替代a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">class.a</span>]=<span class=\"string\">\"fn()\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>//fn()返回true、false,如果true则添加.a</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> [<span class=\"attr\">ngClass</span>]=<span class=\"string\">\"&#123;a:isA,b:isB&#125;\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span>// b会完全替代a</span><br></pre></td></tr></table></figure>\n<ol>\n<li><p>样式绑定</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;button [style.color]=<span class=\"string\">\"a?red:green\"</span>&gt;button&lt;<span class=\"regexp\">/button&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;button [ngStyle] = \"&#123;'font-style':a?'red':'green'&#125;\"&gt;button&lt;/</span>button&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>双向绑定双向绑定可以从组件类 -&gt; 模板，也可以模板 -&gt; 组件类，利用[(ngModel)]可以实现双向数据绑定</p>\n</li>\n</ol>"},{"title":"angular 线上商城学习","_content":"\n使用 angular 开发线上商城\n\n<!--more-->\n\n## 创建 angular 工程\n\n1. ng new action\n2. 引入第三方的包是通过更改 angular-cli 来实现的。\n3. e2e: 是存放端到端的测试目录，是用来做自动化测试\n4. protractor.conf.js 自动化测试文件\n5. tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。\n6. assets 是用来存放静态资源的。\n7. environments 开发、测试、生产环境的配置，多环境的开发。\n8. main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。\n9. polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。\n10. styles.css 用来编写全局使用的 css。\n\n## 组件\n\n* component 是整个应用的基础。\n* @Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。\n* Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。\n* Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。\n* 所有组件都必须使用 @Component() 装饰器进行注解。\n\n```angular\n@Component{\n  selector:'app-root',//元数据\n  templateUrl:'./app.component.html',\n  styleUrls:['./app.component.css'],\n}\n\nexport class AppComponent{ //暴露为一个组件 ，TypeScript 类，为控制器\n  title = 'app worker'\n}\n```\n\n* @input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。\n* providers 是用来完成依赖注入的。\n* @Outputs 输出属性\n\n## 模块\n\n* 使用 @ngModule 声明一个模块。\n* 使用 declarations 说明了模块中包含了的组件，**这个元数据里面只能用于声明组件、指令、管道**。\n* providers 用于声明模块的服务。\n* bootstrap 用于声明模块的主组件。\n\n<!-- 2-3 -->\n","source":"_posts/angular-线上商城学习.md","raw":"---\ntitle: angular 线上商城学习\ncategories: angular\n---\n\n使用 angular 开发线上商城\n\n<!--more-->\n\n## 创建 angular 工程\n\n1. ng new action\n2. 引入第三方的包是通过更改 angular-cli 来实现的。\n3. e2e: 是存放端到端的测试目录，是用来做自动化测试\n4. protractor.conf.js 自动化测试文件\n5. tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。\n6. assets 是用来存放静态资源的。\n7. environments 开发、测试、生产环境的配置，多环境的开发。\n8. main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。\n9. polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。\n10. styles.css 用来编写全局使用的 css。\n\n## 组件\n\n* component 是整个应用的基础。\n* @Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。\n* Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。\n* Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。\n* 所有组件都必须使用 @Component() 装饰器进行注解。\n\n```angular\n@Component{\n  selector:'app-root',//元数据\n  templateUrl:'./app.component.html',\n  styleUrls:['./app.component.css'],\n}\n\nexport class AppComponent{ //暴露为一个组件 ，TypeScript 类，为控制器\n  title = 'app worker'\n}\n```\n\n* @input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。\n* providers 是用来完成依赖注入的。\n* @Outputs 输出属性\n\n## 模块\n\n* 使用 @ngModule 声明一个模块。\n* 使用 declarations 说明了模块中包含了的组件，**这个元数据里面只能用于声明组件、指令、管道**。\n* providers 用于声明模块的服务。\n* bootstrap 用于声明模块的主组件。\n\n<!-- 2-3 -->\n","slug":"angular-线上商城学习","published":1,"date":"2018-03-20T03:29:41.818Z","updated":"2018-03-20T03:29:41.818Z","_id":"cjepksjn1000g8gv69qa91zh1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>使用 angular 开发线上商城</p>\n<a id=\"more\"></a>\n<h2 id=\"创建-angular-工程\"><a href=\"#创建-angular-工程\" class=\"headerlink\" title=\"创建 angular 工程\"></a>创建 angular 工程</h2><ol>\n<li>ng new action</li>\n<li>引入第三方的包是通过更改 angular-cli 来实现的。</li>\n<li>e2e: 是存放端到端的测试目录，是用来做自动化测试</li>\n<li>protractor.conf.js 自动化测试文件</li>\n<li>tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。</li>\n<li>assets 是用来存放静态资源的。</li>\n<li>environments 开发、测试、生产环境的配置，多环境的开发。</li>\n<li>main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。</li>\n<li>polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。</li>\n<li>styles.css 用来编写全局使用的 css。</li>\n</ol>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><ul>\n<li>component 是整个应用的基础。</li>\n<li>@Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。</li>\n<li>Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。</li>\n<li>Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。</li>\n<li>所有组件都必须使用 @Component() 装饰器进行注解。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component&#123;</span><br><span class=\"line\">  selector:&apos;app-root&apos;,//元数据</span><br><span class=\"line\">  templateUrl:&apos;./app.component.html&apos;,</span><br><span class=\"line\">  styleUrls:[&apos;./app.component.css&apos;],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export class AppComponent&#123; //暴露为一个组件 ，TypeScript 类，为控制器</span><br><span class=\"line\">  title = &apos;app worker&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。</li>\n<li>providers 是用来完成依赖注入的。</li>\n<li>@Outputs 输出属性</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><ul>\n<li>使用 @ngModule 声明一个模块。</li>\n<li>使用 declarations 说明了模块中包含了的组件，<strong>这个元数据里面只能用于声明组件、指令、管道</strong>。</li>\n<li>providers 用于声明模块的服务。</li>\n<li>bootstrap 用于声明模块的主组件。</li>\n</ul>\n<!-- 2-3 -->\n","site":{"data":{}},"excerpt":"<p>使用 angular 开发线上商城</p>","more":"<h2 id=\"创建-angular-工程\"><a href=\"#创建-angular-工程\" class=\"headerlink\" title=\"创建 angular 工程\"></a>创建 angular 工程</h2><ol>\n<li>ng new action</li>\n<li>引入第三方的包是通过更改 angular-cli 来实现的。</li>\n<li>e2e: 是存放端到端的测试目录，是用来做自动化测试</li>\n<li>protractor.conf.js 自动化测试文件</li>\n<li>tsconfig.json 是 tsLink 的配置文件是用于 javascript 的代码检查。</li>\n<li>assets 是用来存放静态资源的。</li>\n<li>environments 开发、测试、生产环境的配置，多环境的开发。</li>\n<li>main.ts 整个整个 web 应用的入口点，也是脚本的执行的入口点，通过这个文件启动 angular 整个项目。</li>\n<li>polyfills.ts 使用来导入一些必要的库。使 angular 能正常的运行在某一些老版本的浏览器。</li>\n<li>styles.css 用来编写全局使用的 css。</li>\n</ol>\n<h2 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h2><ul>\n<li>component 是整个应用的基础。</li>\n<li>@Component() 装饰器 : 用来告知 angular 框架如何处理一个 TypeScript 类， @Component() 装饰器 包含多个属性，属性的值叫做元数据，angular 会根据这些元数据进行渲染组件，并执行相应的逻辑。</li>\n<li>Template 模板 ，通过组建自带的模板来定义组件的外观，模板以 html 存在，用来呈现控制器中的数据。</li>\n<li>Controller 控制器 会被 @Component() 来装饰。用以处理模板中的数据。</li>\n<li>所有组件都必须使用 @Component() 装饰器进行注解。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@Component&#123;</span><br><span class=\"line\">  selector:&apos;app-root&apos;,//元数据</span><br><span class=\"line\">  templateUrl:&apos;./app.component.html&apos;,</span><br><span class=\"line\">  styleUrls:[&apos;./app.component.css&apos;],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export class AppComponent&#123; //暴露为一个组件 ，TypeScript 类，为控制器</span><br><span class=\"line\">  title = &apos;app worker&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@input 输入属性 是用来接受外部传入的数据，使得父组件可以直接传递数据给子组件。</li>\n<li>providers 是用来完成依赖注入的。</li>\n<li>@Outputs 输出属性</li>\n</ul>\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><ul>\n<li>使用 @ngModule 声明一个模块。</li>\n<li>使用 declarations 说明了模块中包含了的组件，<strong>这个元数据里面只能用于声明组件、指令、管道</strong>。</li>\n<li>providers 用于声明模块的服务。</li>\n<li>bootstrap 用于声明模块的主组件。</li>\n</ul>\n<!-- 2-3 -->"},{"title":"angular 基础","comments":1,"_content":"\n## angular 与 vue 的区别\n\n* angular2 全部采用 TypeScript 编写，TypeScript （编译工具），它为 JS 带来了类似于 Java 和 C# 的静态类型，\n* vue 的双向绑定基于 ES5 的 getter/setter 来实现的，而 angular 是由自己实现一套模板编译规则们需要进行 “ 脏 ” 检查，而 vue 不需要，因此 vue 在性能上更高效。\n* angular 中，当 watcher 越来越多时会越来越慢，因为作用域的每一次变化\n\n<!--more-->\n\n## angular\n\n* 组件化，数据的单向中心。es6 的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下：\n* DOM 事件，譬如用户输入文本，点击按钮等。( ng-click )\n* XHR 响应事件 ( $http )\n* 浏览器 Location 变更事件 ( $location )\n* Timer 事件 ( $timeout , $interval )\n* 执行 $digest() 或 $apply()\n\n## react\n\n* 速度很快：来源于虚拟 DOM，只有在调用 get 和 set 的时候才会更新 DOM，而且是先更新虚拟 DOM 再更新实际的 DOM，由此更新 DOM 的次数少内容也会少很多。\n* FLUX 架构，react 更关注 UI 的组件化和数据的单向更新。可以直接有 es6 的一些语法。\n* 服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是 web 的执行。\n* 目标是 UI。\n* 本身是一个 MVC 中的 V。\n\n---\n\n## Angular 为表单内置了 4 种 css 样式\n\n* ng-valid 校验合法状态\n* ng-invalid 校验非法状态\n* ng-pristine 如果要使用原生的 form，需要设置这个值\n* ng-dirty 表单处于脏数据状态\n\n---\n\n## @Component\n\n* @Component 是 Angular 提供的装饰函数，用来描述 Component 的元数据\n* selector 指这个组件在 HTML 模板中的标签是什么\n* template 是嵌入（inline ）的 HTML 模板，如果使用单独文件可用 templateUrl。\n* styles 是嵌入（inline ）的 CSS 样式，如果使用单独文件可用 styleUrls。\n* providers 列出会在此模块中 “ 注入 ” 的服务 (service)- 依赖注入\n* bootstrap 指明哪个组件为引导组件 ( 比如 AppComponent), 当 angular 引导应用时，它会在 Dom 中渲染这个引导性组件，并把结果放进 index.html 的该组件的标签中。\n\n## @NgModule\n\n@NgModule 装饰器用来为模块定义元数据。declarations 列出了应用中的顶层组件，在 module 里面声明的组件在 module 范围内都可以直接使用，也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件，就想我们在 AppComponent 的模板末尾加上 <app-login></app-login> 一样。\n\n```javascript\nimport { HttpModule } from '@angular/http'\n\nimport { AppComponent } from './app.component'\nimport { LoginComponent } from './login/login.component'\n\n@NgModule({\n  declarations: [AppComponent, LoginComponent],\n  imports: [BrowserModule, FormsModule, HttpModule],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n```\n\nNgModule 装饰器用来为模块定义元数据。\n\n* declarations 列出了应用中的顶层组件。\n* BrowerModule 提供了运行在浏览器中的应用所需要的关键服务 (service) 和指令 (Directive), 这个模块所在需要在浏览器中跑的应用都应用引用。\n* FormsModule 提供了表单处理和双向绑定等服务和指令。\n* HttpModule 提供 Htpp 请求和响应的服务。\n* providers 列出会在此模版中 “ 注入 ” 的服务（service ）。\n* bootstrap 指明哪个组件为引导性组件，并把结果放到 index.html 的该组件的元素标签中。\n* 静态引导 AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n---\n\n## 依赖注入\n\n如果不使用依赖注入，则需要 // 声明成员变量，其类型为 service 里面自定义的方法\n\n    ```javascript\n    //第一种：\n    service:AuthService;\n\n    constructor(){\n        this.service = new AuthService();//在构造中初始化service\n    }\n    //第二种：\n\n    providers: [\n    {provide: 'auth',  useClass: AuthService}\n    ]\n    ```\n\n* 第一种：由于实例化是在组件中进行的，意味着我们如果更改 service 的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量 service。当 import 相关的服务后，这是 import 将类型引入进来，而 provider 里面会配置这个类型的实例。\n* provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide 定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。\n\n```javascript\n       onstructor(@Inject('auth') private service) {\n   }\n```\n\n* @inject('auth'), 这个修饰符的意思是请到系统配置中找到名称为 auth 的那个依赖注入到我修饰的变量中。\n\n## 双向数据绑定\n\n* [(ngModel)]=\"username\" ,[] 的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉 [] 就是将 ngModel 赋值成 username 这个字符串。[] 的含义是单向绑定，就是将组件中给 model 赋的值会设置到 HTML 的 input 控件中。[()]是双向绑定。ngModel 是 FormModule 中提供的指令，它负责从 Domain Model 中创建一个 FormControl 的实例，并将这个实例和表单控件绑定 .\n* @Input() 是输入型绑定的修饰符，用于从数据从父组件传到子组件。\n\n---\n\n## 表单验证\n\n```html\n    <div>\n        <input required type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            />\n            {{usernameRef.valid}}\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            {{passwordRef.valid}}\n        <button (click)=\"onClick()\">Login</button>\n        </div>\n        <div>\n        <input #usernameRef type=\"text\">\n        <button (click)=\"onClick(usernameRef.value)\">Login</button>\n        </div>\n```\n\n1. 通过 #usernameRef = 'ngModel' 重新加入了引用，这个引用指向了 ngModel, 这个引用是要在模板中使用的所以加入这个引用。\n2. 在输入框中加入 #usernameRef，这个叫引用，引用的是 input 对象，如果想要传递 input 的值，可以用 usernameRef.value.\n\n```html\n    <div>\n        <input type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            {{ usernameRef.errors | json }}\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n        <button (click)=\"onClick()\">Login</button>\n    </div>\n```\n\n\\*ngIf = \"usernameRef.error?.required\" 的意思是当 usernameRef.error.required 为 true 的时候显示 div 标签\n\n```html\n    <div>\n        <form #formRef=\"ngForm\" (ngSubmit)=\"onSubmit(formRef.value)\">\n        <fieldset ngModelGroup=\"login\">\n            <input type=\"text\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n            <input type=\"password\"\n            name=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            required\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n            <button (click)=\"onClick()\">Login</button>\n            <button type=\"submit\">Submit</button>\n            </fieldset>\n        </form>\n        </div>\n```\n\n* ngModel 会注册成 Form 的子控件，注册控件需要 name ，这个要求我们显示的指定对应控件的 name ，因此需要为 input 增加 name 属性，在 formREF.value 中包含了表单所有填写项的值\n\n* 有时在表单相中表单项过多时，就使用 HTML 中的 fieldset 标签用来处理。<fieldset ngModelGroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。\n\n---\n\n## 路由\n\n路径配置的顺序是非常重要的，angular2 使用 “ 先匹配优先 ” 的原则。\n\n* redirectTo 重定向\n  ## service\n\n```javascript\n    //post /todos\n    addTodo(desc:string):Promise<Todo>{\n        let todo={\n            id:UUID.UUID(),\n            desc:desc,\n            completed:false\n        };\n        return this.http\n            .post(this.api_url,JSON.stringfy(todo),{header:this.headers})\n            .toPromise()\n            .then(res=>res.json().data as Todo)\n            .catch(this.handleError);\n    }\n```\n\n---\n\n````javascript\n    inputValue: string = '';\n    @Input() placeholder: string = 'What needs to be done?';\n    @Input() delay: number = 300;\n\n    //detect the input value and output this to parent\n    @Output() textChanges = new EventEmitter<string>();\n    //detect the enter keyup event and output this to parent\n    @Output() onEnterUp = new EventEmitter<boolean>();\n    ```\n- placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。\n- 由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。\n- export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.\n\n\n--------------------------\n## 验证用户帐户的流程\n- UserService:用于通过用户名查找用户并返回用户\n- AuthService:用于认证用户，其中需要利用UserService 的方法。\n- AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。\n- @SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,\nparentModule参数也就被赋值为空。\n\n----------------\n## 路由守卫\n应用场景如下:\n该用户可能无权导航到目标组件。导航前需要用户先登录。\n\n路由器支持多种守卫：\n\n- 用CanActivate来处理导航到某路由的情况。\n- 用CanActivateChild处理导航到子路由的情况。\n- 用CanDeactivate来处理从当前路由离开的情况。\n- 用Resolve在路由激活之前获取路由数据。\n- 用CanLoad来处理异步导航到某特性模块的情况。\n\n----------------------\n## 模块优化\n 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)\n\n```javascript\n    import { NgModule } from '@angular/core';\n    import { CommonModule } from '@angular/common';\n    import { FormsModule } from '@angular/forms';\n    import { MdlModule } from 'angular2-mdl';\n\n    @NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ],\n    exports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ]\n    })\n    export class SharedModule { }\n````\n\n这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可\n","source":"_posts/angular基础.md","raw":"---\ntitle: angular 基础\ncategories: angular\ncomments: true\n---\n\n## angular 与 vue 的区别\n\n* angular2 全部采用 TypeScript 编写，TypeScript （编译工具），它为 JS 带来了类似于 Java 和 C# 的静态类型，\n* vue 的双向绑定基于 ES5 的 getter/setter 来实现的，而 angular 是由自己实现一套模板编译规则们需要进行 “ 脏 ” 检查，而 vue 不需要，因此 vue 在性能上更高效。\n* angular 中，当 watcher 越来越多时会越来越慢，因为作用域的每一次变化\n\n<!--more-->\n\n## angular\n\n* 组件化，数据的单向中心。es6 的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下：\n* DOM 事件，譬如用户输入文本，点击按钮等。( ng-click )\n* XHR 响应事件 ( $http )\n* 浏览器 Location 变更事件 ( $location )\n* Timer 事件 ( $timeout , $interval )\n* 执行 $digest() 或 $apply()\n\n## react\n\n* 速度很快：来源于虚拟 DOM，只有在调用 get 和 set 的时候才会更新 DOM，而且是先更新虚拟 DOM 再更新实际的 DOM，由此更新 DOM 的次数少内容也会少很多。\n* FLUX 架构，react 更关注 UI 的组件化和数据的单向更新。可以直接有 es6 的一些语法。\n* 服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是 web 的执行。\n* 目标是 UI。\n* 本身是一个 MVC 中的 V。\n\n---\n\n## Angular 为表单内置了 4 种 css 样式\n\n* ng-valid 校验合法状态\n* ng-invalid 校验非法状态\n* ng-pristine 如果要使用原生的 form，需要设置这个值\n* ng-dirty 表单处于脏数据状态\n\n---\n\n## @Component\n\n* @Component 是 Angular 提供的装饰函数，用来描述 Component 的元数据\n* selector 指这个组件在 HTML 模板中的标签是什么\n* template 是嵌入（inline ）的 HTML 模板，如果使用单独文件可用 templateUrl。\n* styles 是嵌入（inline ）的 CSS 样式，如果使用单独文件可用 styleUrls。\n* providers 列出会在此模块中 “ 注入 ” 的服务 (service)- 依赖注入\n* bootstrap 指明哪个组件为引导组件 ( 比如 AppComponent), 当 angular 引导应用时，它会在 Dom 中渲染这个引导性组件，并把结果放进 index.html 的该组件的标签中。\n\n## @NgModule\n\n@NgModule 装饰器用来为模块定义元数据。declarations 列出了应用中的顶层组件，在 module 里面声明的组件在 module 范围内都可以直接使用，也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件，就想我们在 AppComponent 的模板末尾加上 <app-login></app-login> 一样。\n\n```javascript\nimport { HttpModule } from '@angular/http'\n\nimport { AppComponent } from './app.component'\nimport { LoginComponent } from './login/login.component'\n\n@NgModule({\n  declarations: [AppComponent, LoginComponent],\n  imports: [BrowserModule, FormsModule, HttpModule],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {}\n```\n\nNgModule 装饰器用来为模块定义元数据。\n\n* declarations 列出了应用中的顶层组件。\n* BrowerModule 提供了运行在浏览器中的应用所需要的关键服务 (service) 和指令 (Directive), 这个模块所在需要在浏览器中跑的应用都应用引用。\n* FormsModule 提供了表单处理和双向绑定等服务和指令。\n* HttpModule 提供 Htpp 请求和响应的服务。\n* providers 列出会在此模版中 “ 注入 ” 的服务（service ）。\n* bootstrap 指明哪个组件为引导性组件，并把结果放到 index.html 的该组件的元素标签中。\n* 静态引导 AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);\n\n---\n\n## 依赖注入\n\n如果不使用依赖注入，则需要 // 声明成员变量，其类型为 service 里面自定义的方法\n\n    ```javascript\n    //第一种：\n    service:AuthService;\n\n    constructor(){\n        this.service = new AuthService();//在构造中初始化service\n    }\n    //第二种：\n\n    providers: [\n    {provide: 'auth',  useClass: AuthService}\n    ]\n    ```\n\n* 第一种：由于实例化是在组件中进行的，意味着我们如果更改 service 的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量 service。当 import 相关的服务后，这是 import 将类型引入进来，而 provider 里面会配置这个类型的实例。\n* provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide 定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。\n\n```javascript\n       onstructor(@Inject('auth') private service) {\n   }\n```\n\n* @inject('auth'), 这个修饰符的意思是请到系统配置中找到名称为 auth 的那个依赖注入到我修饰的变量中。\n\n## 双向数据绑定\n\n* [(ngModel)]=\"username\" ,[] 的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉 [] 就是将 ngModel 赋值成 username 这个字符串。[] 的含义是单向绑定，就是将组件中给 model 赋的值会设置到 HTML 的 input 控件中。[()]是双向绑定。ngModel 是 FormModule 中提供的指令，它负责从 Domain Model 中创建一个 FormControl 的实例，并将这个实例和表单控件绑定 .\n* @Input() 是输入型绑定的修饰符，用于从数据从父组件传到子组件。\n\n---\n\n## 表单验证\n\n```html\n    <div>\n        <input required type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            />\n            {{usernameRef.valid}}\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            {{passwordRef.valid}}\n        <button (click)=\"onClick()\">Login</button>\n        </div>\n        <div>\n        <input #usernameRef type=\"text\">\n        <button (click)=\"onClick(usernameRef.value)\">Login</button>\n        </div>\n```\n\n1. 通过 #usernameRef = 'ngModel' 重新加入了引用，这个引用指向了 ngModel, 这个引用是要在模板中使用的所以加入这个引用。\n2. 在输入框中加入 #usernameRef，这个叫引用，引用的是 input 对象，如果想要传递 input 的值，可以用 usernameRef.value.\n\n```html\n    <div>\n        <input type=\"text\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            {{ usernameRef.errors | json }}\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n        <input required type=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n        <button (click)=\"onClick()\">Login</button>\n    </div>\n```\n\n\\*ngIf = \"usernameRef.error?.required\" 的意思是当 usernameRef.error.required 为 true 的时候显示 div 标签\n\n```html\n    <div>\n        <form #formRef=\"ngForm\" (ngSubmit)=\"onSubmit(formRef.value)\">\n        <fieldset ngModelGroup=\"login\">\n            <input type=\"text\"\n            name=\"username\"\n            [(ngModel)]=\"username\"\n            #usernameRef=\"ngModel\"\n            required\n            minlength=\"3\"\n            />\n            <div *ngIf=\"usernameRef.errors?.required\">this is required</div>\n            <div *ngIf=\"usernameRef.errors?.minlength\">should be at least 3 charactors</div>\n            <input type=\"password\"\n            name=\"password\"\n            [(ngModel)]=\"password\"\n            #passwordRef=\"ngModel\"\n            required\n            />\n            <div *ngIf=\"passwordRef.errors?.required\">this is required</div>\n            <button (click)=\"onClick()\">Login</button>\n            <button type=\"submit\">Submit</button>\n            </fieldset>\n        </form>\n        </div>\n```\n\n* ngModel 会注册成 Form 的子控件，注册控件需要 name ，这个要求我们显示的指定对应控件的 name ，因此需要为 input 增加 name 属性，在 formREF.value 中包含了表单所有填写项的值\n\n* 有时在表单相中表单项过多时，就使用 HTML 中的 fieldset 标签用来处理。<fieldset ngModelGroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。\n\n---\n\n## 路由\n\n路径配置的顺序是非常重要的，angular2 使用 “ 先匹配优先 ” 的原则。\n\n* redirectTo 重定向\n  ## service\n\n```javascript\n    //post /todos\n    addTodo(desc:string):Promise<Todo>{\n        let todo={\n            id:UUID.UUID(),\n            desc:desc,\n            completed:false\n        };\n        return this.http\n            .post(this.api_url,JSON.stringfy(todo),{header:this.headers})\n            .toPromise()\n            .then(res=>res.json().data as Todo)\n            .catch(this.handleError);\n    }\n```\n\n---\n\n````javascript\n    inputValue: string = '';\n    @Input() placeholder: string = 'What needs to be done?';\n    @Input() delay: number = 300;\n\n    //detect the input value and output this to parent\n    @Output() textChanges = new EventEmitter<string>();\n    //detect the enter keyup event and output this to parent\n    @Output() onEnterUp = new EventEmitter<boolean>();\n    ```\n- placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。\n- 由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。\n- export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.\n\n\n--------------------------\n## 验证用户帐户的流程\n- UserService:用于通过用户名查找用户并返回用户\n- AuthService:用于认证用户，其中需要利用UserService 的方法。\n- AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。\n- @SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,\nparentModule参数也就被赋值为空。\n\n----------------\n## 路由守卫\n应用场景如下:\n该用户可能无权导航到目标组件。导航前需要用户先登录。\n\n路由器支持多种守卫：\n\n- 用CanActivate来处理导航到某路由的情况。\n- 用CanActivateChild处理导航到子路由的情况。\n- 用CanDeactivate来处理从当前路由离开的情况。\n- 用Resolve在路由激活之前获取路由数据。\n- 用CanLoad来处理异步导航到某特性模块的情况。\n\n----------------------\n## 模块优化\n 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)\n\n```javascript\n    import { NgModule } from '@angular/core';\n    import { CommonModule } from '@angular/common';\n    import { FormsModule } from '@angular/forms';\n    import { MdlModule } from 'angular2-mdl';\n\n    @NgModule({\n    imports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ],\n    exports: [\n        CommonModule,\n        FormsModule,\n        MdlModule\n    ]\n    })\n    export class SharedModule { }\n````\n\n这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可\n","slug":"angular基础","published":1,"date":"2018-03-20T03:29:41.819Z","updated":"2018-03-20T03:29:41.819Z","_id":"cjepksjn6000j8gv6quat0s0p","layout":"post","photos":[],"link":"","content":"<h2 id=\"angular-与-vue-的区别\"><a href=\"#angular-与-vue-的区别\" class=\"headerlink\" title=\"angular 与 vue 的区别\"></a>angular 与 vue 的区别</h2><ul>\n<li>angular2 全部采用 TypeScript 编写，TypeScript （编译工具），它为 JS 带来了类似于 Java 和 C# 的静态类型，</li>\n<li>vue 的双向绑定基于 ES5 的 getter/setter 来实现的，而 angular 是由自己实现一套模板编译规则们需要进行 “ 脏 ” 检查，而 vue 不需要，因此 vue 在性能上更高效。</li>\n<li>angular 中，当 watcher 越来越多时会越来越慢，因为作用域的每一次变化</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"angular\"><a href=\"#angular\" class=\"headerlink\" title=\"angular\"></a>angular</h2><ul>\n<li>组件化，数据的单向中心。es6 的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下：</li>\n<li>DOM 事件，譬如用户输入文本，点击按钮等。( ng-click )</li>\n<li>XHR 响应事件 ( $http )</li>\n<li>浏览器 Location 变更事件 ( $location )</li>\n<li>Timer 事件 ( $timeout , $interval )</li>\n<li>执行 $digest() 或 $apply()</li>\n</ul>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h2><ul>\n<li>速度很快：来源于虚拟 DOM，只有在调用 get 和 set 的时候才会更新 DOM，而且是先更新虚拟 DOM 再更新实际的 DOM，由此更新 DOM 的次数少内容也会少很多。</li>\n<li>FLUX 架构，react 更关注 UI 的组件化和数据的单向更新。可以直接有 es6 的一些语法。</li>\n<li>服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是 web 的执行。</li>\n<li>目标是 UI。</li>\n<li>本身是一个 MVC 中的 V。</li>\n</ul>\n<hr>\n<h2 id=\"Angular-为表单内置了-4-种-css-样式\"><a href=\"#Angular-为表单内置了-4-种-css-样式\" class=\"headerlink\" title=\"Angular 为表单内置了 4 种 css 样式\"></a>Angular 为表单内置了 4 种 css 样式</h2><ul>\n<li>ng-valid 校验合法状态</li>\n<li>ng-invalid 校验非法状态</li>\n<li>ng-pristine 如果要使用原生的 form，需要设置这个值</li>\n<li>ng-dirty 表单处于脏数据状态</li>\n</ul>\n<hr>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h2><ul>\n<li>@Component 是 Angular 提供的装饰函数，用来描述 Component 的元数据</li>\n<li>selector 指这个组件在 HTML 模板中的标签是什么</li>\n<li>template 是嵌入（inline ）的 HTML 模板，如果使用单独文件可用 templateUrl。</li>\n<li>styles 是嵌入（inline ）的 CSS 样式，如果使用单独文件可用 styleUrls。</li>\n<li>providers 列出会在此模块中 “ 注入 ” 的服务 (service)- 依赖注入</li>\n<li>bootstrap 指明哪个组件为引导组件 ( 比如 AppComponent), 当 angular 引导应用时，它会在 Dom 中渲染这个引导性组件，并把结果放进 index.html 的该组件的标签中。</li>\n</ul>\n<h2 id=\"NgModule\"><a href=\"#NgModule\" class=\"headerlink\" title=\"@NgModule\"></a>@NgModule</h2><p>@NgModule 装饰器用来为模块定义元数据。declarations 列出了应用中的顶层组件，在 module 里面声明的组件在 module 范围内都可以直接使用，也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件，就想我们在 AppComponent 的模板末尾加上 <app-login></app-login> 一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; HttpModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; LoginComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./login/login.component'</span></span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declarations: [AppComponent, LoginComponent],</span><br><span class=\"line\">  imports: [BrowserModule, FormsModule, HttpModule],</span><br><span class=\"line\">  providers: [],</span><br><span class=\"line\">  bootstrap: [AppComponent]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>NgModule 装饰器用来为模块定义元数据。</p>\n<ul>\n<li>declarations 列出了应用中的顶层组件。</li>\n<li>BrowerModule 提供了运行在浏览器中的应用所需要的关键服务 (service) 和指令 (Directive), 这个模块所在需要在浏览器中跑的应用都应用引用。</li>\n<li>FormsModule 提供了表单处理和双向绑定等服务和指令。</li>\n<li>HttpModule 提供 Htpp 请求和响应的服务。</li>\n<li>providers 列出会在此模版中 “ 注入 ” 的服务（service ）。</li>\n<li>bootstrap 指明哪个组件为引导性组件，并把结果放到 index.html 的该组件的元素标签中。</li>\n<li>静态引导 AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);</li>\n</ul>\n<hr>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>如果不使用依赖注入，则需要 // 声明成员变量，其类型为 service 里面自定义的方法</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种：</span></span><br><span class=\"line\">service:AuthService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.service = <span class=\"keyword\">new</span> AuthService();<span class=\"comment\">//在构造中初始化service</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二种：</span></span><br><span class=\"line\"></span><br><span class=\"line\">providers: [</span><br><span class=\"line\">&#123;<span class=\"attr\">provide</span>: <span class=\"string\">'auth'</span>,  <span class=\"attr\">useClass</span>: AuthService&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>第一种：由于实例化是在组件中进行的，意味着我们如果更改 service 的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量 service。当 import 相关的服务后，这是 import 将类型引入进来，而 provider 里面会配置这个类型的实例。</li>\n<li>provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide 定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    onstructor(@Inject(<span class=\"string\">'auth'</span>) private service) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@inject(‘auth’), 这个修饰符的意思是请到系统配置中找到名称为 auth 的那个依赖注入到我修饰的变量中。</li>\n</ul>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><ul>\n<li>[(ngModel)]=”username” ,[] 的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉 [] 就是将 ngModel 赋值成 username 这个字符串。[] 的含义是单向绑定，就是将组件中给 model 赋的值会设置到 HTML 的 input 控件中。[()]是双向绑定。ngModel 是 FormModule 中提供的指令，它负责从 Domain Model 中创建一个 FormControl 的实例，并将这个实例和表单控件绑定 .</li>\n<li>@Input() 是输入型绑定的修饰符，用于从数据从父组件传到子组件。</li>\n</ul>\n<hr>\n<h2 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;usernameRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;passwordRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">usernameRef</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick(usernameRef.value)\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过 #usernameRef = ‘ngModel’ 重新加入了引用，这个引用指向了 ngModel, 这个引用是要在模板中使用的所以加入这个引用。</li>\n<li>在输入框中加入 #usernameRef，这个叫引用，引用的是 input 对象，如果想要传递 input 的值，可以用 usernameRef.value.</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123; usernameRef.errors | json &#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>*ngIf = “usernameRef.error?.required” 的意思是当 usernameRef.error.required 为 true 的时候显示 div 标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">formRef</span>=<span class=\"string\">\"ngForm\"</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">\"onSubmit(formRef.value)\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fieldset</span> <span class=\"attr\">ngModelGroup</span>=<span class=\"string\">\"login\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>ngModel 会注册成 Form 的子控件，注册控件需要 name ，这个要求我们显示的指定对应控件的 name ，因此需要为 input 增加 name 属性，在 formREF.value 中包含了表单所有填写项的值</p>\n</li>\n<li><p>有时在表单相中表单项过多时，就使用 HTML 中的 fieldset 标签用来处理。<fieldset ngmodelgroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。</fieldset></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>路径配置的顺序是非常重要的，angular2 使用 “ 先匹配优先 ” 的原则。</p>\n<ul>\n<li>redirectTo 重定向<h2 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h2></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//post /todos</span></span><br><span class=\"line\">addTodo(desc:string):<span class=\"built_in\">Promise</span>&lt;Todo&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> todo=&#123;</span><br><span class=\"line\">        id:UUID.UUID(),</span><br><span class=\"line\">        desc:desc,</span><br><span class=\"line\">        completed:<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http</span><br><span class=\"line\">        .post(<span class=\"keyword\">this</span>.api_url,<span class=\"built_in\">JSON</span>.stringfy(todo),&#123;<span class=\"attr\">header</span>:<span class=\"keyword\">this</span>.headers&#125;)</span><br><span class=\"line\">        .toPromise()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>res.json().data <span class=\"keyword\">as</span> Todo)</span><br><span class=\"line\">        .catch(<span class=\"keyword\">this</span>.handleError);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    inputValue: string = <span class=\"string\">''</span>;</span><br><span class=\"line\">    @Input() placeholder: string = <span class=\"string\">'What needs to be done?'</span>;</span><br><span class=\"line\">    @Input() delay: number = <span class=\"number\">300</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//detect the input value and output this to parent</span></span><br><span class=\"line\">    @Output() textChanges = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//detect the enter keyup event and output this to parent</span></span><br><span class=\"line\">    @Output() onEnterUp = <span class=\"keyword\">new</span> EventEmitter&lt;boolean&gt;();</span><br><span class=\"line\">    <span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">- placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。</span></span><br><span class=\"line\"><span class=\"string\">- 由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。</span></span><br><span class=\"line\"><span class=\"string\">- export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">--------------------------</span></span><br><span class=\"line\"><span class=\"string\">## 验证用户帐户的流程</span></span><br><span class=\"line\"><span class=\"string\">- UserService:用于通过用户名查找用户并返回用户</span></span><br><span class=\"line\"><span class=\"string\">- AuthService:用于认证用户，其中需要利用UserService 的方法。</span></span><br><span class=\"line\"><span class=\"string\">- AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。</span></span><br><span class=\"line\"><span class=\"string\">- @SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,</span></span><br><span class=\"line\"><span class=\"string\">parentModule参数也就被赋值为空。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">----------------</span></span><br><span class=\"line\"><span class=\"string\">## 路由守卫</span></span><br><span class=\"line\"><span class=\"string\">应用场景如下:</span></span><br><span class=\"line\"><span class=\"string\">该用户可能无权导航到目标组件。导航前需要用户先登录。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">路由器支持多种守卫：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 用CanActivate来处理导航到某路由的情况。</span></span><br><span class=\"line\"><span class=\"string\">- 用CanActivateChild处理导航到子路由的情况。</span></span><br><span class=\"line\"><span class=\"string\">- 用CanDeactivate来处理从当前路由离开的情况。</span></span><br><span class=\"line\"><span class=\"string\">- 用Resolve在路由激活之前获取路由数据。</span></span><br><span class=\"line\"><span class=\"string\">- 用CanLoad来处理异步导航到某特性模块的情况。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">----------------------</span></span><br><span class=\"line\"><span class=\"string\">## 模块优化</span></span><br><span class=\"line\"><span class=\"string\"> 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; CommonModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/common'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; FormsModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/forms'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; MdlModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2-mdl'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NgModule(&#123;</span><br><span class=\"line\">    imports: [</span><br><span class=\"line\">        CommonModule,</span><br><span class=\"line\">        FormsModule,</span><br><span class=\"line\">        MdlModule</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    exports: [</span><br><span class=\"line\">        CommonModule,</span><br><span class=\"line\">        FormsModule,</span><br><span class=\"line\">        MdlModule</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"angular-与-vue-的区别\"><a href=\"#angular-与-vue-的区别\" class=\"headerlink\" title=\"angular 与 vue 的区别\"></a>angular 与 vue 的区别</h2><ul>\n<li>angular2 全部采用 TypeScript 编写，TypeScript （编译工具），它为 JS 带来了类似于 Java 和 C# 的静态类型，</li>\n<li>vue 的双向绑定基于 ES5 的 getter/setter 来实现的，而 angular 是由自己实现一套模板编译规则们需要进行 “ 脏 ” 检查，而 vue 不需要，因此 vue 在性能上更高效。</li>\n<li>angular 中，当 watcher 越来越多时会越来越慢，因为作用域的每一次变化</li>\n</ul>","more":"<h2 id=\"angular\"><a href=\"#angular\" class=\"headerlink\" title=\"angular\"></a>angular</h2><ul>\n<li>组件化，数据的单向中心。es6 的语法。angular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然 Google 不会这么 low，angular 只有在指定的事件触发时进入脏值检测，大致如下：</li>\n<li>DOM 事件，譬如用户输入文本，点击按钮等。( ng-click )</li>\n<li>XHR 响应事件 ( $http )</li>\n<li>浏览器 Location 变更事件 ( $location )</li>\n<li>Timer 事件 ( $timeout , $interval )</li>\n<li>执行 $digest() 或 $apply()</li>\n</ul>\n<h2 id=\"react\"><a href=\"#react\" class=\"headerlink\" title=\"react\"></a>react</h2><ul>\n<li>速度很快：来源于虚拟 DOM，只有在调用 get 和 set 的时候才会更新 DOM，而且是先更新虚拟 DOM 再更新实际的 DOM，由此更新 DOM 的次数少内容也会少很多。</li>\n<li>FLUX 架构，react 更关注 UI 的组件化和数据的单向更新。可以直接有 es6 的一些语法。</li>\n<li>服务器端渲染，单页应用的缺陷是对于搜索引擎有很大的限制。react 的解决的方案是在服务器上预渲染应用然后发送到服务端，但是爬虫是依赖的服务端的响应而不是 web 的执行。</li>\n<li>目标是 UI。</li>\n<li>本身是一个 MVC 中的 V。</li>\n</ul>\n<hr>\n<h2 id=\"Angular-为表单内置了-4-种-css-样式\"><a href=\"#Angular-为表单内置了-4-种-css-样式\" class=\"headerlink\" title=\"Angular 为表单内置了 4 种 css 样式\"></a>Angular 为表单内置了 4 种 css 样式</h2><ul>\n<li>ng-valid 校验合法状态</li>\n<li>ng-invalid 校验非法状态</li>\n<li>ng-pristine 如果要使用原生的 form，需要设置这个值</li>\n<li>ng-dirty 表单处于脏数据状态</li>\n</ul>\n<hr>\n<h2 id=\"Component\"><a href=\"#Component\" class=\"headerlink\" title=\"@Component\"></a>@Component</h2><ul>\n<li>@Component 是 Angular 提供的装饰函数，用来描述 Component 的元数据</li>\n<li>selector 指这个组件在 HTML 模板中的标签是什么</li>\n<li>template 是嵌入（inline ）的 HTML 模板，如果使用单独文件可用 templateUrl。</li>\n<li>styles 是嵌入（inline ）的 CSS 样式，如果使用单独文件可用 styleUrls。</li>\n<li>providers 列出会在此模块中 “ 注入 ” 的服务 (service)- 依赖注入</li>\n<li>bootstrap 指明哪个组件为引导组件 ( 比如 AppComponent), 当 angular 引导应用时，它会在 Dom 中渲染这个引导性组件，并把结果放进 index.html 的该组件的标签中。</li>\n</ul>\n<h2 id=\"NgModule\"><a href=\"#NgModule\" class=\"headerlink\" title=\"@NgModule\"></a>@NgModule</h2><p>@NgModule 装饰器用来为模块定义元数据。declarations 列出了应用中的顶层组件，在 module 里面声明的组件在 module 范围内都可以直接使用，也就是说在同一 module 里面的任何 Component 都可以在其模板文件中直接使用声明的组件，就想我们在 AppComponent 的模板末尾加上 <app-login></app-login> 一样。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; HttpModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/http'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; AppComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./app.component'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; LoginComponent &#125; <span class=\"keyword\">from</span> <span class=\"string\">'./login/login.component'</span></span><br><span class=\"line\"></span><br><span class=\"line\">@NgModule(&#123;</span><br><span class=\"line\">  declarations: [AppComponent, LoginComponent],</span><br><span class=\"line\">  imports: [BrowserModule, FormsModule, HttpModule],</span><br><span class=\"line\">  providers: [],</span><br><span class=\"line\">  bootstrap: [AppComponent]</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>NgModule 装饰器用来为模块定义元数据。</p>\n<ul>\n<li>declarations 列出了应用中的顶层组件。</li>\n<li>BrowerModule 提供了运行在浏览器中的应用所需要的关键服务 (service) 和指令 (Directive), 这个模块所在需要在浏览器中跑的应用都应用引用。</li>\n<li>FormsModule 提供了表单处理和双向绑定等服务和指令。</li>\n<li>HttpModule 提供 Htpp 请求和响应的服务。</li>\n<li>providers 列出会在此模版中 “ 注入 ” 的服务（service ）。</li>\n<li>bootstrap 指明哪个组件为引导性组件，并把结果放到 index.html 的该组件的元素标签中。</li>\n<li>静态引导 AppModuleNgFactory platformBrowser().bootstrapModuleFactory(AppModuleNgFactory);</li>\n</ul>\n<hr>\n<h2 id=\"依赖注入\"><a href=\"#依赖注入\" class=\"headerlink\" title=\"依赖注入\"></a>依赖注入</h2><p>如果不使用依赖注入，则需要 // 声明成员变量，其类型为 service 里面自定义的方法</p>\n<pre><code><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//第一种：</span></span><br><span class=\"line\">service:AuthService;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">constructor</span>()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.service = <span class=\"keyword\">new</span> AuthService();<span class=\"comment\">//在构造中初始化service</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//第二种：</span></span><br><span class=\"line\"></span><br><span class=\"line\">providers: [</span><br><span class=\"line\">&#123;<span class=\"attr\">provide</span>: <span class=\"string\">'auth'</span>,  <span class=\"attr\">useClass</span>: AuthService&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li>第一种：由于实例化是在组件中进行的，意味着我们如果更改 service 的构造函数的话，组件也需要更改。如果使用依赖注入的话，就不需要显示声明成员变量 service。当 import 相关的服务后，这是 import 将类型引入进来，而 provider 里面会配置这个类型的实例。</li>\n<li>provider 是一个数组，这里配置将要注入到其他组件中的服务配置。provide 定义了这个服务的名称，有需要注入这个服务的就引用这个名称就好。useClass 指明这个名称对应的服务是一个类。这样定义之后就能在任意组件中注入这个依赖了。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    onstructor(@Inject(<span class=\"string\">'auth'</span>) private service) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>@inject(‘auth’), 这个修饰符的意思是请到系统配置中找到名称为 auth 的那个依赖注入到我修饰的变量中。</li>\n</ul>\n<h2 id=\"双向数据绑定\"><a href=\"#双向数据绑定\" class=\"headerlink\" title=\"双向数据绑定\"></a>双向数据绑定</h2><ul>\n<li>[(ngModel)]=”username” ,[] 的作用是将等号后面当成表达式来解析而不是当成字符串，如果去掉 [] 就是将 ngModel 赋值成 username 这个字符串。[] 的含义是单向绑定，就是将组件中给 model 赋的值会设置到 HTML 的 input 控件中。[()]是双向绑定。ngModel 是 FormModule 中提供的指令，它负责从 Domain Model 中创建一个 FormControl 的实例，并将这个实例和表单控件绑定 .</li>\n<li>@Input() 是输入型绑定的修饰符，用于从数据从父组件传到子组件。</li>\n</ul>\n<hr>\n<h2 id=\"表单验证\"><a href=\"#表单验证\" class=\"headerlink\" title=\"表单验证\"></a>表单验证</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;usernameRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123;passwordRef.valid&#125;&#125;</span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> #<span class=\"attr\">usernameRef</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick(usernameRef.value)\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>通过 #usernameRef = ‘ngModel’ 重新加入了引用，这个引用指向了 ngModel, 这个引用是要在模板中使用的所以加入这个引用。</li>\n<li>在输入框中加入 #usernameRef，这个叫引用，引用的是 input 对象，如果想要传递 input 的值，可以用 usernameRef.value.</li>\n</ol>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        &#123;&#123; usernameRef.errors | json &#125;&#125;</span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">required</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>*ngIf = “usernameRef.error?.required” 的意思是当 usernameRef.error.required 为 true 的时候显示 div 标签</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">form</span> #<span class=\"attr\">formRef</span>=<span class=\"string\">\"ngForm\"</span> (<span class=\"attr\">ngSubmit</span>)=<span class=\"string\">\"onSubmit(formRef.value)\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">fieldset</span> <span class=\"attr\">ngModelGroup</span>=<span class=\"string\">\"login\"</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"username\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">usernameRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">minlength</span>=<span class=\"string\">\"3\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"usernameRef.errors?.minlength\"</span>&gt;</span>should be at least 3 charactors<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">name</span>=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        [(<span class=\"attr\">ngModel</span>)]=<span class=\"string\">\"password\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        #<span class=\"attr\">passwordRef</span>=<span class=\"string\">\"ngModel\"</span></span></span><br><span class=\"line\"><span class=\"tag\">        <span class=\"attr\">required</span></span></span><br><span class=\"line\"><span class=\"tag\">        /&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">div</span> *<span class=\"attr\">ngIf</span>=<span class=\"string\">\"passwordRef.errors?.required\"</span>&gt;</span>this is required<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> (<span class=\"attr\">click</span>)=<span class=\"string\">\"onClick()\"</span>&gt;</span>Login<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span>=<span class=\"string\">\"submit\"</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>ngModel 会注册成 Form 的子控件，注册控件需要 name ，这个要求我们显示的指定对应控件的 name ，因此需要为 input 增加 name 属性，在 formREF.value 中包含了表单所有填写项的值</p>\n</li>\n<li><p>有时在表单相中表单项过多时，就使用 HTML 中的 fieldset 标签用来处理。<fieldset ngmodelgroup=\"login\"> 意味着我们对于 fieldset 之内的数据都分组到了 login 对象中。</fieldset></p>\n</li>\n</ul>\n<hr>\n<h2 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h2><p>路径配置的顺序是非常重要的，angular2 使用 “ 先匹配优先 ” 的原则。</p>\n<ul>\n<li>redirectTo 重定向<h2 id=\"service\"><a href=\"#service\" class=\"headerlink\" title=\"service\"></a>service</h2></li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//post /todos</span></span><br><span class=\"line\">addTodo(desc:string):<span class=\"built_in\">Promise</span>&lt;Todo&gt;&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> todo=&#123;</span><br><span class=\"line\">        id:UUID.UUID(),</span><br><span class=\"line\">        desc:desc,</span><br><span class=\"line\">        completed:<span class=\"literal\">false</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.http</span><br><span class=\"line\">        .post(<span class=\"keyword\">this</span>.api_url,<span class=\"built_in\">JSON</span>.stringfy(todo),&#123;<span class=\"attr\">header</span>:<span class=\"keyword\">this</span>.headers&#125;)</span><br><span class=\"line\">        .toPromise()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">res</span>=&gt;</span>res.json().data <span class=\"keyword\">as</span> Todo)</span><br><span class=\"line\">        .catch(<span class=\"keyword\">this</span>.handleError);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    inputValue: string = <span class=\"string\">''</span>;</span><br><span class=\"line\">    @Input() placeholder: string = <span class=\"string\">'What needs to be done?'</span>;</span><br><span class=\"line\">    @Input() delay: number = <span class=\"number\">300</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//detect the input value and output this to parent</span></span><br><span class=\"line\">    @Output() textChanges = <span class=\"keyword\">new</span> EventEmitter&lt;string&gt;();</span><br><span class=\"line\">    <span class=\"comment\">//detect the enter keyup event and output this to parent</span></span><br><span class=\"line\">    @Output() onEnterUp = <span class=\"keyword\">new</span> EventEmitter&lt;boolean&gt;();</span><br><span class=\"line\">    <span class=\"string\">``</span><span class=\"string\">`</span></span><br><span class=\"line\"><span class=\"string\">- placeholder和delay作为2个输入型变量，这样在引入标签中就可以设置这两个属性了。</span></span><br><span class=\"line\"><span class=\"string\">- 由@Output修饰的onTextChanges 和 onEnterUp，这两个变量都定义了EventEmitter(事件发射器)。</span></span><br><span class=\"line\"><span class=\"string\">- export const routing = RouterModule.forChild(routes);，用的是forChild而不是forRoot,因为forRoot只能用于根目录，所有非跟模块的其他模块都只能用forChild.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">--------------------------</span></span><br><span class=\"line\"><span class=\"string\">## 验证用户帐户的流程</span></span><br><span class=\"line\"><span class=\"string\">- UserService:用于通过用户名查找用户并返回用户</span></span><br><span class=\"line\"><span class=\"string\">- AuthService:用于认证用户，其中需要利用UserService 的方法。</span></span><br><span class=\"line\"><span class=\"string\">- AuthGuard:路由拦截器，用于拦截到路由后通过Authservice来知道此用户是否有权限访问路由。根据结果导航到不同路径。</span></span><br><span class=\"line\"><span class=\"string\">- @SkipSelf装饰器意味着在当前注入器的所有祖先注入器中寻找，如果注入器找不到想要的提供商时就会抛出一个错误。但是@Optional装饰器表示找不到该服务则会返回null,</span></span><br><span class=\"line\"><span class=\"string\">parentModule参数也就被赋值为空。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">----------------</span></span><br><span class=\"line\"><span class=\"string\">## 路由守卫</span></span><br><span class=\"line\"><span class=\"string\">应用场景如下:</span></span><br><span class=\"line\"><span class=\"string\">该用户可能无权导航到目标组件。导航前需要用户先登录。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">路由器支持多种守卫：</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">- 用CanActivate来处理导航到某路由的情况。</span></span><br><span class=\"line\"><span class=\"string\">- 用CanActivateChild处理导航到子路由的情况。</span></span><br><span class=\"line\"><span class=\"string\">- 用CanDeactivate来处理从当前路由离开的情况。</span></span><br><span class=\"line\"><span class=\"string\">- 用Resolve在路由激活之前获取路由数据。</span></span><br><span class=\"line\"><span class=\"string\">- 用CanLoad来处理异步导航到某特性模块的情况。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">----------------------</span></span><br><span class=\"line\"><span class=\"string\">## 模块优化</span></span><br><span class=\"line\"><span class=\"string\"> 各个模块定义，发现我们不断地重复引入了CommonModule、FormsModule、MdlModule,这些组件常用，就可以建立一个ShareModule(src\\app\\shared\\shared.module.ts)</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; NgModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/core'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; CommonModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/common'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; FormsModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'@angular/forms'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">import</span> &#123; MdlModule &#125; <span class=\"keyword\">from</span> <span class=\"string\">'angular2-mdl'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    @NgModule(&#123;</span><br><span class=\"line\">    imports: [</span><br><span class=\"line\">        CommonModule,</span><br><span class=\"line\">        FormsModule,</span><br><span class=\"line\">        MdlModule</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    exports: [</span><br><span class=\"line\">        CommonModule,</span><br><span class=\"line\">        FormsModule,</span><br><span class=\"line\">        MdlModule</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    <span class=\"keyword\">export</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SharedModule</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n<p>这个模块的作用是将常用的模块打包起来，将常用的模块导入又导出，这样在其他模块中值需引入这个模块即可</p>"},{"title":"css 小技巧","_content":"\ncss 在开发中的填坑总结\n\n<!--more-->\n\n## 一、利用 css 的 content 属性 attr 抓取资料\n\n想要获取伪元素，可以用以下写法：\n\n```html\n<div data-msg=\"open\"></div>\ndiv:hover:after{\n    content:attr(data-mag);\n}\n```\n\n## 二、利用：valid 和：invalid 来做表单即使校验\n\n* :required 伪类指定具有 required 属性的表单元素\n* :valid 伪类指定一个通过匹配正确的所要求的表单元素\n* :invalid 伪类指定一个不匹配指定要求的表单元素\n\n## 三、writing-mode\n\n使用 writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;\n\n## 四、实现鼠标悬浮内容自动撑开的过渡动画\n\n需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：\n\n```html\n<ul>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n</ul>\n.bd {\n  max-height:0;\n  overflow:hidden;\n  transition: all 1s ease-out;\n}\nli:hover .bd {\n  max-height: 600px;\n  transition-timing-function: ease-in;\n}\n```\n\n## 五、移动端 web 页面支持弹性滚动\n\n-webkit-overflow-scrolling: touch;\n\n## 六、美化浏览器自带的 radio ，checkbox 属性\n\n```html\n<div class=\"radio-beauty-container\">\n    <label>\n        <span class=\"radio-name\">前端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName1\" hidden/>\n        <label for=\"radioName1\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">后端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName2\" hidden/>\n        <label for=\"radioName2\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">全栈工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName3\" hidden/>\n        <label for=\"radioName3\" class=\"radio-beauty\"></label>\n    </label>\n</div>\n.radio-beauty-container {\n    font-size: 0;\n    $bgc: green;\n    %common {\n        padding: 2px;\n        background-color: $bgc;\n        background-clip: content-box;\n    }\n    .radio-name {\n        vertical-align: middle;\n        font-size: 16px;\n    }\n    .radio-beauty {\n        width: 18px;\n        height: 18px;\n        box-sizing: border-box;\n        display: inline-block;\n        border: 1px solid $bgc;\n        vertical-align: middle;\n        margin: 0 15px 0 3px;\n        border-radius: 50%;\n        &:hover {\n            box-shadow: 0 0 7px $bgc;\n            @extend %common;\n        }\n    }\n    input[type=\"radio\"]:checked+.radio-beauty {\n        @extend %common;\n    }\n}\n```\n\n## 七、改变 input 焦点光标的颜色\n\n```html\n<input value=\"This field uses a default caret.\" />\n<input class=\"custom\" value=\"I have a custom caret color!\" />\ninput {\n  caret-color: auto;\n  display: block;\n  margin-bottom: .5em;\n}\n\ninput.custom {\n  caret-color: red;\n}\n```\n\n## 八、rem 布局不再使用 JavaScript 设置\n\n现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：\n\n```html\nhtml{\nfont-size: 100vw / 750\n}\n```\n\n## 切角效果实现\n\n切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成 45° 的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。\n\n![](https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67)\n\n## BFC（快格式化上下文）\n它决定了元素如何对其内容进行定位，以及与其他元素的关系的相互作用。当涉及到可视化布局时，BFC提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境元素不会影响到其他环境中的布局。\n\n### BFC 的作用：\n\n- 可以包含浮动元素\n- 不被浮动元素覆盖\n- 阻止父子元素的margin折叠\n\n### BFC的特征：\n- 内部的BOX会在垂直方向，一个接一个地放置。\n- BOX垂直方向的距离由margin决定。属于同一个BFC的两个BOX的margin会发生重叠。\n- BFC的区域不会与float BOX 重叠。\n- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也是如此。\n- 计算BFC的高度时，float元素也会参与计算。\n\n### 如何触发BFC？\n- float 的值部位none。\n- position 的值不为static 或者是relative。\n- display 的值为table-cell,table-caption,inline-block,flex,或者inline-flex中的一个。\n- overflow的值不为visible。\n\n","source":"_posts/css-小技巧.md","raw":"---\ntitle: css 小技巧\ncategories: css\n---\n\ncss 在开发中的填坑总结\n\n<!--more-->\n\n## 一、利用 css 的 content 属性 attr 抓取资料\n\n想要获取伪元素，可以用以下写法：\n\n```html\n<div data-msg=\"open\"></div>\ndiv:hover:after{\n    content:attr(data-mag);\n}\n```\n\n## 二、利用：valid 和：invalid 来做表单即使校验\n\n* :required 伪类指定具有 required 属性的表单元素\n* :valid 伪类指定一个通过匹配正确的所要求的表单元素\n* :invalid 伪类指定一个不匹配指定要求的表单元素\n\n## 三、writing-mode\n\n使用 writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;\n\n## 四、实现鼠标悬浮内容自动撑开的过渡动画\n\n需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：\n\n```html\n<ul>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n  <li>\n    <div class=\"hd\"> 列表1 </div>\n    <div class=\"bd\">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>\n  </li>\n</ul>\n.bd {\n  max-height:0;\n  overflow:hidden;\n  transition: all 1s ease-out;\n}\nli:hover .bd {\n  max-height: 600px;\n  transition-timing-function: ease-in;\n}\n```\n\n## 五、移动端 web 页面支持弹性滚动\n\n-webkit-overflow-scrolling: touch;\n\n## 六、美化浏览器自带的 radio ，checkbox 属性\n\n```html\n<div class=\"radio-beauty-container\">\n    <label>\n        <span class=\"radio-name\">前端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName1\" hidden/>\n        <label for=\"radioName1\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">后端工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName2\" hidden/>\n        <label for=\"radioName2\" class=\"radio-beauty\"></label>\n    </label>\n    <label>\n        <span class=\"radio-name\">全栈工程师</span>\n        <input type=\"radio\" name=\"radioName\" id=\"radioName3\" hidden/>\n        <label for=\"radioName3\" class=\"radio-beauty\"></label>\n    </label>\n</div>\n.radio-beauty-container {\n    font-size: 0;\n    $bgc: green;\n    %common {\n        padding: 2px;\n        background-color: $bgc;\n        background-clip: content-box;\n    }\n    .radio-name {\n        vertical-align: middle;\n        font-size: 16px;\n    }\n    .radio-beauty {\n        width: 18px;\n        height: 18px;\n        box-sizing: border-box;\n        display: inline-block;\n        border: 1px solid $bgc;\n        vertical-align: middle;\n        margin: 0 15px 0 3px;\n        border-radius: 50%;\n        &:hover {\n            box-shadow: 0 0 7px $bgc;\n            @extend %common;\n        }\n    }\n    input[type=\"radio\"]:checked+.radio-beauty {\n        @extend %common;\n    }\n}\n```\n\n## 七、改变 input 焦点光标的颜色\n\n```html\n<input value=\"This field uses a default caret.\" />\n<input class=\"custom\" value=\"I have a custom caret color!\" />\ninput {\n  caret-color: auto;\n  display: block;\n  margin-bottom: .5em;\n}\n\ninput.custom {\n  caret-color: red;\n}\n```\n\n## 八、rem 布局不再使用 JavaScript 设置\n\n现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：\n\n```html\nhtml{\nfont-size: 100vw / 750\n}\n```\n\n## 切角效果实现\n\n切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成 45° 的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。\n\n![](https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67)\n\n## BFC（快格式化上下文）\n它决定了元素如何对其内容进行定位，以及与其他元素的关系的相互作用。当涉及到可视化布局时，BFC提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境元素不会影响到其他环境中的布局。\n\n### BFC 的作用：\n\n- 可以包含浮动元素\n- 不被浮动元素覆盖\n- 阻止父子元素的margin折叠\n\n### BFC的特征：\n- 内部的BOX会在垂直方向，一个接一个地放置。\n- BOX垂直方向的距离由margin决定。属于同一个BFC的两个BOX的margin会发生重叠。\n- BFC的区域不会与float BOX 重叠。\n- BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也是如此。\n- 计算BFC的高度时，float元素也会参与计算。\n\n### 如何触发BFC？\n- float 的值部位none。\n- position 的值不为static 或者是relative。\n- display 的值为table-cell,table-caption,inline-block,flex,或者inline-flex中的一个。\n- overflow的值不为visible。\n\n","slug":"css-小技巧","published":1,"date":"2018-03-12T15:29:22.788Z","updated":"2018-03-13T06:13:03.235Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjna000k8gv6a7ikzdio","content":"<p>css 在开发中的填坑总结</p>\n<a id=\"more\"></a>\n<h2 id=\"一、利用-css-的-content-属性-attr-抓取资料\"><a href=\"#一、利用-css-的-content-属性-attr-抓取资料\" class=\"headerlink\" title=\"一、利用 css 的 content 属性 attr 抓取资料\"></a>一、利用 css 的 content 属性 attr 抓取资料</h2><p>想要获取伪元素，可以用以下写法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-msg</span>=<span class=\"string\">\"open\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">div:hover:after&#123;</span><br><span class=\"line\">    content:attr(data-mag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、利用：valid-和：invalid-来做表单即使校验\"><a href=\"#二、利用：valid-和：invalid-来做表单即使校验\" class=\"headerlink\" title=\"二、利用：valid 和：invalid 来做表单即使校验\"></a>二、利用：valid 和：invalid 来做表单即使校验</h2><ul>\n<li>:required 伪类指定具有 required 属性的表单元素</li>\n<li>:valid 伪类指定一个通过匹配正确的所要求的表单元素</li>\n<li>:invalid 伪类指定一个不匹配指定要求的表单元素</li>\n</ul>\n<h2 id=\"三、writing-mode\"><a href=\"#三、writing-mode\" class=\"headerlink\" title=\"三、writing-mode\"></a>三、writing-mode</h2><p>使用 writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;</p>\n<h2 id=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"><a href=\"#四、实现鼠标悬浮内容自动撑开的过渡动画\" class=\"headerlink\" title=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"></a>四、实现鼠标悬浮内容自动撑开的过渡动画</h2><p>需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">.bd &#123;</span><br><span class=\"line\">  max-height:0;</span><br><span class=\"line\">  overflow:hidden;</span><br><span class=\"line\">  transition: all 1s ease-out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">li:hover .bd &#123;</span><br><span class=\"line\">  max-height: 600px;</span><br><span class=\"line\">  transition-timing-function: ease-in;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、移动端-web-页面支持弹性滚动\"><a href=\"#五、移动端-web-页面支持弹性滚动\" class=\"headerlink\" title=\"五、移动端 web 页面支持弹性滚动\"></a>五、移动端 web 页面支持弹性滚动</h2><p>-webkit-overflow-scrolling: touch;</p>\n<h2 id=\"六、美化浏览器自带的-radio-，checkbox-属性\"><a href=\"#六、美化浏览器自带的-radio-，checkbox-属性\" class=\"headerlink\" title=\"六、美化浏览器自带的 radio ，checkbox 属性\"></a>六、美化浏览器自带的 radio ，checkbox 属性</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty-container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>前端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>后端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>全栈工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.radio-beauty-container &#123;</span><br><span class=\"line\">    font-size: 0;</span><br><span class=\"line\">    $bgc: green;</span><br><span class=\"line\">    %common &#123;</span><br><span class=\"line\">        padding: 2px;</span><br><span class=\"line\">        background-color: $bgc;</span><br><span class=\"line\">        background-clip: content-box;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-name &#123;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        font-size: 16px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-beauty &#123;</span><br><span class=\"line\">        width: 18px;</span><br><span class=\"line\">        height: 18px;</span><br><span class=\"line\">        box-sizing: border-box;</span><br><span class=\"line\">        display: inline-block;</span><br><span class=\"line\">        border: 1px solid $bgc;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        margin: 0 15px 0 3px;</span><br><span class=\"line\">        border-radius: 50%;</span><br><span class=\"line\">        &amp;:hover &#123;</span><br><span class=\"line\">            box-shadow: 0 0 7px $bgc;</span><br><span class=\"line\">            @extend %common;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    input[type=\"radio\"]:checked+.radio-beauty &#123;</span><br><span class=\"line\">        @extend %common;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"七、改变-input-焦点光标的颜色\"><a href=\"#七、改变-input-焦点光标的颜色\" class=\"headerlink\" title=\"七、改变 input 焦点光标的颜色\"></a>七、改变 input 焦点光标的颜色</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"This field uses a default caret.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"custom\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"I have a custom caret color!\"</span> /&gt;</span></span><br><span class=\"line\">input &#123;</span><br><span class=\"line\">  caret-color: auto;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  margin-bottom: .5em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">input.custom &#123;</span><br><span class=\"line\">  caret-color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"八、rem-布局不再使用-JavaScript-设置\"><a href=\"#八、rem-布局不再使用-JavaScript-设置\" class=\"headerlink\" title=\"八、rem 布局不再使用 JavaScript 设置\"></a>八、rem 布局不再使用 JavaScript 设置</h2><p>现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html&#123;</span><br><span class=\"line\">font-size: 100vw / 750</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"切角效果实现\"><a href=\"#切角效果实现\" class=\"headerlink\" title=\"切角效果实现\"></a>切角效果实现</h2><p>切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成 45° 的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。</p>\n<p><img src=\"https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67\" alt=\"\"></p>\n<h2 id=\"BFC（快格式化上下文）\"><a href=\"#BFC（快格式化上下文）\" class=\"headerlink\" title=\"BFC（快格式化上下文）\"></a>BFC（快格式化上下文）</h2><p>它决定了元素如何对其内容进行定位，以及与其他元素的关系的相互作用。当涉及到可视化布局时，BFC提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境元素不会影响到其他环境中的布局。</p>\n<h3 id=\"BFC-的作用：\"><a href=\"#BFC-的作用：\" class=\"headerlink\" title=\"BFC 的作用：\"></a>BFC 的作用：</h3><ul>\n<li>可以包含浮动元素</li>\n<li>不被浮动元素覆盖</li>\n<li>阻止父子元素的margin折叠</li>\n</ul>\n<h3 id=\"BFC的特征：\"><a href=\"#BFC的特征：\" class=\"headerlink\" title=\"BFC的特征：\"></a>BFC的特征：</h3><ul>\n<li>内部的BOX会在垂直方向，一个接一个地放置。</li>\n<li>BOX垂直方向的距离由margin决定。属于同一个BFC的两个BOX的margin会发生重叠。</li>\n<li>BFC的区域不会与float BOX 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也是如此。</li>\n<li>计算BFC的高度时，float元素也会参与计算。</li>\n</ul>\n<h3 id=\"如何触发BFC？\"><a href=\"#如何触发BFC？\" class=\"headerlink\" title=\"如何触发BFC？\"></a>如何触发BFC？</h3><ul>\n<li>float 的值部位none。</li>\n<li>position 的值不为static 或者是relative。</li>\n<li>display 的值为table-cell,table-caption,inline-block,flex,或者inline-flex中的一个。</li>\n<li>overflow的值不为visible。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>css 在开发中的填坑总结</p>","more":"<h2 id=\"一、利用-css-的-content-属性-attr-抓取资料\"><a href=\"#一、利用-css-的-content-属性-attr-抓取资料\" class=\"headerlink\" title=\"一、利用 css 的 content 属性 attr 抓取资料\"></a>一、利用 css 的 content 属性 attr 抓取资料</h2><p>想要获取伪元素，可以用以下写法：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">data-msg</span>=<span class=\"string\">\"open\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">div:hover:after&#123;</span><br><span class=\"line\">    content:attr(data-mag);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、利用：valid-和：invalid-来做表单即使校验\"><a href=\"#二、利用：valid-和：invalid-来做表单即使校验\" class=\"headerlink\" title=\"二、利用：valid 和：invalid 来做表单即使校验\"></a>二、利用：valid 和：invalid 来做表单即使校验</h2><ul>\n<li>:required 伪类指定具有 required 属性的表单元素</li>\n<li>:valid 伪类指定一个通过匹配正确的所要求的表单元素</li>\n<li>:invalid 伪类指定一个不匹配指定要求的表单元素</li>\n</ul>\n<h2 id=\"三、writing-mode\"><a href=\"#三、writing-mode\" class=\"headerlink\" title=\"三、writing-mode\"></a>三、writing-mode</h2><p>使用 writing-mode 这个 CSS 属性实现容器的文字从上往下排列。 writing-mode: vertical-rl;</p>\n<h2 id=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"><a href=\"#四、实现鼠标悬浮内容自动撑开的过渡动画\" class=\"headerlink\" title=\"四、实现鼠标悬浮内容自动撑开的过渡动画\"></a>四、实现鼠标悬浮内容自动撑开的过渡动画</h2><p>需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 auto，悬浮时候撑开内容有个过渡动画。而用 CSS3 实现的话，由于高度的不确定，而 transtion 是需要具体的数值，所以设置 height:auto 是无法实现效果的，可以通过 max-height 这个属性间接的实现这么个效果，css 样式是这样的：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"hd\"</span>&gt;</span> 列表1 <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"bd\"</span>&gt;</span>列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容列表内容<span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span>内容<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">li</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">ul</span>&gt;</span></span><br><span class=\"line\">.bd &#123;</span><br><span class=\"line\">  max-height:0;</span><br><span class=\"line\">  overflow:hidden;</span><br><span class=\"line\">  transition: all 1s ease-out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">li:hover .bd &#123;</span><br><span class=\"line\">  max-height: 600px;</span><br><span class=\"line\">  transition-timing-function: ease-in;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"五、移动端-web-页面支持弹性滚动\"><a href=\"#五、移动端-web-页面支持弹性滚动\" class=\"headerlink\" title=\"五、移动端 web 页面支持弹性滚动\"></a>五、移动端 web 页面支持弹性滚动</h2><p>-webkit-overflow-scrolling: touch;</p>\n<h2 id=\"六、美化浏览器自带的-radio-，checkbox-属性\"><a href=\"#六、美化浏览器自带的-radio-，checkbox-属性\" class=\"headerlink\" title=\"六、美化浏览器自带的 radio ，checkbox 属性\"></a>六、美化浏览器自带的 radio ，checkbox 属性</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty-container\"</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>前端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName1\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>后端工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName2\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">span</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-name\"</span>&gt;</span>全栈工程师<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">\"radio\"</span> <span class=\"attr\">name</span>=<span class=\"string\">\"radioName\"</span> <span class=\"attr\">id</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">hidden</span>/&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"radioName3\"</span> <span class=\"attr\">class</span>=<span class=\"string\">\"radio-beauty\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">.radio-beauty-container &#123;</span><br><span class=\"line\">    font-size: 0;</span><br><span class=\"line\">    $bgc: green;</span><br><span class=\"line\">    %common &#123;</span><br><span class=\"line\">        padding: 2px;</span><br><span class=\"line\">        background-color: $bgc;</span><br><span class=\"line\">        background-clip: content-box;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-name &#123;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        font-size: 16px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .radio-beauty &#123;</span><br><span class=\"line\">        width: 18px;</span><br><span class=\"line\">        height: 18px;</span><br><span class=\"line\">        box-sizing: border-box;</span><br><span class=\"line\">        display: inline-block;</span><br><span class=\"line\">        border: 1px solid $bgc;</span><br><span class=\"line\">        vertical-align: middle;</span><br><span class=\"line\">        margin: 0 15px 0 3px;</span><br><span class=\"line\">        border-radius: 50%;</span><br><span class=\"line\">        &amp;:hover &#123;</span><br><span class=\"line\">            box-shadow: 0 0 7px $bgc;</span><br><span class=\"line\">            @extend %common;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    input[type=\"radio\"]:checked+.radio-beauty &#123;</span><br><span class=\"line\">        @extend %common;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"七、改变-input-焦点光标的颜色\"><a href=\"#七、改变-input-焦点光标的颜色\" class=\"headerlink\" title=\"七、改变 input 焦点光标的颜色\"></a>七、改变 input 焦点光标的颜色</h2><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">value</span>=<span class=\"string\">\"This field uses a default caret.\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">class</span>=<span class=\"string\">\"custom\"</span> <span class=\"attr\">value</span>=<span class=\"string\">\"I have a custom caret color!\"</span> /&gt;</span></span><br><span class=\"line\">input &#123;</span><br><span class=\"line\">  caret-color: auto;</span><br><span class=\"line\">  display: block;</span><br><span class=\"line\">  margin-bottom: .5em;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">input.custom &#123;</span><br><span class=\"line\">  caret-color: red;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"八、rem-布局不再使用-JavaScript-设置\"><a href=\"#八、rem-布局不再使用-JavaScript-设置\" class=\"headerlink\" title=\"八、rem 布局不再使用 JavaScript 设置\"></a>八、rem 布局不再使用 JavaScript 设置</h2><p>现在移动端 css3 单位 vw ,wh 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">html&#123;</span><br><span class=\"line\">font-size: 100vw / 750</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"切角效果实现\"><a href=\"#切角效果实现\" class=\"headerlink\" title=\"切角效果实现\"></a>切角效果实现</h2><p>切角效果是时下非常流行的一种设计风格，并广泛运用于平面设计中，它最常见的形态就是把元素的一个或多个切成 45° 的切口，尤其是在最近几年，扁平化设计盖过拟物化设计后，这种切脚设计更为流行，例如下图就是通过切角实现的一个导航栏，在后面将详细论述起实现。</p>\n<p><img src=\"https://camo.githubusercontent.com/b07ae76cf4ce21d62ef2a4ce97932d831e723c50/687474703a2f2f636f6e74656e742d6d616e6167656d656e742e62302e7570616979756e2e636f6d2f313437323739393439333539332e706e67\" alt=\"\"></p>\n<h2 id=\"BFC（快格式化上下文）\"><a href=\"#BFC（快格式化上下文）\" class=\"headerlink\" title=\"BFC（快格式化上下文）\"></a>BFC（快格式化上下文）</h2><p>它决定了元素如何对其内容进行定位，以及与其他元素的关系的相互作用。当涉及到可视化布局时，BFC提供了一个环境，HTML元素在这个环境中按照一定规则进行布局。一个环境元素不会影响到其他环境中的布局。</p>\n<h3 id=\"BFC-的作用：\"><a href=\"#BFC-的作用：\" class=\"headerlink\" title=\"BFC 的作用：\"></a>BFC 的作用：</h3><ul>\n<li>可以包含浮动元素</li>\n<li>不被浮动元素覆盖</li>\n<li>阻止父子元素的margin折叠</li>\n</ul>\n<h3 id=\"BFC的特征：\"><a href=\"#BFC的特征：\" class=\"headerlink\" title=\"BFC的特征：\"></a>BFC的特征：</h3><ul>\n<li>内部的BOX会在垂直方向，一个接一个地放置。</li>\n<li>BOX垂直方向的距离由margin决定。属于同一个BFC的两个BOX的margin会发生重叠。</li>\n<li>BFC的区域不会与float BOX 重叠。</li>\n<li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也是如此。</li>\n<li>计算BFC的高度时，float元素也会参与计算。</li>\n</ul>\n<h3 id=\"如何触发BFC？\"><a href=\"#如何触发BFC？\" class=\"headerlink\" title=\"如何触发BFC？\"></a>如何触发BFC？</h3><ul>\n<li>float 的值部位none。</li>\n<li>position 的值不为static 或者是relative。</li>\n<li>display 的值为table-cell,table-caption,inline-block,flex,或者inline-flex中的一个。</li>\n<li>overflow的值不为visible。</li>\n</ul>"},{"title":"localstorage","_content":"\nHTML5 中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。**Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费**。\n\nweb storage 提供了两个存储对象：localStorage 和 sessionStorage。\n\n<!--more-->\n\n## localStorage 和 sessionStorage\n\nsessionStorage 存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于 sessionStorage 存储的数据。也是由这些特性导致 sessionStorage 的使用场景较少。\n\nlocalStorage 可以永久存储，而且同源下数据多窗口可以共享。\n\n## localStorage 的基本使用\n\n有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：\n\n```javascript\ntry {\n  localStorage.setItem(key, value);\n} catch(e) {\n  if (isQuotaExceeded(e)) {\n    // Storage full, maybe notify user or do some clean-up\n  }\n}\n\nfunction isQuotaExceeded(e) {\n  var quotaExceeded = false;\n  if (e) {\n    if (e.code) {\n      switch (e.code) {\n        case 22:\n          quotaExceeded = true;\n          break;\n        case 1014:\n          // Firefox\n          if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n            quotaExceeded = true;\n          }\n          break;\n      }\n    } else if (e.number === -2147024882) {\n      // Internet Explorer 8\n      quotaExceeded = true;\n    }\n  }\n  return quotaExceeded;\n```\n\n另外在存储容量快满时，会造成 getItem 性能急剧下降\n\n### sessionStorage,localStorage,cookie 区别\n\n* 都会在浏览器端保存，有大小限制，同源限制\n* cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器\n  cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie\n* 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除\n* 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享\n* localStorage 的修改会促发其他文档窗口的 update 事件\n* cookie 有 secure 属性要求 HTTPS 传输\n* 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M\n\n\ncookie 和 session 都是用来跟踪浏览器用户身份的会话方式。\n\n### cookie 机制\n\n如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。\n\ncookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。\n\n### session 机制\n\n当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。\n\n### 存储内容\n\ncookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。\n\n### 存储的大小\n\n* cookie:单个 cookie 保存的数据不能超过 4kb;\n* session:大小没有限制。\n\n### sessionStorage\n\n是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。\n\n在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage\n\n非常适合 SPA，可以方便再各业务模块进行传值\n\n### localSotrage\n\nlocalStorage 存储的数据是永久性的。","source":"_posts/localstorage.md","raw":"---\ntitle: localstorage\ncategories: webAPI\n---\n\nHTML5 中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。**Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费**。\n\nweb storage 提供了两个存储对象：localStorage 和 sessionStorage。\n\n<!--more-->\n\n## localStorage 和 sessionStorage\n\nsessionStorage 存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于 sessionStorage 存储的数据。也是由这些特性导致 sessionStorage 的使用场景较少。\n\nlocalStorage 可以永久存储，而且同源下数据多窗口可以共享。\n\n## localStorage 的基本使用\n\n有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：\n\n```javascript\ntry {\n  localStorage.setItem(key, value);\n} catch(e) {\n  if (isQuotaExceeded(e)) {\n    // Storage full, maybe notify user or do some clean-up\n  }\n}\n\nfunction isQuotaExceeded(e) {\n  var quotaExceeded = false;\n  if (e) {\n    if (e.code) {\n      switch (e.code) {\n        case 22:\n          quotaExceeded = true;\n          break;\n        case 1014:\n          // Firefox\n          if (e.name === 'NS_ERROR_DOM_QUOTA_REACHED') {\n            quotaExceeded = true;\n          }\n          break;\n      }\n    } else if (e.number === -2147024882) {\n      // Internet Explorer 8\n      quotaExceeded = true;\n    }\n  }\n  return quotaExceeded;\n```\n\n另外在存储容量快满时，会造成 getItem 性能急剧下降\n\n### sessionStorage,localStorage,cookie 区别\n\n* 都会在浏览器端保存，有大小限制，同源限制\n* cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器\n  cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie\n* 有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除\n* 共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享\n* localStorage 的修改会促发其他文档窗口的 update 事件\n* cookie 有 secure 属性要求 HTTPS 传输\n* 浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M\n\n\ncookie 和 session 都是用来跟踪浏览器用户身份的会话方式。\n\n### cookie 机制\n\n如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。\n\ncookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。\n\n### session 机制\n\n当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。\n\n### 存储内容\n\ncookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。\n\n### 存储的大小\n\n* cookie:单个 cookie 保存的数据不能超过 4kb;\n* session:大小没有限制。\n\n### sessionStorage\n\n是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。\n\n在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage\n\n非常适合 SPA，可以方便再各业务模块进行传值\n\n### localSotrage\n\nlocalStorage 存储的数据是永久性的。","slug":"localstorage","published":1,"date":"2018-03-12T15:29:22.788Z","updated":"2018-03-12T15:29:22.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjne000n8gv6b0czoa88","content":"<p>HTML5 中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。<strong>Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费</strong>。</p>\n<p>web storage 提供了两个存储对象：localStorage 和 sessionStorage。</p>\n<a id=\"more\"></a>\n<h2 id=\"localStorage-和-sessionStorage\"><a href=\"#localStorage-和-sessionStorage\" class=\"headerlink\" title=\"localStorage 和 sessionStorage\"></a>localStorage 和 sessionStorage</h2><p>sessionStorage 存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于 sessionStorage 存储的数据。也是由这些特性导致 sessionStorage 的使用场景较少。</p>\n<p>localStorage 可以永久存储，而且同源下数据多窗口可以共享。</p>\n<h2 id=\"localStorage-的基本使用\"><a href=\"#localStorage-的基本使用\" class=\"headerlink\" title=\"localStorage 的基本使用\"></a>localStorage 的基本使用</h2><p>有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  localStorage.setItem(key, value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isQuotaExceeded(e)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Storage full, maybe notify user or do some clean-up</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isQuotaExceeded</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> quotaExceeded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.code) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (e.code) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">22</span>:</span><br><span class=\"line\">          quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1014</span>:</span><br><span class=\"line\">          <span class=\"comment\">// Firefox</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.name === <span class=\"string\">'NS_ERROR_DOM_QUOTA_REACHED'</span>) &#123;</span><br><span class=\"line\">            quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e.number === <span class=\"number\">-2147024882</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Internet Explorer 8</span></span><br><span class=\"line\">      quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quotaExceeded;</span><br></pre></td></tr></table></figure>\n<p>另外在存储容量快满时，会造成 getItem 性能急剧下降</p>\n<h3 id=\"sessionStorage-localStorage-cookie-区别\"><a href=\"#sessionStorage-localStorage-cookie-区别\" class=\"headerlink\" title=\"sessionStorage,localStorage,cookie 区别\"></a>sessionStorage,localStorage,cookie 区别</h3><ul>\n<li>都会在浏览器端保存，有大小限制，同源限制</li>\n<li>cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器<br>cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie</li>\n<li>有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除</li>\n<li>共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享</li>\n<li>localStorage 的修改会促发其他文档窗口的 update 事件</li>\n<li>cookie 有 secure 属性要求 HTTPS 传输</li>\n<li>浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M</li>\n</ul>\n<p>cookie 和 session 都是用来跟踪浏览器用户身份的会话方式。</p>\n<h3 id=\"cookie-机制\"><a href=\"#cookie-机制\" class=\"headerlink\" title=\"cookie 机制\"></a>cookie 机制</h3><p>如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。</p>\n<p>cookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。</p>\n<h3 id=\"session-机制\"><a href=\"#session-机制\" class=\"headerlink\" title=\"session 机制\"></a>session 机制</h3><p>当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。</p>\n<h3 id=\"存储内容\"><a href=\"#存储内容\" class=\"headerlink\" title=\"存储内容\"></a>存储内容</h3><p>cookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。</p>\n<h3 id=\"存储的大小\"><a href=\"#存储的大小\" class=\"headerlink\" title=\"存储的大小\"></a>存储的大小</h3><ul>\n<li>cookie:单个 cookie 保存的数据不能超过 4kb;</li>\n<li>session:大小没有限制。</li>\n</ul>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。</p>\n<p>在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage</p>\n<p>非常适合 SPA，可以方便再各业务模块进行传值</p>\n<h3 id=\"localSotrage\"><a href=\"#localSotrage\" class=\"headerlink\" title=\"localSotrage\"></a>localSotrage</h3><p>localStorage 存储的数据是永久性的。</p>\n","site":{"data":{}},"excerpt":"<p>HTML5 中 Web Storage 的出现，主要是为了弥补使用 Cookie 作为本地存储的不足。<strong>Cookie 存储的数据量非常小，而且数据会自动携带到请求头里，但服务器端可能并不关心这些数据，所以会造成带宽的浪费</strong>。</p>\n<p>web storage 提供了两个存储对象：localStorage 和 sessionStorage。</p>","more":"<h2 id=\"localStorage-和-sessionStorage\"><a href=\"#localStorage-和-sessionStorage\" class=\"headerlink\" title=\"localStorage 和 sessionStorage\"></a>localStorage 和 sessionStorage</h2><p>sessionStorage 存储的数据仅在本次会话有用，会话结束之后会自动失效，而且数据仅在当前窗口有效，同一源下新窗口也访问不到其他窗口基于 sessionStorage 存储的数据。也是由这些特性导致 sessionStorage 的使用场景较少。</p>\n<p>localStorage 可以永久存储，而且同源下数据多窗口可以共享。</p>\n<h2 id=\"localStorage-的基本使用\"><a href=\"#localStorage-的基本使用\" class=\"headerlink\" title=\"localStorage 的基本使用\"></a>localStorage 的基本使用</h2><p>有两点需要注意一下。在 setItem 时，可能会达到大小限制，最好加上错误捕捉 ：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  localStorage.setItem(key, value);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (isQuotaExceeded(e)) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Storage full, maybe notify user or do some clean-up</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isQuotaExceeded</span>(<span class=\"params\">e</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> quotaExceeded = <span class=\"literal\">false</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.code) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">switch</span> (e.code) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">22</span>:</span><br><span class=\"line\">          quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> <span class=\"number\">1014</span>:</span><br><span class=\"line\">          <span class=\"comment\">// Firefox</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (e.name === <span class=\"string\">'NS_ERROR_DOM_QUOTA_REACHED'</span>) &#123;</span><br><span class=\"line\">            quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e.number === <span class=\"number\">-2147024882</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// Internet Explorer 8</span></span><br><span class=\"line\">      quotaExceeded = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quotaExceeded;</span><br></pre></td></tr></table></figure>\n<p>另外在存储容量快满时，会造成 getItem 性能急剧下降</p>\n<h3 id=\"sessionStorage-localStorage-cookie-区别\"><a href=\"#sessionStorage-localStorage-cookie-区别\" class=\"headerlink\" title=\"sessionStorage,localStorage,cookie 区别\"></a>sessionStorage,localStorage,cookie 区别</h3><ul>\n<li>都会在浏览器端保存，有大小限制，同源限制</li>\n<li>cookie 会在请求时发送到服务器，作为会话标识，服务器可修改 cookie；web storage 不会发送到服务器<br>cookie 有 path 概念，子路径可以访问父路径 cookie，父路径不能访问子路径 cookie</li>\n<li>有效期：cookie 在设置的有效期内有效，默认为浏览器关闭；sessionStorage 在窗口关闭前有效，localStorage 长期有效，直到用户删除</li>\n<li>共享：sessionStorage 不能共享，localStorage 在同源文档之间共享，cookie 在同源且符合 path 规则的文档之间共享</li>\n<li>localStorage 的修改会促发其他文档窗口的 update 事件</li>\n<li>cookie 有 secure 属性要求 HTTPS 传输</li>\n<li>浏览器不能保存超过 300 个 cookie，单个服务器不能超过 20 个，每个 cookie 不能超过 4k。web storage 大小支持能达到 5M</li>\n</ul>\n<p>cookie 和 session 都是用来跟踪浏览器用户身份的会话方式。</p>\n<h3 id=\"cookie-机制\"><a href=\"#cookie-机制\" class=\"headerlink\" title=\"cookie 机制\"></a>cookie 机制</h3><p>如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。</p>\n<p>cookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。</p>\n<h3 id=\"session-机制\"><a href=\"#session-机制\" class=\"headerlink\" title=\"session 机制\"></a>session 机制</h3><p>当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。</p>\n<h3 id=\"存储内容\"><a href=\"#存储内容\" class=\"headerlink\" title=\"存储内容\"></a>存储内容</h3><p>cookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。</p>\n<h3 id=\"存储的大小\"><a href=\"#存储的大小\" class=\"headerlink\" title=\"存储的大小\"></a>存储的大小</h3><ul>\n<li>cookie:单个 cookie 保存的数据不能超过 4kb;</li>\n<li>session:大小没有限制。</li>\n</ul>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。</p>\n<p>在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage</p>\n<p>非常适合 SPA，可以方便再各业务模块进行传值</p>\n<h3 id=\"localSotrage\"><a href=\"#localSotrage\" class=\"headerlink\" title=\"localSotrage\"></a>localSotrage</h3><p>localStorage 存储的数据是永久性的。</p>"},{"title":"this指向","date":"2018-01-23T03:39:32.000Z","_content":"\n[链接](http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w)\n\n1. js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。this 永远指向最后调用它的那个对象。\n2. 普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过 call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。\n3. this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。\n\n<!--more-->\n\n## 默认绑定\n\n在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就会应用默认绑定规则，默认绑定的指向的是全局作用域。\n\n```javascript\n<script type=\"text/javascript\" charset=\"utf-8\">\n  var name = \"g\";\n  function a() {\n      console.log(this.name);        //g\n      a.name = 'inside';\n      function b() {\n          console.log(this.name);  //g\n\n\n      }\n      b();\n  }\n  a();\n</script>\n```\n\n`a()` 函数在全局作用域中被调用，因此第 1 句中的 `this` 就绑定在了全局对象上。`b()` 函数在 `a()` 函数里面调用，即使这样第二句中的 `this` 指代的仍然是全局对象，即使 `a()` 函数设置了 `name` 属性。这就是默认绑定规则，它是 `js` 中最常见的一种函数调用模式，`this` 的绑定规则也是最简单的一种，就是绑定在全局作用域上\n\n** 但是如果使用了严格模式，则 `this` 不能绑定到全局对象，在严格模式下，把 `this` 绑定到全局对象上时，实际上绑定的是 `underfined`，因此上面的代码会报错 **\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var c = this\n  c.name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。\n\n---\n\n## 隐式绑定\n\n当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar obj1 = {\n  name: 'zxt',\n  say: say\n}\nvar obj2 = {\n  name: 'zxt1',\n  say: say\n}\nobj1.say() // zxt\nobj2.say() // zxt1\n```\n\nobj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自然指向了这个上下文对象。这是很常见的函数调用模式\n\n** 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 **\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nvar obj2 = {\n  a: 42,\n  foo: foo\n}\nvar obj1 = {\n  a: 2,\n  obj2: obj2\n}\nobj1.obj2.foo()\n```\n\n### 隐式绑定上下文的时丢失上下文\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj = {\n  name: 'inside',\n  say: say\n}\nvar alias = obj.say // 设置一个简写   (1)\nalias() // 函数调用 输出\"global\"  (2)\n```\n\n由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias = say，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下文 ”。最终执行 alias 函数只不过简单的执行了 say 函数\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nfunction doFoo(fn) {\n  // fn其实引用的是foo\n  fn() // <-- 调用位置！\n}\nvar obj = {\n  a: 2,\n  foo: foo\n}\nvar a = 'oops, global' // a是全局对象的属性\ndoFoo(obj.foo)\n```\n\n参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置\n\n---\n\n## 显示绑定\n\n显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本相似，他们之间的区别是：\n\n* apply(obj,[arg1.arg2,...]); 被调用函数的参数以数组的形式给出\n\n* call(obj,arg1,arg2,arg3,...); 被调用函数的参数依次给出\n\n* bind 函数执行后，返回的是一个新函数。\n\n** 硬性绑定的应用场景：**\n\n```javascript\nfunction foo(something) {\nconsole.log( this.a, something );\nreturn this.a + something;\n} v\nar obj = {\na:2\n};\nvar bar = function() {\nreturn foo.apply( obj, arguments );\n};\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n另一种使用方法是创建一个\n\n```javascript\nfunction speak() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj1 = {\n  name: 'obj1'\n}\nvar obj2 = {\n  name: 'obj2'\n}\nspeak() // global 等价于speak.call(window)\nspeak.call(window)\nspeak.call(obj1) // obj1\nspeak.call(obj2) // obj2\n```\n\n带参数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar obj2 = {\n  a: 3\n}\ncount.call(obj1, 1, 2) // 4\ncount.apply(obj1, [1, 2]) // 4\ncount.call(obj2, 1, 2) // 5\ncount.apply(obj2, [1, 2]) // 5\n```\n\n因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了 call 或者 apply 所调用的对象上。而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar bound1 = count.bind(obj1) // 未指定参数\nbound1(1, 2) // 4\nvar bound2 = count.bind(obj1, 1) // 指定了一个参数\nbound2(2) // 4\nvar bound3 = count.bind(obj1, 1, 2) // 指定了两个参数\nbound3() //4\nvar bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略\nbound4() // 4\n```\n\n所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。\n\n---\n\nnew 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  console.log('我也只不过是个普通函数')\n  console.log(this) //window、window、Person\n}\nPerson('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(this.name) // \"zxt\"\nconsole.log(age) // 22\nPerson('yh', 122)\nconsole.log(this.name) //yu\nvar zxt = new Person('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(zxt.name) // \"zxt\"\nconsole.log(zxt.age) // 22\nconsole.log(this.name) //yu\n```\n\n定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。如果通过一个 new 操作符，则构造了一个新的对象。\n\n两种调用方式的不同之处：\n\n* ** 普通函数调用时，应用启用默认绑定规则 **，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。\n* 当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函数，会自动执行下面的操作\n  1. 创建一个全新的对象。\n  2. 这个新对象或被执行原型链连接\n  3. 这个新对象会绑定到函数调用的 this\n  4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象\n\n---\n\n## 四种绑定的优先级\n\n这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。** 默认优先级最低 < 隐式绑定第二 < 显示绑定第三 < new 绑定最高 **\n\n---\n\n## 箭头函数中的 this\n\n箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。\n\n```javascript\nvar a = 1\nvar foo = () => {\n  console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域\n}\nvar obj = {\n  a: 2\n}\nfoo() // 1 ,在全局对象中调用\nfoo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果\n```\n\n箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  this.speak = function() {\n    console.log(this.name)\n    // 普通函数（非箭头函数),this绑定在调用时的作用域\n  }\n  this.bornYear = () => {\n    // 本文写于2016年，因此new Date().getFullYear()得到的是2016\n    // 箭头函数，this绑定在实例内部\n    console.log(new Date().getFullYear() - this.age)\n  }\n}\nvar zxt = new Person('zxt', 22)\nzxt.speak() // \"zxt\"\nzxt.bornYear() // 1994\n// 到这里应该大家应该都没什么问题\nvar xiaoMing = {\n  name: 'xiaoming',\n  age: 18 // 小明永远18岁\n}\nzxt.speak.call(xiaoMing)\n// \"xiaoming\" this绑定的是xiaoMing这个对象\nzxt.bornYear.call(xiaoMing)\n```\n\n以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。\n\n---\n\n```javascript\nvar obj = {\n  id: 'awesome',\n  cool: function coolFn() {\n    var _this = this\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nobj.cool() // 酷,object\nsetTimeout(obj.cool, 100) //window\n```\n\ncool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。\n\n```javascript\nfunction Obj(name) {\n  var _this = this //_this = object{}\n  _this.id = name\n  _this.cool = function() {\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nvar test = new Obj('yaya') //yaya\ntest.cool() //yaya\nvar xiaohong = {\n  id: xiaohong,\n  age: 18\n}\ntest.cool.call(xiaohong) //根本不执行\n```\n\n---\n\n```javascript\nfunction identify() {\n  return this.name.toUpperCase()\n}\nfunction speak() {\n  var greeting = \"Hello, I'm \" + identify.call(this)\n  console.log(greeting)\n}\nvar me = {\n  name: 'Kyle'\n}\nvar you = {\n  name: 'Reader'\n}\nidentify.call(me) // KYLE\nidentify.call(you) // READER\nspeak.call(me) // Hello, 我是KYLE\nspeak.call(you) // Hello, 我是READER\n```\n\n---\n\n```javascript\nfunction foo(num) {\n  console.log('foo: ' + num)\n  // 记录foo被调用的次数\n\n  this.count++\n}\nfoo.count = 0\nvar i\nfor (i = 0; i < 10; i++) {\n  if (i > 5) {\n    foo(i)\n  }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo被调用了多少次？\nconsole.log(foo.count) // 0 -- WTF?\n```\n\n执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。\n\n** 匿名函数无法指向自身 **，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用匿名函数，至少在需要自引用时使用时使用具名函数\n\n**this 在任何情况下都不指向函数的词法作用域 **，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 \\*\\*\n\n```javascript\nfunction foo() {\n  var a = 2\n  this.bar()\n}\nfunction bar() {\n  console.log(this.a)\n}\nfoo()\n```\n\n试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，** 不能使用 this 来引用一个词法作用域内部的东西 **，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的\n\n---\n\n## 综合题\n\n### 1\n\n```javascript\nvar names = '宋伟老师'\nvar obj = {\n  names: '张健老师',\n  showName: function() {\n    console.log(this.name)\n  },\n  returnName: function() {\n    return this.name\n  },\n  returnFunctionName: function() {\n    return function() {\n      console.log(this.name)\n    }\n  }\n}\nobj.showName() //输出什么？   \"张健老师\"\nobj.returnName() //输出什么？   \"张健老师\"\nobj.returnFunctionName()() //输出什么？   \"宋伟老师\"\nobj.showName.call(names) //输出什么？   undefined\nobj.returnName.call(names) //输出什么？   undefined\nobj.returnFunctionName().call(names) //输出什么？   undefined\nvar newObj = obj.returnFunctionName().bind(window)\nnewObj.call(obj) //输出什么？   \"宋伟老师\"\n//为什么最后一个输出\"宋伟老师\"？因为bind指向this对象后  再一次调用的话  this指向不会被改变\n```\n\n### 2\n\n```javascript\nvar big = '万达老师'\n\nvar obj = {\n  big: '宋伟老师',\n  showBig: function() {\n    return this.big\n  }\n}\nobj.showBig.call(big) //ƒ big() { [native code] }  //精通String的操作方法的同学就把为什么回复出来吧\n```\n\n### 3\n\n```javascript\nfunction a(a,b,c){\n    console.log(this.length);                 //4\n    console.log(this.callee.length);          //1\n}\n\nfunction fn(d){\n    arguments[0](10,20,30,40,50);\n}\n\nfn(a,10,20,30);\n\n\n//第一个输出结果:因为this当前指向的是arguments 。 arguments是一个伪数组具备length属性。arguments又是保存函数的实参。\nfn调用的时候传入4个实参。所以arguments长度为4。这个时候arguments[0] 等同于 arguments.a调用这个函数。所以this指向的是arguments这个伪数组也是(对象)(听到这还有疑惑小伙伴留言问我)\n\n//第二个输出结果：callee是arguments的一个属性,主要返回当前arguments直属的函数体。所以this.callees是返回fn 。每一个函数有一个length属性主要用来返回函数的形参的所以就是1。\n```\n","source":"_posts/this指向.md","raw":"---\ntitle: this指向\ndate: 2018-01-23 11:39:32\ntags:\n---\n\n[链接](http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w)\n\n1. js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。this 永远指向最后调用它的那个对象。\n2. 普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过 call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。\n3. this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。\n\n<!--more-->\n\n## 默认绑定\n\n在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就会应用默认绑定规则，默认绑定的指向的是全局作用域。\n\n```javascript\n<script type=\"text/javascript\" charset=\"utf-8\">\n  var name = \"g\";\n  function a() {\n      console.log(this.name);        //g\n      a.name = 'inside';\n      function b() {\n          console.log(this.name);  //g\n\n\n      }\n      b();\n  }\n  a();\n</script>\n```\n\n`a()` 函数在全局作用域中被调用，因此第 1 句中的 `this` 就绑定在了全局对象上。`b()` 函数在 `a()` 函数里面调用，即使这样第二句中的 `this` 指代的仍然是全局对象，即使 `a()` 函数设置了 `name` 属性。这就是默认绑定规则，它是 `js` 中最常见的一种函数调用模式，`this` 的绑定规则也是最简单的一种，就是绑定在全局作用域上\n\n** 但是如果使用了严格模式，则 `this` 不能绑定到全局对象，在严格模式下，把 `this` 绑定到全局对象上时，实际上绑定的是 `underfined`，因此上面的代码会报错 **\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var c = this\n  c.name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  name = 'inside'\n  function b() {\n    console.log(this.name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(this.name) //g\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(name) //inside\n  }\n  b()\n}\na()\n```\n\n---\n\n```javascript\nvar name = 'g'\nfunction a() {\n  console.log(name) //underfined\n  var name = 'inside'\n  function b() {\n    console.log(this.name) //g\n  }\n  b()\n}\na()\n```\n\n所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。\n\n---\n\n## 隐式绑定\n\n当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar obj1 = {\n  name: 'zxt',\n  say: say\n}\nvar obj2 = {\n  name: 'zxt1',\n  say: say\n}\nobj1.say() // zxt\nobj2.say() // zxt1\n```\n\nobj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自然指向了这个上下文对象。这是很常见的函数调用模式\n\n** 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 **\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nvar obj2 = {\n  a: 42,\n  foo: foo\n}\nvar obj1 = {\n  a: 2,\n  obj2: obj2\n}\nobj1.obj2.foo()\n```\n\n### 隐式绑定上下文的时丢失上下文\n\n```javascript\nfunction say() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj = {\n  name: 'inside',\n  say: say\n}\nvar alias = obj.say // 设置一个简写   (1)\nalias() // 函数调用 输出\"global\"  (2)\n```\n\n由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias = say，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下文 ”。最终执行 alias 函数只不过简单的执行了 say 函数\n\n```javascript\nfunction foo() {\n  console.log(this.a)\n}\nfunction doFoo(fn) {\n  // fn其实引用的是foo\n  fn() // <-- 调用位置！\n}\nvar obj = {\n  a: 2,\n  foo: foo\n}\nvar a = 'oops, global' // a是全局对象的属性\ndoFoo(obj.foo)\n```\n\n参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置\n\n---\n\n## 显示绑定\n\n显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本相似，他们之间的区别是：\n\n* apply(obj,[arg1.arg2,...]); 被调用函数的参数以数组的形式给出\n\n* call(obj,arg1,arg2,arg3,...); 被调用函数的参数依次给出\n\n* bind 函数执行后，返回的是一个新函数。\n\n** 硬性绑定的应用场景：**\n\n```javascript\nfunction foo(something) {\nconsole.log( this.a, something );\nreturn this.a + something;\n} v\nar obj = {\na:2\n};\nvar bar = function() {\nreturn foo.apply( obj, arguments );\n};\nvar b = bar( 3 ); // 2 3\nconsole.log( b ); // 5\n```\n\n另一种使用方法是创建一个\n\n```javascript\nfunction speak() {\n  console.log(this.name)\n}\nvar name = 'global'\nvar obj1 = {\n  name: 'obj1'\n}\nvar obj2 = {\n  name: 'obj2'\n}\nspeak() // global 等价于speak.call(window)\nspeak.call(window)\nspeak.call(obj1) // obj1\nspeak.call(obj2) // obj2\n```\n\n带参数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar obj2 = {\n  a: 3\n}\ncount.call(obj1, 1, 2) // 4\ncount.apply(obj1, [1, 2]) // 4\ncount.call(obj2, 1, 2) // 5\ncount.apply(obj2, [1, 2]) // 5\n```\n\n因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了 call 或者 apply 所调用的对象上。而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：\n\n```javascript\n// 带参数\nfunction count(num1, num2) {\n  console.log(this.a * num1 + num2)\n}\nvar obj1 = {\n  a: 2\n}\nvar bound1 = count.bind(obj1) // 未指定参数\nbound1(1, 2) // 4\nvar bound2 = count.bind(obj1, 1) // 指定了一个参数\nbound2(2) // 4\nvar bound3 = count.bind(obj1, 1, 2) // 指定了两个参数\nbound3() //4\nvar bound4 = count.bind(obj1, 1, 2, 3) // 指定了多余的参数,多余的参数会被忽略\nbound4() // 4\n```\n\n所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。\n\n---\n\nnew 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  console.log('我也只不过是个普通函数')\n  console.log(this) //window、window、Person\n}\nPerson('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(this.name) // \"zxt\"\nconsole.log(age) // 22\nPerson('yh', 122)\nconsole.log(this.name) //yu\nvar zxt = new Person('zxt', 22) // \"我也只不过是个普通函数\"\nconsole.log(zxt.name) // \"zxt\"\nconsole.log(zxt.age) // 22\nconsole.log(this.name) //yu\n```\n\n定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。如果通过一个 new 操作符，则构造了一个新的对象。\n\n两种调用方式的不同之处：\n\n* ** 普通函数调用时，应用启用默认绑定规则 **，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。\n* 当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函数，会自动执行下面的操作\n  1. 创建一个全新的对象。\n  2. 这个新对象或被执行原型链连接\n  3. 这个新对象会绑定到函数调用的 this\n  4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象\n\n---\n\n## 四种绑定的优先级\n\n这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。** 默认优先级最低 < 隐式绑定第二 < 显示绑定第三 < new 绑定最高 **\n\n---\n\n## 箭头函数中的 this\n\n箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。\n\n```javascript\nvar a = 1\nvar foo = () => {\n  console.log(this.a) // 定义在全局对象中，因此this绑定在全局作用域\n}\nvar obj = {\n  a: 2\n}\nfoo() // 1 ,在全局对象中调用\nfoo.call(obj) // 1,显示绑定，由obj对象来调用，但根本不影响结果\n```\n\n箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改\n\n```javascript\nfunction Person(name, age) {\n  this.name = name\n  this.age = age\n  this.speak = function() {\n    console.log(this.name)\n    // 普通函数（非箭头函数),this绑定在调用时的作用域\n  }\n  this.bornYear = () => {\n    // 本文写于2016年，因此new Date().getFullYear()得到的是2016\n    // 箭头函数，this绑定在实例内部\n    console.log(new Date().getFullYear() - this.age)\n  }\n}\nvar zxt = new Person('zxt', 22)\nzxt.speak() // \"zxt\"\nzxt.bornYear() // 1994\n// 到这里应该大家应该都没什么问题\nvar xiaoMing = {\n  name: 'xiaoming',\n  age: 18 // 小明永远18岁\n}\nzxt.speak.call(xiaoMing)\n// \"xiaoming\" this绑定的是xiaoMing这个对象\nzxt.bornYear.call(xiaoMing)\n```\n\n以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。\n\n---\n\n```javascript\nvar obj = {\n  id: 'awesome',\n  cool: function coolFn() {\n    var _this = this\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nobj.cool() // 酷,object\nsetTimeout(obj.cool, 100) //window\n```\n\ncool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。\n\n```javascript\nfunction Obj(name) {\n  var _this = this //_this = object{}\n  _this.id = name\n  _this.cool = function() {\n    console.log(_this.id)\n  }\n}\nvar id = 'not awesome'\nvar test = new Obj('yaya') //yaya\ntest.cool() //yaya\nvar xiaohong = {\n  id: xiaohong,\n  age: 18\n}\ntest.cool.call(xiaohong) //根本不执行\n```\n\n---\n\n```javascript\nfunction identify() {\n  return this.name.toUpperCase()\n}\nfunction speak() {\n  var greeting = \"Hello, I'm \" + identify.call(this)\n  console.log(greeting)\n}\nvar me = {\n  name: 'Kyle'\n}\nvar you = {\n  name: 'Reader'\n}\nidentify.call(me) // KYLE\nidentify.call(you) // READER\nspeak.call(me) // Hello, 我是KYLE\nspeak.call(you) // Hello, 我是READER\n```\n\n---\n\n```javascript\nfunction foo(num) {\n  console.log('foo: ' + num)\n  // 记录foo被调用的次数\n\n  this.count++\n}\nfoo.count = 0\nvar i\nfor (i = 0; i < 10; i++) {\n  if (i > 5) {\n    foo(i)\n  }\n}\n// foo: 6\n// foo: 7\n// foo: 8\n// foo: 9\n// foo被调用了多少次？\nconsole.log(foo.count) // 0 -- WTF?\n```\n\n执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。\n\n** 匿名函数无法指向自身 **，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用匿名函数，至少在需要自引用时使用时使用具名函数\n\n**this 在任何情况下都不指向函数的词法作用域 **，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 \\*\\*\n\n```javascript\nfunction foo() {\n  var a = 2\n  this.bar()\n}\nfunction bar() {\n  console.log(this.a)\n}\nfoo()\n```\n\n试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，** 不能使用 this 来引用一个词法作用域内部的东西 **，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的\n\n---\n\n## 综合题\n\n### 1\n\n```javascript\nvar names = '宋伟老师'\nvar obj = {\n  names: '张健老师',\n  showName: function() {\n    console.log(this.name)\n  },\n  returnName: function() {\n    return this.name\n  },\n  returnFunctionName: function() {\n    return function() {\n      console.log(this.name)\n    }\n  }\n}\nobj.showName() //输出什么？   \"张健老师\"\nobj.returnName() //输出什么？   \"张健老师\"\nobj.returnFunctionName()() //输出什么？   \"宋伟老师\"\nobj.showName.call(names) //输出什么？   undefined\nobj.returnName.call(names) //输出什么？   undefined\nobj.returnFunctionName().call(names) //输出什么？   undefined\nvar newObj = obj.returnFunctionName().bind(window)\nnewObj.call(obj) //输出什么？   \"宋伟老师\"\n//为什么最后一个输出\"宋伟老师\"？因为bind指向this对象后  再一次调用的话  this指向不会被改变\n```\n\n### 2\n\n```javascript\nvar big = '万达老师'\n\nvar obj = {\n  big: '宋伟老师',\n  showBig: function() {\n    return this.big\n  }\n}\nobj.showBig.call(big) //ƒ big() { [native code] }  //精通String的操作方法的同学就把为什么回复出来吧\n```\n\n### 3\n\n```javascript\nfunction a(a,b,c){\n    console.log(this.length);                 //4\n    console.log(this.callee.length);          //1\n}\n\nfunction fn(d){\n    arguments[0](10,20,30,40,50);\n}\n\nfn(a,10,20,30);\n\n\n//第一个输出结果:因为this当前指向的是arguments 。 arguments是一个伪数组具备length属性。arguments又是保存函数的实参。\nfn调用的时候传入4个实参。所以arguments长度为4。这个时候arguments[0] 等同于 arguments.a调用这个函数。所以this指向的是arguments这个伪数组也是(对象)(听到这还有疑惑小伙伴留言问我)\n\n//第二个输出结果：callee是arguments的一个属性,主要返回当前arguments直属的函数体。所以this.callees是返回fn 。每一个函数有一个length属性主要用来返回函数的形参的所以就是1。\n```\n","slug":"this指向","published":1,"updated":"2018-03-12T15:29:22.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjnn000o8gv6l0t2q4mf","content":"<p><a href=\"http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<ol>\n<li>js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。this 永远指向最后调用它的那个对象。</li>\n<li>普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过 call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。</li>\n<li>this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就会应用默认绑定规则，默认绑定的指向的是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> charset=<span class=\"string\">\"utf-8\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"g\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);        <span class=\"comment\">//g</span></span><br><span class=\"line\">      a.name = <span class=\"string\">'inside'</span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);  <span class=\"comment\">//g</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      b();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>a()</code> 函数在全局作用域中被调用，因此第 1 句中的 <code>this</code> 就绑定在了全局对象上。<code>b()</code> 函数在 <code>a()</code> 函数里面调用，即使这样第二句中的 <code>this</code> 指代的仍然是全局对象，即使 <code>a()</code> 函数设置了 <code>name</code> 属性。这就是默认绑定规则，它是 <code>js</code> 中最常见的一种函数调用模式，<code>this</code> 的绑定规则也是最简单的一种，就是绑定在全局作用域上</p>\n<p><strong> 但是如果使用了严格模式，则 <code>this</code> 不能绑定到全局对象，在严格模式下，把 <code>this</code> 绑定到全局对象上时，实际上绑定的是 <code>underfined</code>，因此上面的代码会报错 </strong></p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span></span><br><span class=\"line\">  c.name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<p>所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。</p>\n<hr>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt1'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.say() <span class=\"comment\">// zxt</span></span><br><span class=\"line\">obj2.say() <span class=\"comment\">// zxt1</span></span><br></pre></td></tr></table></figure>\n<p>obj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自然指向了这个上下文对象。这是很常见的函数调用模式</p>\n<p><strong> 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 </strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">42</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  obj2: obj2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.obj2.foo()</span><br></pre></td></tr></table></figure>\n<h3 id=\"隐式绑定上下文的时丢失上下文\"><a href=\"#隐式绑定上下文的时丢失上下文\" class=\"headerlink\" title=\"隐式绑定上下文的时丢失上下文\"></a>隐式绑定上下文的时丢失上下文</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'inside'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> alias = obj.say <span class=\"comment\">// 设置一个简写   (1)</span></span><br><span class=\"line\">alias() <span class=\"comment\">// 函数调用 输出\"global\"  (2)</span></span><br></pre></td></tr></table></figure>\n<p>由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias = say，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下文 ”。最终执行 alias 函数只不过简单的执行了 say 函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// fn其实引用的是foo</span></span><br><span class=\"line\">  fn() <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'oops, global'</span> <span class=\"comment\">// a是全局对象的属性</span></span><br><span class=\"line\">doFoo(obj.foo)</span><br></pre></td></tr></table></figure>\n<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置</p>\n<hr>\n<h2 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h2><p>显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本相似，他们之间的区别是：</p>\n<ul>\n<li><p>apply(obj,[arg1.arg2,…]); 被调用函数的参数以数组的形式给出</p>\n</li>\n<li><p>call(obj,arg1,arg2,arg3,…); 被调用函数的参数依次给出</p>\n</li>\n<li><p>bind 函数执行后，返回的是一个新函数。</p>\n</li>\n</ul>\n<p><strong> 硬性绑定的应用场景：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar obj = &#123;</span><br><span class=\"line\">a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>另一种使用方法是创建一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">speak() <span class=\"comment\">// global 等价于speak.call(window)</span></span><br><span class=\"line\">speak.call(<span class=\"built_in\">window</span>)</span><br><span class=\"line\">speak.call(obj1) <span class=\"comment\">// obj1</span></span><br><span class=\"line\">speak.call(obj2) <span class=\"comment\">// obj2</span></span><br></pre></td></tr></table></figure>\n<p>带参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count.call(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.call(obj2, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 5</span></span><br><span class=\"line\">count.apply(obj2, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了 call 或者 apply 所调用的对象上。而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bound1 = count.bind(obj1) <span class=\"comment\">// 未指定参数</span></span><br><span class=\"line\">bound1(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound2 = count.bind(obj1, <span class=\"number\">1</span>) <span class=\"comment\">// 指定了一个参数</span></span><br><span class=\"line\">bound2(<span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound3 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 指定了两个参数</span></span><br><span class=\"line\">bound3() <span class=\"comment\">//4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound4 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 指定了多余的参数,多余的参数会被忽略</span></span><br><span class=\"line\">bound4() <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。</p>\n<hr>\n<p>new 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'我也只不过是个普通函数'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//window、window、Person</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age) <span class=\"comment\">// 22</span></span><br><span class=\"line\">Person(<span class=\"string\">'yh'</span>, <span class=\"number\">122</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.age) <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br></pre></td></tr></table></figure>\n<p>定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。如果通过一个 new 操作符，则构造了一个新的对象。</p>\n<p>两种调用方式的不同之处：</p>\n<ul>\n<li><strong> 普通函数调用时，应用启用默认绑定规则 </strong>，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。</li>\n<li>当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函数，会自动执行下面的操作<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象或被执行原型链连接</li>\n<li>这个新对象会绑定到函数调用的 this</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"四种绑定的优先级\"><a href=\"#四种绑定的优先级\" class=\"headerlink\" title=\"四种绑定的优先级\"></a>四种绑定的优先级</h2><p>这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。<strong> 默认优先级最低 &lt; 隐式绑定第二 &lt; 显示绑定第三 &lt; new 绑定最高 </strong></p>\n<hr>\n<h2 id=\"箭头函数中的-this\"><a href=\"#箭头函数中的-this\" class=\"headerlink\" title=\"箭头函数中的 this\"></a>箭头函数中的 this</h2><p>箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// 定义在全局对象中，因此this绑定在全局作用域</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 1 ,在全局对象中调用</span></span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// 1,显示绑定，由obj对象来调用，但根本不影响结果</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.speak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    <span class=\"comment\">// 普通函数（非箭头函数),this绑定在调用时的作用域</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bornYear = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 本文写于2016年，因此new Date().getFullYear()得到的是2016</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数，this绑定在实例内部</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear() - <span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>)</span><br><span class=\"line\">zxt.speak() <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\">zxt.bornYear() <span class=\"comment\">// 1994</span></span><br><span class=\"line\"><span class=\"comment\">// 到这里应该大家应该都没什么问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoMing = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xiaoming'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span> <span class=\"comment\">// 小明永远18岁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">zxt.speak.call(xiaoMing)</span><br><span class=\"line\"><span class=\"comment\">// \"xiaoming\" this绑定的是xiaoMing这个对象</span></span><br><span class=\"line\">zxt.bornYear.call(xiaoMing)</span><br></pre></td></tr></table></figure>\n<p>以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">'awesome'</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\">obj.cool() <span class=\"comment\">// 酷,object</span></span><br><span class=\"line\">setTimeout(obj.cool, <span class=\"number\">100</span>) <span class=\"comment\">//window</span></span><br></pre></td></tr></table></figure>\n<p>cool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span> <span class=\"comment\">//_this = object&#123;&#125;</span></span><br><span class=\"line\">  _this.id = name</span><br><span class=\"line\">  _this.cool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"keyword\">new</span> Obj(<span class=\"string\">'yaya'</span>) <span class=\"comment\">//yaya</span></span><br><span class=\"line\">test.cool() <span class=\"comment\">//yaya</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</span><br><span class=\"line\">  id: xiaohong,</span><br><span class=\"line\">  age: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test.cool.call(xiaohong) <span class=\"comment\">//根本不执行</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identify</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + identify.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(greeting)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kyle'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> you = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Reader'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">identify.call(me) <span class=\"comment\">// KYLE</span></span><br><span class=\"line\">identify.call(you) <span class=\"comment\">// READER</span></span><br><span class=\"line\">speak.call(me) <span class=\"comment\">// Hello, 我是KYLE</span></span><br><span class=\"line\">speak.call(you) <span class=\"comment\">// Hello, 我是READER</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo: '</span> + num)</span><br><span class=\"line\">  <span class=\"comment\">// 记录foo被调用的次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"><span class=\"comment\">// foo被调用了多少次？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count) <span class=\"comment\">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>\n<p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。</p>\n<p><strong> 匿名函数无法指向自身 </strong>，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用匿名函数，至少在需要自引用时使用时使用具名函数</p>\n<p><strong>this 在任何情况下都不指向函数的词法作用域 </strong>，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 **</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，<strong> 不能使用 this 来引用一个词法作用域内部的东西 </strong>，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的</p>\n<hr>\n<h2 id=\"综合题\"><a href=\"#综合题\" class=\"headerlink\" title=\"综合题\"></a>综合题</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"string\">'宋伟老师'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  names: <span class=\"string\">'张健老师'</span>,</span><br><span class=\"line\">  showName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  returnName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  returnFunctionName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showName() <span class=\"comment\">//输出什么？   \"张健老师\"</span></span><br><span class=\"line\">obj.returnName() <span class=\"comment\">//输出什么？   \"张健老师\"</span></span><br><span class=\"line\">obj.returnFunctionName()() <span class=\"comment\">//输出什么？   \"宋伟老师\"</span></span><br><span class=\"line\">obj.showName.call(names) <span class=\"comment\">//输出什么？   undefined</span></span><br><span class=\"line\">obj.returnName.call(names) <span class=\"comment\">//输出什么？   undefined</span></span><br><span class=\"line\">obj.returnFunctionName().call(names) <span class=\"comment\">//输出什么？   undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newObj = obj.returnFunctionName().bind(<span class=\"built_in\">window</span>)</span><br><span class=\"line\">newObj.call(obj) <span class=\"comment\">//输出什么？   \"宋伟老师\"</span></span><br><span class=\"line\"><span class=\"comment\">//为什么最后一个输出\"宋伟老师\"？因为bind指向this对象后  再一次调用的话  this指向不会被改变</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> big = <span class=\"string\">'万达老师'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  big: <span class=\"string\">'宋伟老师'</span>,</span><br><span class=\"line\">  showBig: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.big</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showBig.call(big) <span class=\"comment\">//ƒ big() &#123; [native code] &#125;  //精通String的操作方法的同学就把为什么回复出来吧</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length);                 <span class=\"comment\">//4</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.callee.length);          <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>](<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>,<span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(a,<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个输出结果:因为this当前指向的是arguments 。 arguments是一个伪数组具备length属性。arguments又是保存函数的实参。</span></span><br><span class=\"line\">fn调用的时候传入<span class=\"number\">4</span>个实参。所以<span class=\"built_in\">arguments</span>长度为<span class=\"number\">4</span>。这个时候<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] 等同于 <span class=\"built_in\">arguments</span>.a调用这个函数。所以<span class=\"keyword\">this</span>指向的是<span class=\"built_in\">arguments</span>这个伪数组也是(对象)(听到这还有疑惑小伙伴留言问我)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二个输出结果：callee是arguments的一个属性,主要返回当前arguments直属的函数体。所以this.callees是返回fn 。每一个函数有一个length属性主要用来返回函数的形参的所以就是1。</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><a href=\"http://mp.weixin.qq.com/s/2PnWD8bIFgEJxYONoPZs6w\" target=\"_blank\" rel=\"noopener\">链接</a></p>\n<ol>\n<li>js 函数中 this 指向并不是在函数定义的时候确定的，而是在函数调用的时候确定的，所以函数的调用方式决定 this 的 指向。this 永远指向最后调用它的那个对象。</li>\n<li>普通的函数有 3 种调用方式：直接调用，方法调用和 new 调用。除此之外还有通过 bind() 将函数绑定到对象之后再调用，通过 call()、apply() 进行调用等。es6 引入箭头函数之后，其 this 指向又有所不同。</li>\n<li>this 既不是指向函数自身也不指向函数作用域，this 实际上是在函数被调用是发生绑定的，它的指向完全取决于函数在哪里调用。</li>\n</ol>","more":"<h2 id=\"默认绑定\"><a href=\"#默认绑定\" class=\"headerlink\" title=\"默认绑定\"></a>默认绑定</h2><p>在 JavaScript 中，最常用的函数调用类型就是独立函数调用。如果在调用函数的时候，函数不带任何修饰，也就是光秃秃的调用，那就会应用默认绑定规则，默认绑定的指向的是全局作用域。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> charset=<span class=\"string\">\"utf-8\"</span>&gt;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">\"g\"</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);        <span class=\"comment\">//g</span></span><br><span class=\"line\">      a.name = <span class=\"string\">'inside'</span>;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">          <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name);  <span class=\"comment\">//g</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      b();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  a();</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>a()</code> 函数在全局作用域中被调用，因此第 1 句中的 <code>this</code> 就绑定在了全局对象上。<code>b()</code> 函数在 <code>a()</code> 函数里面调用，即使这样第二句中的 <code>this</code> 指代的仍然是全局对象，即使 <code>a()</code> 函数设置了 <code>name</code> 属性。这就是默认绑定规则，它是 <code>js</code> 中最常见的一种函数调用模式，<code>this</code> 的绑定规则也是最简单的一种，就是绑定在全局作用域上</p>\n<p><strong> 但是如果使用了严格模式，则 <code>this</code> 不能绑定到全局对象，在严格模式下，把 <code>this</code> 绑定到全局对象上时，实际上绑定的是 <code>underfined</code>，因此上面的代码会报错 </strong></p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> c = <span class=\"keyword\">this</span></span><br><span class=\"line\">  c.name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//inside</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'g'</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(name) <span class=\"comment\">//underfined</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> name = <span class=\"string\">'inside'</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">b</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//g</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  b()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n<p>所以通过上面的实验可以充分的得出一个结论，this 确实不是指向的当前作用域的，this 和词法作用域是完全不同的。</p>\n<hr>\n<h2 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h2><p>当函数在调用时，如果函数有所谓的 “ 落脚点 ”, 即有上下文对象时，隐式绑定规则会把函数中的 this 绑定到这个上下文对象。如果觉得上面这段话不够直白的话，还是来看代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'zxt1'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.say() <span class=\"comment\">// zxt</span></span><br><span class=\"line\">obj2.say() <span class=\"comment\">// zxt1</span></span><br></pre></td></tr></table></figure>\n<p>obj1 ， obj2 就是所谓 say 函数的落脚点，专业一点的说法就是上下文对象，给函数指定了这个上下文对象的时，函数内部的 this 自然指向了这个上下文对象。这是很常见的函数调用模式</p>\n<p><strong> 对象属性引用链中只有最顶层或者说是最后一层会影响调用位置 </strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">42</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  obj2: obj2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj1.obj2.foo()</span><br></pre></td></tr></table></figure>\n<h3 id=\"隐式绑定上下文的时丢失上下文\"><a href=\"#隐式绑定上下文的时丢失上下文\" class=\"headerlink\" title=\"隐式绑定上下文的时丢失上下文\"></a>隐式绑定上下文的时丢失上下文</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">say</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'inside'</span>,</span><br><span class=\"line\">  say: say</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> alias = obj.say <span class=\"comment\">// 设置一个简写   (1)</span></span><br><span class=\"line\">alias() <span class=\"comment\">// 函数调用 输出\"global\"  (2)</span></span><br></pre></td></tr></table></figure>\n<p>由于在 js 中，函数是对象，对象之间是引用传递，而不是值传递，因此第一句代码只是 alias = obj.say= say, 也就是 alias = say，obj.say 只是起了一个桥梁的作用，alias 最终引用的是 say 函数的地址，而与 obj 这个对象无关了，这就是所谓的 “ 丢失上下文 ”。最终执行 alias 函数只不过简单的执行了 say 函数</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">doFoo</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// fn其实引用的是foo</span></span><br><span class=\"line\">  fn() <span class=\"comment\">// &lt;-- 调用位置！</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span>,</span><br><span class=\"line\">  foo: foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'oops, global'</span> <span class=\"comment\">// a是全局对象的属性</span></span><br><span class=\"line\">doFoo(obj.foo)</span><br></pre></td></tr></table></figure>\n<p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值。回调函数丢失 this 是很常见的情况，除此之外回调函数的函数可能会修改 this，实际上你无法控制回调函数的执行方式，因此就没办法控制会影响绑定的调用位置</p>\n<hr>\n<h2 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h2><p>显示绑定，显示的将 this 绑定到一个上下文，js 中，提供了三种显示绑定的方法，apply,call ， bind。apply 和 call 的用法基本相似，他们之间的区别是：</p>\n<ul>\n<li><p>apply(obj,[arg1.arg2,…]); 被调用函数的参数以数组的形式给出</p>\n</li>\n<li><p>call(obj,arg1,arg2,arg3,…); 被调用函数的参数依次给出</p>\n</li>\n<li><p>bind 函数执行后，返回的是一个新函数。</p>\n</li>\n</ul>\n<p><strong> 硬性绑定的应用场景：</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">something</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( <span class=\"keyword\">this</span>.a, something );</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.a + something;</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar obj = &#123;</span><br><span class=\"line\">a:<span class=\"number\">2</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bar = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> foo.apply( obj, <span class=\"built_in\">arguments</span> );</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = bar( <span class=\"number\">3</span> ); <span class=\"comment\">// 2 3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( b ); <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>另一种使用方法是创建一个</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> name = <span class=\"string\">'global'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj1'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'obj2'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">speak() <span class=\"comment\">// global 等价于speak.call(window)</span></span><br><span class=\"line\">speak.call(<span class=\"built_in\">window</span>)</span><br><span class=\"line\">speak.call(obj1) <span class=\"comment\">// obj1</span></span><br><span class=\"line\">speak.call(obj2) <span class=\"comment\">// obj2</span></span><br></pre></td></tr></table></figure>\n<p>带参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj2 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">3</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">count.call(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.apply(obj1, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 4</span></span><br><span class=\"line\">count.call(obj2, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 5</span></span><br><span class=\"line\">count.apply(obj2, [<span class=\"number\">1</span>, <span class=\"number\">2</span>]) <span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure>\n<p>因此可以看出，apply ， call 的作用就是给函数绑定一个执行上下文，且是显示绑定的。因此函数内的 this 自然而然就绑定在了 call 或者 apply 所调用的对象上。而 bind 函数，则返回一个绑定了制定的执行上下文的新函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带参数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">count</span>(<span class=\"params\">num1, num2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a * num1 + num2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj1 = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> bound1 = count.bind(obj1) <span class=\"comment\">// 未指定参数</span></span><br><span class=\"line\">bound1(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound2 = count.bind(obj1, <span class=\"number\">1</span>) <span class=\"comment\">// 指定了一个参数</span></span><br><span class=\"line\">bound2(<span class=\"number\">2</span>) <span class=\"comment\">// 4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound3 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">// 指定了两个参数</span></span><br><span class=\"line\">bound3() <span class=\"comment\">//4</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> bound4 = count.bind(obj1, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">// 指定了多余的参数,多余的参数会被忽略</span></span><br><span class=\"line\">bound4() <span class=\"comment\">// 4</span></span><br></pre></td></tr></table></figure>\n<p>所以 bind 方法只是返回了一个新的函数，这个函数内的 this 指定了执行上下文，而返回这个新函数可以接受参数。</p>\n<hr>\n<p>new 绑定最后要将的一种 this 绑定规则，是指通过 new 操作符调用构造函数时发生的 this 绑定。构造函数也仅仅是普通函数而已，只不过构造函数以答谢字母开头，也只不过它可以通过 new 操作符调用而已。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'我也只不过是个普通函数'</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>) <span class=\"comment\">//window、window、Person</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(age) <span class=\"comment\">// 22</span></span><br><span class=\"line\">Person(<span class=\"string\">'yh'</span>, <span class=\"number\">122</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>) <span class=\"comment\">// \"我也只不过是个普通函数\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.name) <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(zxt.age) <span class=\"comment\">// 22</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name) <span class=\"comment\">//yu</span></span><br></pre></td></tr></table></figure>\n<p>定义的 Person 函数，既可以普通调用，也可以构造函数的形式上的调用，当普通函数调用时，则按正常的函数执行，输出一个字符串。如果通过一个 new 操作符，则构造了一个新的对象。</p>\n<p>两种调用方式的不同之处：</p>\n<ul>\n<li><strong> 普通函数调用时，应用启用默认绑定规则 </strong>，this 绑定在全局上，此时全局对象上回分别增加 name 和 age 两个属性。</li>\n<li>当通过 new 操作符时，会产生一个新对象，并且会把构造函数内的 this 绑定到这个对象上，事实上，在 js 中，使用 new 来调用函数，会自动执行下面的操作<ol>\n<li>创建一个全新的对象。</li>\n<li>这个新对象或被执行原型链连接</li>\n<li>这个新对象会绑定到函数调用的 this</li>\n<li>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"四种绑定的优先级\"><a href=\"#四种绑定的优先级\" class=\"headerlink\" title=\"四种绑定的优先级\"></a>四种绑定的优先级</h2><p>这四种绑定规则基本上涵盖了所有函数调用情况。但是同时应用了这四种规则中的两种甚至更多，又该是怎么样的一个情况，或者说这四种绑定的优先级顺序又是怎么样的。<strong> 默认优先级最低 &lt; 隐式绑定第二 &lt; 显示绑定第三 &lt; new 绑定最高 </strong></p>\n<hr>\n<h2 id=\"箭头函数中的-this\"><a href=\"#箭头函数中的-this\" class=\"headerlink\" title=\"箭头函数中的 this\"></a>箭头函数中的 this</h2><p>箭头函数的 this 是根据外层的 ( 函数或则全局 ) 作用于来决定的，函数体内的 this 对象指的是定义时所在的对象，而不是之前介绍的调用时绑定的对象。箭头函数的 this 始终指向函数定义时的 this，而非执行时。箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a) <span class=\"comment\">// 定义在全局对象中，因此this绑定在全局作用域</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  a: <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() <span class=\"comment\">// 1 ,在全局对象中调用</span></span><br><span class=\"line\">foo.call(obj) <span class=\"comment\">// 1,显示绑定，由obj对象来调用，但根本不影响结果</span></span><br></pre></td></tr></table></figure>\n<p>箭头函数的 this 强制性的绑定在了箭头函数定义时所在的作用域，而且无法通过显示绑定，如 apply，call 方法来修改</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.speak = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    <span class=\"comment\">// 普通函数（非箭头函数),this绑定在调用时的作用域</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bornYear = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 本文写于2016年，因此new Date().getFullYear()得到的是2016</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数，this绑定在实例内部</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>().getFullYear() - <span class=\"keyword\">this</span>.age)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> zxt = <span class=\"keyword\">new</span> Person(<span class=\"string\">'zxt'</span>, <span class=\"number\">22</span>)</span><br><span class=\"line\">zxt.speak() <span class=\"comment\">// \"zxt\"</span></span><br><span class=\"line\">zxt.bornYear() <span class=\"comment\">// 1994</span></span><br><span class=\"line\"><span class=\"comment\">// 到这里应该大家应该都没什么问题</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaoMing = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'xiaoming'</span>,</span><br><span class=\"line\">  age: <span class=\"number\">18</span> <span class=\"comment\">// 小明永远18岁</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">zxt.speak.call(xiaoMing)</span><br><span class=\"line\"><span class=\"comment\">// \"xiaoming\" this绑定的是xiaoMing这个对象</span></span><br><span class=\"line\">zxt.bornYear.call(xiaoMing)</span><br></pre></td></tr></table></figure>\n<p>以上就是 javascript 中所有 this 绑定的情况，在 es6 之前，前面所说的四种绑定规则可以涵盖任何的函数调用情况，es6 标准实施以后，对于函数的扩展新增了箭头函数，与之不同的是，箭头函数的作用于位于箭头函数定义时所在的作用域。</p>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  id: <span class=\"string\">'awesome'</span>,</span><br><span class=\"line\">  cool: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">coolFn</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\">obj.cool() <span class=\"comment\">// 酷,object</span></span><br><span class=\"line\">setTimeout(obj.cool, <span class=\"number\">100</span>) <span class=\"comment\">//window</span></span><br></pre></td></tr></table></figure>\n<p>cool() 函数丢失了同 this 之间的绑定， var self = this 这种方案可以圆满解决了理解和正确使用 this 绑定的问题。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Obj</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span> <span class=\"comment\">//_this = object&#123;&#125;</span></span><br><span class=\"line\">  _this.id = name</span><br><span class=\"line\">  _this.cool = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(_this.id)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> id = <span class=\"string\">'not awesome'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> test = <span class=\"keyword\">new</span> Obj(<span class=\"string\">'yaya'</span>) <span class=\"comment\">//yaya</span></span><br><span class=\"line\">test.cool() <span class=\"comment\">//yaya</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> xiaohong = &#123;</span><br><span class=\"line\">  id: xiaohong,</span><br><span class=\"line\">  age: <span class=\"number\">18</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test.cool.call(xiaohong) <span class=\"comment\">//根本不执行</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">identify</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name.toUpperCase()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">speak</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> greeting = <span class=\"string\">\"Hello, I'm \"</span> + identify.call(<span class=\"keyword\">this</span>)</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(greeting)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> me = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Kyle'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> you = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Reader'</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">identify.call(me) <span class=\"comment\">// KYLE</span></span><br><span class=\"line\">identify.call(you) <span class=\"comment\">// READER</span></span><br><span class=\"line\">speak.call(me) <span class=\"comment\">// Hello, 我是KYLE</span></span><br><span class=\"line\">speak.call(you) <span class=\"comment\">// Hello, 我是READER</span></span><br></pre></td></tr></table></figure>\n<hr>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'foo: '</span> + num)</span><br><span class=\"line\">  <span class=\"comment\">// 记录foo被调用的次数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.count++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo.count = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> i</span><br><span class=\"line\"><span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">    foo(i)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// foo: 6</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 7</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 8</span></span><br><span class=\"line\"><span class=\"comment\">// foo: 9</span></span><br><span class=\"line\"><span class=\"comment\">// foo被调用了多少次？</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(foo.count) <span class=\"comment\">// 0 -- WTF?</span></span><br></pre></td></tr></table></figure>\n<p>执行 foo.count = 0 时，的确向函数对象 foo 添加了一个属性 count。但是函数内部代码 this.count 中的 this 并不指向那个函数，所以虽然属性名相同，跟对象却并不相同。这段代码在五一中创建了一个全局变量 count。</p>\n<p><strong> 匿名函数无法指向自身 </strong>，arguments.callee 是唯一一种从匿名函数对象中引用自身的方法，已被弃用。，然而更好的是避免使用匿名函数，至少在需要自引用时使用时使用具名函数</p>\n<p><strong>this 在任何情况下都不指向函数的词法作用域 </strong>，作用域 “ 对象 ” 无法通过 js 代码来访问，它存在于 js 引擎内部 **</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span></span><br><span class=\"line\">  <span class=\"keyword\">this</span>.bar()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>试图用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar 可以 i 访问 foo() 变量的 a，这是不可能实现的，<strong> 不能使用 this 来引用一个词法作用域内部的东西 </strong>，每当想要把 this 和此法作用域混用的时候，一定要提醒自己，这是无法实现的</p>\n<hr>\n<h2 id=\"综合题\"><a href=\"#综合题\" class=\"headerlink\" title=\"综合题\"></a>综合题</h2><h3 id=\"1\"><a href=\"#1\" class=\"headerlink\" title=\"1\"></a>1</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> names = <span class=\"string\">'宋伟老师'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  names: <span class=\"string\">'张健老师'</span>,</span><br><span class=\"line\">  showName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  returnName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  returnFunctionName: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showName() <span class=\"comment\">//输出什么？   \"张健老师\"</span></span><br><span class=\"line\">obj.returnName() <span class=\"comment\">//输出什么？   \"张健老师\"</span></span><br><span class=\"line\">obj.returnFunctionName()() <span class=\"comment\">//输出什么？   \"宋伟老师\"</span></span><br><span class=\"line\">obj.showName.call(names) <span class=\"comment\">//输出什么？   undefined</span></span><br><span class=\"line\">obj.returnName.call(names) <span class=\"comment\">//输出什么？   undefined</span></span><br><span class=\"line\">obj.returnFunctionName().call(names) <span class=\"comment\">//输出什么？   undefined</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> newObj = obj.returnFunctionName().bind(<span class=\"built_in\">window</span>)</span><br><span class=\"line\">newObj.call(obj) <span class=\"comment\">//输出什么？   \"宋伟老师\"</span></span><br><span class=\"line\"><span class=\"comment\">//为什么最后一个输出\"宋伟老师\"？因为bind指向this对象后  再一次调用的话  this指向不会被改变</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"2\"><a href=\"#2\" class=\"headerlink\" title=\"2\"></a>2</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> big = <span class=\"string\">'万达老师'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</span><br><span class=\"line\">  big: <span class=\"string\">'宋伟老师'</span>,</span><br><span class=\"line\">  showBig: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.big</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">obj.showBig.call(big) <span class=\"comment\">//ƒ big() &#123; [native code] &#125;  //精通String的操作方法的同学就把为什么回复出来吧</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"3\"><a href=\"#3\" class=\"headerlink\" title=\"3\"></a>3</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span>(<span class=\"params\">a,b,c</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.length);                 <span class=\"comment\">//4</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span>.callee.length);          <span class=\"comment\">//1</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fn</span>(<span class=\"params\">d</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>](<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>,<span class=\"number\">50</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fn(a,<span class=\"number\">10</span>,<span class=\"number\">20</span>,<span class=\"number\">30</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第一个输出结果:因为this当前指向的是arguments 。 arguments是一个伪数组具备length属性。arguments又是保存函数的实参。</span></span><br><span class=\"line\">fn调用的时候传入<span class=\"number\">4</span>个实参。所以<span class=\"built_in\">arguments</span>长度为<span class=\"number\">4</span>。这个时候<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] 等同于 <span class=\"built_in\">arguments</span>.a调用这个函数。所以<span class=\"keyword\">this</span>指向的是<span class=\"built_in\">arguments</span>这个伪数组也是(对象)(听到这还有疑惑小伙伴留言问我)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//第二个输出结果：callee是arguments的一个属性,主要返回当前arguments直属的函数体。所以this.callees是返回fn 。每一个函数有一个length属性主要用来返回函数的形参的所以就是1。</span></span><br></pre></td></tr></table></figure>"},{"title":"react-native 入门","_content":"\nreact-native 入门基础笔记：使用 ：react-native init AwesomeProject 进行构建 react-native 项目\n\n<!--more-->\n\n## react-native 目录详解\n\n里面有四个文件夹：\n\n* android / ios ：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；\n* node_modules ：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；\n* js ：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自\n","source":"_posts/react-native-入门.md","raw":"---\ntitle: react-native 入门\ncategories: react-native\ntags:\n---\n\nreact-native 入门基础笔记：使用 ：react-native init AwesomeProject 进行构建 react-native 项目\n\n<!--more-->\n\n## react-native 目录详解\n\n里面有四个文件夹：\n\n* android / ios ：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；\n* node_modules ：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；\n* js ：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自\n","slug":"react-native-入门","published":1,"date":"2018-03-20T03:29:41.820Z","updated":"2018-03-20T03:29:41.820Z","_id":"cjepksjnq000q8gv60xhp3aqi","comments":1,"layout":"post","photos":[],"link":"","content":"<p>react-native 入门基础笔记：使用 ：react-native init AwesomeProject 进行构建 react-native 项目</p>\n<a id=\"more\"></a>\n<h2 id=\"react-native-目录详解\"><a href=\"#react-native-目录详解\" class=\"headerlink\" title=\"react-native 目录详解\"></a>react-native 目录详解</h2><p>里面有四个文件夹：</p>\n<ul>\n<li>android / ios ：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；</li>\n<li>node_modules ：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；</li>\n<li>js ：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>react-native 入门基础笔记：使用 ：react-native init AwesomeProject 进行构建 react-native 项目</p>","more":"<h2 id=\"react-native-目录详解\"><a href=\"#react-native-目录详解\" class=\"headerlink\" title=\"react-native 目录详解\"></a>react-native 目录详解</h2><p>里面有四个文件夹：</p>\n<ul>\n<li>android / ios ：各自存放了一个相关平台的工程 project，可以直接下拉 JS Bundle 并运行，对于 移动端小白而言可以不用管里面的具体实现；</li>\n<li>node_modules ：里面是自动生成的 node 依赖之类的文件，通过读取 package.json 里的配置来生成；</li>\n<li>js ：这个文件夹最为重要，我们的开发都在这个文件夹里，把写好的 js 文件打包下发给 client 就会自</li>\n</ul>"},{"title":"优化-seo优化","date":"2018-03-08T09:05:51.000Z","_content":"\nseo 优化整合\n\n<!--more-->\n\n* 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可\n* 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页\n* 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用 js 输出：爬虫不会执行 js 获取内容\n* 少用 iframe：搜索引擎不会抓取 iframe 中的内容\n* 非装饰性图片必须加 alt\n* 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n## WEB 开发中会话跟踪的方法有哪些\nHTTP 是一种无状态协议，当用户发出请求时，服务器就会做出响应，客户端与服务端的联系是离散的，非连续的，当用户在同一个网站的多个页面之间转换时，根本无法确定是否是同一个用户，会话跟踪就可以解决这个问题。当一个用户在多个页面间切换时，服务就会保存该用户的信息。\n1. cookie\n2. session\n3. url 重写\n4. 隐藏input\n5. ip地址\n\n","source":"_posts/优化.md","raw":"---\ntitle: 优化-seo优化\ndate: 2018-03-08 17:05:51\ntags:\n---\n\nseo 优化整合\n\n<!--more-->\n\n* 合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可\n* 语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页\n* 重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用 js 输出：爬虫不会执行 js 获取内容\n* 少用 iframe：搜索引擎不会抓取 iframe 中的内容\n* 非装饰性图片必须加 alt\n* 提高网站速度：网站速度是搜索引擎排序的一个重要指标\n\n## WEB 开发中会话跟踪的方法有哪些\nHTTP 是一种无状态协议，当用户发出请求时，服务器就会做出响应，客户端与服务端的联系是离散的，非连续的，当用户在同一个网站的多个页面之间转换时，根本无法确定是否是同一个用户，会话跟踪就可以解决这个问题。当一个用户在多个页面间切换时，服务就会保存该用户的信息。\n1. cookie\n2. session\n3. url 重写\n4. 隐藏input\n5. ip地址\n\n","slug":"优化","published":1,"updated":"2018-03-20T03:29:41.821Z","_id":"cjepksjnu000s8gv6r30x9r5v","comments":1,"layout":"post","photos":[],"link":"","content":"<p>seo 优化整合</p>\n<a id=\"more\"></a>\n<ul>\n<li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li>\n<li>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li>\n<li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li>\n<li>少用 iframe：搜索引擎不会抓取 iframe 中的内容</li>\n<li>非装饰性图片必须加 alt</li>\n<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>\n</ul>\n<h2 id=\"WEB-开发中会话跟踪的方法有哪些\"><a href=\"#WEB-开发中会话跟踪的方法有哪些\" class=\"headerlink\" title=\"WEB 开发中会话跟踪的方法有哪些\"></a>WEB 开发中会话跟踪的方法有哪些</h2><p>HTTP 是一种无状态协议，当用户发出请求时，服务器就会做出响应，客户端与服务端的联系是离散的，非连续的，当用户在同一个网站的多个页面之间转换时，根本无法确定是否是同一个用户，会话跟踪就可以解决这个问题。当一个用户在多个页面间切换时，服务就会保存该用户的信息。</p>\n<ol>\n<li>cookie</li>\n<li>session</li>\n<li>url 重写</li>\n<li>隐藏input</li>\n<li>ip地址</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>seo 优化整合</p>","more":"<ul>\n<li>合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可</li>\n<li>语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页</li>\n<li>重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取重要内容不要用 js 输出：爬虫不会执行 js 获取内容</li>\n<li>少用 iframe：搜索引擎不会抓取 iframe 中的内容</li>\n<li>非装饰性图片必须加 alt</li>\n<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>\n</ul>\n<h2 id=\"WEB-开发中会话跟踪的方法有哪些\"><a href=\"#WEB-开发中会话跟踪的方法有哪些\" class=\"headerlink\" title=\"WEB 开发中会话跟踪的方法有哪些\"></a>WEB 开发中会话跟踪的方法有哪些</h2><p>HTTP 是一种无状态协议，当用户发出请求时，服务器就会做出响应，客户端与服务端的联系是离散的，非连续的，当用户在同一个网站的多个页面之间转换时，根本无法确定是否是同一个用户，会话跟踪就可以解决这个问题。当一个用户在多个页面间切换时，服务就会保存该用户的信息。</p>\n<ol>\n<li>cookie</li>\n<li>session</li>\n<li>url 重写</li>\n<li>隐藏input</li>\n<li>ip地址</li>\n</ol>"},{"title":"webpack项目配置","date":"2018-01-31T09:15:07.000Z","_content":"\nwebpack 是模块化管理工具，使用 webpack 可以对模块进行压缩，预处理，按需打包，按需加载等。\n\n<!--more-->\n\n## webpack 的特征\n\n* 插件化：webpack 本身非常灵活，提供了丰富插件接口。基于这些接口，webpack 开发了很多插件作为内置功能。\n* 速度快：webpack 使用异步 IO 以及多级缓存机制。所以 webpack 的速度是很快的，尤其是增量更新。\n* 丰富的 loaders：loaders 用来做预处理。这样 webpack 就可以打包任何静态文件。\n* 高适配性：webpack 同时支持 AMD/CommonJS/ES6 模块方案。webpack 会静态解析你的代码，自动帮你管理他们的依赖关系。且对第 - 方库的兼容贼好。\n* 代码拆分：webpack 提供了很多优化机制来减少打包输出的文件大小，不仅如此它还提供了 hash 机制，来解决浏览器缓存。\n* 开发模式友好：webpack 为开发模式也是提供了很多辅助功能。比如 sourceMap、热更新等。\n* 适用于很多场景。\n\n## webapck 最佳配置\n\nwebpack 官方提供的配置方法是通过 module.exports 返回一个 json, 但是这种场景不灵活，不能适配多种场景。\n\n```javascript\nmodule.exports = function(env) {\n  return {\n    context: config.context,\n    entry: config.src,\n    output: {\n      path: path.join(config.jsDest, project),\n      filename: '[name].js',\n      chunkFilename: '[name].[chunkhash:8].js',\n      publicPath: '/assets/' + project + '/'\n    },\n    devtool: 'eval',\n    watch: false,\n    profile: true,\n    cache: true,\n    module: {\n      loaders: getLoaders(env)\n    },\n    resolve: {\n      alias: getAlias(env)\n    },\n    plugins: getPlugins(env)\n  }\n}\n```\n\n* context: 上下文。\n* entry: 入口文件，是所有依赖关系的入口，webpack 从这个入口开始静态解析，分析模块之间的依赖关系。\n* output: 打包输出的配置。\n* devtools:SourceMap 选项，便于开发模式下调试。\n* watch: 监听模式，增量更新，开发必备\n* profile: 优化。\n* cache: webpack 构建的过程中会生成很多的临时文件，打开 cache 可以让这些临时文件缓存起来，从而更快的构建。\n* module.loaders: 如前文介绍，loader 用来对文件做预处理。这样 webpack 就可以打包任何静态文件。\n* resolve.alias: 模块别名，这样就可以更方便的引用模块。\n* plugins: 如前文介绍，webpack 的一些内置功能均是以插件的形式提供。\n\n","source":"_posts/webpack项目配置.md","raw":"---\ntitle: webpack项目配置\ndate: 2018-01-31 17:15:07\ncategories: 项目构建工具\n---\n\nwebpack 是模块化管理工具，使用 webpack 可以对模块进行压缩，预处理，按需打包，按需加载等。\n\n<!--more-->\n\n## webpack 的特征\n\n* 插件化：webpack 本身非常灵活，提供了丰富插件接口。基于这些接口，webpack 开发了很多插件作为内置功能。\n* 速度快：webpack 使用异步 IO 以及多级缓存机制。所以 webpack 的速度是很快的，尤其是增量更新。\n* 丰富的 loaders：loaders 用来做预处理。这样 webpack 就可以打包任何静态文件。\n* 高适配性：webpack 同时支持 AMD/CommonJS/ES6 模块方案。webpack 会静态解析你的代码，自动帮你管理他们的依赖关系。且对第 - 方库的兼容贼好。\n* 代码拆分：webpack 提供了很多优化机制来减少打包输出的文件大小，不仅如此它还提供了 hash 机制，来解决浏览器缓存。\n* 开发模式友好：webpack 为开发模式也是提供了很多辅助功能。比如 sourceMap、热更新等。\n* 适用于很多场景。\n\n## webapck 最佳配置\n\nwebpack 官方提供的配置方法是通过 module.exports 返回一个 json, 但是这种场景不灵活，不能适配多种场景。\n\n```javascript\nmodule.exports = function(env) {\n  return {\n    context: config.context,\n    entry: config.src,\n    output: {\n      path: path.join(config.jsDest, project),\n      filename: '[name].js',\n      chunkFilename: '[name].[chunkhash:8].js',\n      publicPath: '/assets/' + project + '/'\n    },\n    devtool: 'eval',\n    watch: false,\n    profile: true,\n    cache: true,\n    module: {\n      loaders: getLoaders(env)\n    },\n    resolve: {\n      alias: getAlias(env)\n    },\n    plugins: getPlugins(env)\n  }\n}\n```\n\n* context: 上下文。\n* entry: 入口文件，是所有依赖关系的入口，webpack 从这个入口开始静态解析，分析模块之间的依赖关系。\n* output: 打包输出的配置。\n* devtools:SourceMap 选项，便于开发模式下调试。\n* watch: 监听模式，增量更新，开发必备\n* profile: 优化。\n* cache: webpack 构建的过程中会生成很多的临时文件，打开 cache 可以让这些临时文件缓存起来，从而更快的构建。\n* module.loaders: 如前文介绍，loader 用来对文件做预处理。这样 webpack 就可以打包任何静态文件。\n* resolve.alias: 模块别名，这样就可以更方便的引用模块。\n* plugins: 如前文介绍，webpack 的一些内置功能均是以插件的形式提供。\n\n","slug":"webpack项目配置","published":1,"updated":"2018-03-12T15:29:22.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjnv000t8gv6aygceqq9","content":"<p>webpack 是模块化管理工具，使用 webpack 可以对模块进行压缩，预处理，按需打包，按需加载等。</p>\n<a id=\"more\"></a>\n<h2 id=\"webpack-的特征\"><a href=\"#webpack-的特征\" class=\"headerlink\" title=\"webpack 的特征\"></a>webpack 的特征</h2><ul>\n<li>插件化：webpack 本身非常灵活，提供了丰富插件接口。基于这些接口，webpack 开发了很多插件作为内置功能。</li>\n<li>速度快：webpack 使用异步 IO 以及多级缓存机制。所以 webpack 的速度是很快的，尤其是增量更新。</li>\n<li>丰富的 loaders：loaders 用来做预处理。这样 webpack 就可以打包任何静态文件。</li>\n<li>高适配性：webpack 同时支持 AMD/CommonJS/ES6 模块方案。webpack 会静态解析你的代码，自动帮你管理他们的依赖关系。且对第 - 方库的兼容贼好。</li>\n<li>代码拆分：webpack 提供了很多优化机制来减少打包输出的文件大小，不仅如此它还提供了 hash 机制，来解决浏览器缓存。</li>\n<li>开发模式友好：webpack 为开发模式也是提供了很多辅助功能。比如 sourceMap、热更新等。</li>\n<li>适用于很多场景。</li>\n</ul>\n<h2 id=\"webapck-最佳配置\"><a href=\"#webapck-最佳配置\" class=\"headerlink\" title=\"webapck 最佳配置\"></a>webapck 最佳配置</h2><p>webpack 官方提供的配置方法是通过 module.exports 返回一个 json, 但是这种场景不灵活，不能适配多种场景。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    context: config.context,</span><br><span class=\"line\">    entry: config.src,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      path: path.join(config.jsDest, project),</span><br><span class=\"line\">      filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">      chunkFilename: <span class=\"string\">'[name].[chunkhash:8].js'</span>,</span><br><span class=\"line\">      publicPath: <span class=\"string\">'/assets/'</span> + project + <span class=\"string\">'/'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: <span class=\"string\">'eval'</span>,</span><br><span class=\"line\">    watch: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    profile: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    cache: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">      loaders: getLoaders(env)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">      alias: getAlias(env)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: getPlugins(env)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>context: 上下文。</li>\n<li>entry: 入口文件，是所有依赖关系的入口，webpack 从这个入口开始静态解析，分析模块之间的依赖关系。</li>\n<li>output: 打包输出的配置。</li>\n<li>devtools:SourceMap 选项，便于开发模式下调试。</li>\n<li>watch: 监听模式，增量更新，开发必备</li>\n<li>profile: 优化。</li>\n<li>cache: webpack 构建的过程中会生成很多的临时文件，打开 cache 可以让这些临时文件缓存起来，从而更快的构建。</li>\n<li>module.loaders: 如前文介绍，loader 用来对文件做预处理。这样 webpack 就可以打包任何静态文件。</li>\n<li>resolve.alias: 模块别名，这样就可以更方便的引用模块。</li>\n<li>plugins: 如前文介绍，webpack 的一些内置功能均是以插件的形式提供。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>webpack 是模块化管理工具，使用 webpack 可以对模块进行压缩，预处理，按需打包，按需加载等。</p>","more":"<h2 id=\"webpack-的特征\"><a href=\"#webpack-的特征\" class=\"headerlink\" title=\"webpack 的特征\"></a>webpack 的特征</h2><ul>\n<li>插件化：webpack 本身非常灵活，提供了丰富插件接口。基于这些接口，webpack 开发了很多插件作为内置功能。</li>\n<li>速度快：webpack 使用异步 IO 以及多级缓存机制。所以 webpack 的速度是很快的，尤其是增量更新。</li>\n<li>丰富的 loaders：loaders 用来做预处理。这样 webpack 就可以打包任何静态文件。</li>\n<li>高适配性：webpack 同时支持 AMD/CommonJS/ES6 模块方案。webpack 会静态解析你的代码，自动帮你管理他们的依赖关系。且对第 - 方库的兼容贼好。</li>\n<li>代码拆分：webpack 提供了很多优化机制来减少打包输出的文件大小，不仅如此它还提供了 hash 机制，来解决浏览器缓存。</li>\n<li>开发模式友好：webpack 为开发模式也是提供了很多辅助功能。比如 sourceMap、热更新等。</li>\n<li>适用于很多场景。</li>\n</ul>\n<h2 id=\"webapck-最佳配置\"><a href=\"#webapck-最佳配置\" class=\"headerlink\" title=\"webapck 最佳配置\"></a>webapck 最佳配置</h2><p>webpack 官方提供的配置方法是通过 module.exports 返回一个 json, 但是这种场景不灵活，不能适配多种场景。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">env</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    context: config.context,</span><br><span class=\"line\">    entry: config.src,</span><br><span class=\"line\">    output: &#123;</span><br><span class=\"line\">      path: path.join(config.jsDest, project),</span><br><span class=\"line\">      filename: <span class=\"string\">'[name].js'</span>,</span><br><span class=\"line\">      chunkFilename: <span class=\"string\">'[name].[chunkhash:8].js'</span>,</span><br><span class=\"line\">      publicPath: <span class=\"string\">'/assets/'</span> + project + <span class=\"string\">'/'</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    devtool: <span class=\"string\">'eval'</span>,</span><br><span class=\"line\">    watch: <span class=\"literal\">false</span>,</span><br><span class=\"line\">    profile: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    cache: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    <span class=\"built_in\">module</span>: &#123;</span><br><span class=\"line\">      loaders: getLoaders(env)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    resolve: &#123;</span><br><span class=\"line\">      alias: getAlias(env)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    plugins: getPlugins(env)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>context: 上下文。</li>\n<li>entry: 入口文件，是所有依赖关系的入口，webpack 从这个入口开始静态解析，分析模块之间的依赖关系。</li>\n<li>output: 打包输出的配置。</li>\n<li>devtools:SourceMap 选项，便于开发模式下调试。</li>\n<li>watch: 监听模式，增量更新，开发必备</li>\n<li>profile: 优化。</li>\n<li>cache: webpack 构建的过程中会生成很多的临时文件，打开 cache 可以让这些临时文件缓存起来，从而更快的构建。</li>\n<li>module.loaders: 如前文介绍，loader 用来对文件做预处理。这样 webpack 就可以打包任何静态文件。</li>\n<li>resolve.alias: 模块别名，这样就可以更方便的引用模块。</li>\n<li>plugins: 如前文介绍，webpack 的一些内置功能均是以插件的形式提供。</li>\n</ul>"},{"title":"作用域","date":"2018-01-23T03:30:11.000Z","_content":"\n1. 作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询\n2. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n\n<!--more-->\n\n## 欺骗词法作用域\n\n1. eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。\n\n   ```javascript\n   function foo(str, a) {\n   eval( str ); // 欺骗！\n   console.log( a, b );\n   } v\n   ar b = 2;\n   foo( \"var b = 3;\", 1 ); // 1, 3\n   ```\n\n2. with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。\n3. js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.\n\n## var a = 2\n\n编译器会进行如下的处理：\n\n1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。\n2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！\n\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。\n\n编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。\n\n在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS\n\n1. LHS: 赋值操作的目标是谁\n1. RHS：谁是赋值操作的源头\n\n---\n\n当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。\n\n遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。\n\n---\n\n## 函数作用域和块作用域\n\n函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )\n\n1. 立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。\n2. 直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。\n3. 当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。\n\n**提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。**\n\n---\n\n## 提升\n\n任何声明在某个作用域内的变量，都将属于这个作用域\n\n包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。\n\n函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n\nvar a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。\n\n---\n\n## 动态作用域\n\n```javascript\n词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。\nfunction foo() {\nconsole.log( a ); // 2\n} f\nunction bar() {\nvar a = 3;\nfoo();\n} v\nar a = 2;\nbar();\n```\n\n此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;\n\n而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。\n\n事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。\n\n**词法作用域是在写代码或者说定义时确定的**，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。\n","source":"_posts/作用域.md","raw":"---\ntitle: 作用域\ndate: 2018-01-23 11:30:11\ncategories: 原生JS\n---\n\n1. 作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询\n2. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n\n<!--more-->\n\n## 欺骗词法作用域\n\n1. eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。\n\n   ```javascript\n   function foo(str, a) {\n   eval( str ); // 欺骗！\n   console.log( a, b );\n   } v\n   ar b = 2;\n   foo( \"var b = 3;\", 1 ); // 1, 3\n   ```\n\n2. with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。\n3. js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.\n\n## var a = 2\n\n编译器会进行如下的处理：\n\n1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。\n2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！\n\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。\n\n编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。\n\n在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS\n\n1. LHS: 赋值操作的目标是谁\n1. RHS：谁是赋值操作的源头\n\n---\n\n当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。\n\n遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。\n\n---\n\n## 函数作用域和块作用域\n\n函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )\n\n1. 立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。\n2. 直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。\n3. 当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。\n\n**提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。**\n\n---\n\n## 提升\n\n任何声明在某个作用域内的变量，都将属于这个作用域\n\n包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。\n\n函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n\nvar a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。\n\n---\n\n## 动态作用域\n\n```javascript\n词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。\nfunction foo() {\nconsole.log( a ); // 2\n} f\nunction bar() {\nvar a = 3;\nfoo();\n} v\nar a = 2;\nbar();\n```\n\n此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;\n\n而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。\n\n事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。\n\n**词法作用域是在写代码或者说定义时确定的**，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。\n","slug":"作用域","published":1,"updated":"2018-03-20T03:29:41.821Z","_id":"cjepksjny000w8gv6dkgn9xk6","comments":1,"layout":"post","photos":[],"link":"","content":"<ol>\n<li>作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询</li>\n<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</li>\n</ol>\n<a id=\"more\"></a>\n<h2 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h2><ol>\n<li><p>eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">eval</span>( str ); <span class=\"comment\">// 欺骗！</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a, b );</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar b = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo( <span class=\"string\">\"var b = 3;\"</span>, <span class=\"number\">1</span> ); <span class=\"comment\">// 1, 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。</p>\n</li>\n<li>js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.</li>\n</ol>\n<h2 id=\"var-a-2\"><a href=\"#var-a-2\" class=\"headerlink\" title=\"var a = 2\"></a>var a = 2</h2><p>编译器会进行如下的处理：</p>\n<ol>\n<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。</li>\n<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！</li>\n</ol>\n<p>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>\n<p>编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。</p>\n<p>在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS</p>\n<ol>\n<li>LHS: 赋值操作的目标是谁</li>\n<li>RHS：谁是赋值操作的源头</li>\n</ol>\n<hr>\n<p>当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。</p>\n<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>\n<hr>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )</p>\n<ol>\n<li>立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。</li>\n<li>直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。</li>\n<li>当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。</li>\n</ol>\n<p><strong>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。</strong></p>\n<hr>\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>任何声明在某个作用域内的变量，都将属于这个作用域</p>\n<p>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。</p>\n<p>函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>\n<p>var a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。</p>\n<hr>\n<h2 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125; f</span><br><span class=\"line\">unction bar() &#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">foo();</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar a = <span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;</p>\n<p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p>\n<p>事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。</p>\n<p><strong>词法作用域是在写代码或者说定义时确定的</strong>，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>\n","site":{"data":{}},"excerpt":"<ol>\n<li>作用域是一套规则，用于确定在何处以及如何查找变量 ( 标识符 )。如果查找的目的是为变量进行赋值，那么就会使用 LHS，如果查找的目的是获取变量的值，就会使用 RHS 查询</li>\n<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</li>\n</ol>","more":"<h2 id=\"欺骗词法作用域\"><a href=\"#欺骗词法作用域\" class=\"headerlink\" title=\"欺骗词法作用域\"></a>欺骗词法作用域</h2><ol>\n<li><p>eval(), 可以接受一个字符串为参数，并将其中的内容视为好像在书写时就存在程序中这个位置的代码。通常被用来执行动态创建的代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\">str, a</span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">eval</span>( str ); <span class=\"comment\">// 欺骗！</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a, b );</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar b = <span class=\"number\">2</span>;</span><br><span class=\"line\">foo( <span class=\"string\">\"var b = 3;\"</span>, <span class=\"number\">1</span> ); <span class=\"comment\">// 1, 3</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>with ，通常被当做重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会处理为定义在这个作用域中的词法标识符。</p>\n</li>\n<li>js 引擎会在编译阶段进行属相的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行阶段快速找到标志符，如果引擎发现可 eval 和with，它只能简单的假设关于标识符位子的判断都是无效的，因为无法再词法分析阶段明确知道 eval() 会接受到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么.</li>\n</ol>\n<h2 id=\"var-a-2\"><a href=\"#var-a-2\" class=\"headerlink\" title=\"var a = 2\"></a>var a = 2</h2><p>编译器会进行如下的处理：</p>\n<ol>\n<li>遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。</li>\n<li>接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，在当前的作用域集合中是否存在一个叫作 a 的变量。如果否，引擎就会使用这个变量；如果不是，引擎会继续查找该变量，如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常！</li>\n</ol>\n<p>总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。</p>\n<p>编译器在编译过程的第二步中生成了代码，引擎执行它时，会通过查找变量 a 来判断它是否已声明过。查找的过程由作用域进行协助，但是引擎执行怎样的查找，会影响最终的查找结果。</p>\n<p>在我们的例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找类型叫做 RHS</p>\n<ol>\n<li>LHS: 赋值操作的目标是谁</li>\n<li>RHS：谁是赋值操作的源头</li>\n</ol>\n<hr>\n<p>当一个块或者函数嵌套在另一个块或函数中时，就发生了作用于的嵌套。因此作用域中无法找到某个变量是，就会在外层嵌套的作用域中继续查找，知道找到该变量，或抵达最外层的作用域为 ( 也就是全局作用域 ) 止。</p>\n<p>遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。</p>\n<hr>\n<h2 id=\"函数作用域和块作用域\"><a href=\"#函数作用域和块作用域\" class=\"headerlink\" title=\"函数作用域和块作用域\"></a>函数作用域和块作用域</h2><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用 ( 事实上在嵌套的作用用户中也可以使用 )</p>\n<ol>\n<li>立即执行函数会被当做函数表达式而不是一个标准的函数声明来处理，函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。</li>\n<li>直接在全局中声明的函数是并绑定在全局作用域中，而立即执行函数被绑定在函数表达式自身的函数中而不是所在作用域中。</li>\n<li>当使用 var 声明变量时，它写在哪儿都是一样的，因为它们最终都会属于外部作用域。</li>\n</ol>\n<p><strong>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使用 let 进行的声明不会再块级作用域中进行提升。声明的代码被运行之前，声明并不 “ 存在 ”。</strong></p>\n<hr>\n<h2 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h2><p>任何声明在某个作用域内的变量，都将属于这个作用域</p>\n<p>包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。声明将被提升到顶部，而赋值语句将被留在原地等待执行阶段。只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了戴安执行的顺序，会照成非常严重的破坏。</p>\n<p>函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量。尽管重复的声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>\n<p>var a = 2; 被分为两个阶段，一个是编译阶段的任务，而第二个是执行阶段的任务。</p>\n<hr>\n<h2 id=\"动态作用域\"><a href=\"#动态作用域\" class=\"headerlink\" title=\"动态作用域\"></a>动态作用域</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">词法作用域是一套关于引擎如何寻找变量以及会在何处找到变量的规则。动态作用域最重要的特征是它的定义过程发生在代码的书写阶段。</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log( a ); <span class=\"comment\">// 2</span></span><br><span class=\"line\">&#125; f</span><br><span class=\"line\">unction bar() &#123;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">3</span>;</span><br><span class=\"line\">foo();</span><br><span class=\"line\">&#125; v</span><br><span class=\"line\">ar a = <span class=\"number\">2</span>;</span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n<p>此法作用域让 foo() 中的 a 通过 RHS 引用了全局作用域的 a，所以会输出 2;</p>\n<p>而动态作用域并不关心函数和作用域是如何声明以及在何处声明的，值关心它们从何处调用，换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。因此如果 js 具有动态作用域就会输出 3。什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</p>\n<p>事实上 js 并不具备动态作用域。它只有词法作用域，但是 this 机制某种程度上很像动态作用域。</p>\n<p><strong>词法作用域是在写代码或者说定义时确定的</strong>，而动态作用域是在运动时确定的。(this 也是 )，词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</p>"},{"title":"你不知道的JavaScript","date":"2018-01-15T08:52:42.000Z","_content":"\n读 《你不知道的 JavaScript》 笔记\n\n<!--more-->\n\n## JS 数据类型\n\nJS 数据类型分为基本数据类型和复杂数据类型\n\n**基本数据类型**\n\n`Number`、`Boolean`、`String`、`Null`、`String`、`Symbol`\n\n** 复杂数据类型**\n\nObject，其他引用类型（Array 、 Date、RegExp 、 Function、基本包装类型（Boolean 、 String、Number ）、Math 等）都是 Object 类型的实例对象\n\n## 类型和语法\n\n### 内置类型\n\njavascript 有 7 中内置类型：\n\n* 空值 (null)\n* 未定义 (undefined)\n* 布尔值 (boolean)\n* 数字 (number)\n* 字符串 (string)\n* 对象 (object)\n* 符号 (symbol,ES6 中新增 )\n\n**除对象之外，其他同称为 “ 基本对象 ”**\n\njavascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。\n\n```javascript\nvar a\nvar b = 42\nvar c\nb = c\ntypeof b //undefined\ntypeof a //undefined\n```\n\nundeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（阻止报错）来检查 undeclared 变量\n\n## 数组\n\n```javascript\nvar a = []\na[3] = '2'\na.length //4\n```\n\n### 字符串\n\n字符串经常被当成字符数组，但它们仅仅是看上去相似而已\n\n```javascript\nvar a = 'fff'\nvar b = ['f', 'f', 'f']\nconsole.log(a.length, b.length) //3,3\n```\n","source":"_posts/你不知道的JavaScript.md","raw":"---\ntitle: 你不知道的JavaScript\ndate: 2018-01-15 16:52:42\ntags:\n---\n\n读 《你不知道的 JavaScript》 笔记\n\n<!--more-->\n\n## JS 数据类型\n\nJS 数据类型分为基本数据类型和复杂数据类型\n\n**基本数据类型**\n\n`Number`、`Boolean`、`String`、`Null`、`String`、`Symbol`\n\n** 复杂数据类型**\n\nObject，其他引用类型（Array 、 Date、RegExp 、 Function、基本包装类型（Boolean 、 String、Number ）、Math 等）都是 Object 类型的实例对象\n\n## 类型和语法\n\n### 内置类型\n\njavascript 有 7 中内置类型：\n\n* 空值 (null)\n* 未定义 (undefined)\n* 布尔值 (boolean)\n* 数字 (number)\n* 字符串 (string)\n* 对象 (object)\n* 符号 (symbol,ES6 中新增 )\n\n**除对象之外，其他同称为 “ 基本对象 ”**\n\njavascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。\n\n```javascript\nvar a\nvar b = 42\nvar c\nb = c\ntypeof b //undefined\ntypeof a //undefined\n```\n\nundeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（阻止报错）来检查 undeclared 变量\n\n## 数组\n\n```javascript\nvar a = []\na[3] = '2'\na.length //4\n```\n\n### 字符串\n\n字符串经常被当成字符数组，但它们仅仅是看上去相似而已\n\n```javascript\nvar a = 'fff'\nvar b = ['f', 'f', 'f']\nconsole.log(a.length, b.length) //3,3\n```\n","slug":"你不知道的JavaScript","published":1,"updated":"2018-03-20T03:29:41.822Z","_id":"cjepksjo2000x8gv6l2lec38d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>读 《你不知道的 JavaScript》 笔记</p>\n<a id=\"more\"></a>\n<h2 id=\"JS-数据类型\"><a href=\"#JS-数据类型\" class=\"headerlink\" title=\"JS 数据类型\"></a>JS 数据类型</h2><p>JS 数据类型分为基本数据类型和复杂数据类型</p>\n<p><strong>基本数据类型</strong></p>\n<p><code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Null</code>、<code>String</code>、<code>Symbol</code></p>\n<p><strong> 复杂数据类型</strong></p>\n<p>Object，其他引用类型（Array 、 Date、RegExp 、 Function、基本包装类型（Boolean 、 String、Number ）、Math 等）都是 Object 类型的实例对象</p>\n<h2 id=\"类型和语法\"><a href=\"#类型和语法\" class=\"headerlink\" title=\"类型和语法\"></a>类型和语法</h2><h3 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h3><p>javascript 有 7 中内置类型：</p>\n<ul>\n<li>空值 (null)</li>\n<li>未定义 (undefined)</li>\n<li>布尔值 (boolean)</li>\n<li>数字 (number)</li>\n<li>字符串 (string)</li>\n<li>对象 (object)</li>\n<li>符号 (symbol,ES6 中新增 )</li>\n</ul>\n<p><strong>除对象之外，其他同称为 “ 基本对象 ”</strong></p>\n<p>javascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c</span><br><span class=\"line\">b = c</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>undeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（阻止报错）来检查 undeclared 变量</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = []</span><br><span class=\"line\">a[<span class=\"number\">3</span>] = <span class=\"string\">'2'</span></span><br><span class=\"line\">a.length <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串经常被当成字符数组，但它们仅仅是看上去相似而已</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'fff'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length, b.length) <span class=\"comment\">//3,3</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>读 《你不知道的 JavaScript》 笔记</p>","more":"<h2 id=\"JS-数据类型\"><a href=\"#JS-数据类型\" class=\"headerlink\" title=\"JS 数据类型\"></a>JS 数据类型</h2><p>JS 数据类型分为基本数据类型和复杂数据类型</p>\n<p><strong>基本数据类型</strong></p>\n<p><code>Number</code>、<code>Boolean</code>、<code>String</code>、<code>Null</code>、<code>String</code>、<code>Symbol</code></p>\n<p><strong> 复杂数据类型</strong></p>\n<p>Object，其他引用类型（Array 、 Date、RegExp 、 Function、基本包装类型（Boolean 、 String、Number ）、Math 等）都是 Object 类型的实例对象</p>\n<h2 id=\"类型和语法\"><a href=\"#类型和语法\" class=\"headerlink\" title=\"类型和语法\"></a>类型和语法</h2><h3 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h3><p>javascript 有 7 中内置类型：</p>\n<ul>\n<li>空值 (null)</li>\n<li>未定义 (undefined)</li>\n<li>布尔值 (boolean)</li>\n<li>数字 (number)</li>\n<li>字符串 (string)</li>\n<li>对象 (object)</li>\n<li>符号 (symbol,ES6 中新增 )</li>\n</ul>\n<p><strong>除对象之外，其他同称为 “ 基本对象 ”</strong></p>\n<p>javascript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。变量在未持有值的时候为 undefined。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a</span><br><span class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"number\">42</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c</span><br><span class=\"line\">b = c</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> b <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">//undefined</span></span><br></pre></td></tr></table></figure>\n<p>undeclared 表示变量未被声明过，但是 javascript 却将 undefined 与 undeclared 混为一谈，我们试图访问 undeclared 变量时会报错 “is not defined”，并且 typeof 对 undefined 和 undeclared 变量都返回 “undefined”，所以可以通过使用 typeof 的安全机制（阻止报错）来检查 undeclared 变量</p>\n<h2 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = []</span><br><span class=\"line\">a[<span class=\"number\">3</span>] = <span class=\"string\">'2'</span></span><br><span class=\"line\">a.length <span class=\"comment\">//4</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>字符串经常被当成字符数组，但它们仅仅是看上去相似而已</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">'fff'</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = [<span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>, <span class=\"string\">'f'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a.length, b.length) <span class=\"comment\">//3,3</span></span><br></pre></td></tr></table></figure>"},{"title":"如何实现双向数据绑定 mvvm","_content":"\n目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input 、 textare 等）添加了 change(input) 事件，来动态修改 model 和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。\n\n<!--more-->\n\n实现数据双向绑定的集中做法大致如下：\n\n* 发布者 - 订阅者模式（backbone.js ）\n\n* 脏值检查（angular.js ）\n\n* 数据劫持（vue.js ）\n\n## 数据劫持 :\n\nvue.js 则是采用数据劫持结合发布者 - 订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter ，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n## 1 、实现 Observer\n\nok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it\n\n### 实现监听\n\n我们知道可以利用 Obeject.defineProperty() 来监听属性变动那么将需要 observe 的数据对象进行递归遍历，包括子属性的属性，都加上 set 和 get 这样的话，给这个对象的某个值赋值，就会触发 set，那么就能监听到了数据变化。。相关代码可以是这样：\n\n```javascript\nvar data = {name:'kindeng'};\nobserve(data);\ndata.name = 'dmq'; //监听到值得变化 kindeng -->dmq\nfunction observe(data){\n  if(!data||typeof data !== 'object){\n    //[]、{}\n    return;\n  }\n  object.key(data).forEach(function(key)){\n    defineReactive(data,key,data[key]);\n  }\n}\n\nfunction defineReactive(data,key,val){\n  observe(val);//监听子属性\n\n  //循环将data 中的每一个元素都绑定上数据劫持\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    //可枚举\n    configurable:false,\n    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化\n    get:function(){\n    return val;\n    },\n    set:function(){\n         console.log('值变');\n         val = newVal ;\n    }\n  })\n}\n```\n\n## 数据观测的实现\n\n### Angular\n\nAngular 的数据监测采用的是 “ 脏值检测 ”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做 watcher，一个作用域中可能有多个 watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有 watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做 digest cycle。脏值检测的劣势有两点：\n\n1. 任何数据变动都意味着当前作用域的每一个 watcher 需要被重新求值，且同一时间只允许一个 digest 运行，因此当 watcher 庞大时，应用性能就不可避免的收到影响，并且很难优化。\n2. 当数据变化时，框架并不能主动监测到变化的产生，需要手动触发 digest cycle 才能触发相应的 DOM 更新。Angular 通过在 DOM 事件处理函数中自动触发 digest cycle 部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。\n\n#### $watch 对象\n\nAngular 每一个绑定到 UI 的数据，就会有一 $watch 对象这个对象包含 3 个值\n\n```javascript\nwatch = {\n  name: '',\n  getNewValue: function($scope) {\n    //得到新值\n    return newValue\n  },\n  listener: function(newValue, oldValue) {\n    //当数据发生变化时\n  }\n}\n```\n\ngetNewValue() 可以得到当前 $scope 上的最新值，listener 函数得到新值和旧值并进行一些操作。\n\n每当我们将数据绑定到 UI 上，angular 就会想你的 watchList 上插入一个 $watch\n\n\\** 只有触发 UI 事件，ajax 请求或者 timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。\n\n### Vue\n\nvue 采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：\n\n1. 将原生的数据改造成 “ 可观察对象 ”。一个可观察对象可以被取值也可以被赋值。\n2. 在 watcher 的求值过程中，每一个被取值的可观察对象都都会将当前的 watcher 注册为自己的一个订阅者，并成为当前的 watcher 的一个依赖。\n3. 当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的 watcher 重新求值，并触发相应的更新。\n4. 依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如 Knockout, 通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。\n","source":"_posts/如何实现双向数据绑定-mvvm.md","raw":"---\ntitle: 如何实现双向数据绑定 mvvm\ncategories: vue\ntags:\n---\n\n目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input 、 textare 等）添加了 change(input) 事件，来动态修改 model 和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。\n\n<!--more-->\n\n实现数据双向绑定的集中做法大致如下：\n\n* 发布者 - 订阅者模式（backbone.js ）\n\n* 脏值检查（angular.js ）\n\n* 数据劫持（vue.js ）\n\n## 数据劫持 :\n\nvue.js 则是采用数据劫持结合发布者 - 订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter ，在数据变动时发布消息给订阅者，触发相应的监听回调。\n\n## 1 、实现 Observer\n\nok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it\n\n### 实现监听\n\n我们知道可以利用 Obeject.defineProperty() 来监听属性变动那么将需要 observe 的数据对象进行递归遍历，包括子属性的属性，都加上 set 和 get 这样的话，给这个对象的某个值赋值，就会触发 set，那么就能监听到了数据变化。。相关代码可以是这样：\n\n```javascript\nvar data = {name:'kindeng'};\nobserve(data);\ndata.name = 'dmq'; //监听到值得变化 kindeng -->dmq\nfunction observe(data){\n  if(!data||typeof data !== 'object){\n    //[]、{}\n    return;\n  }\n  object.key(data).forEach(function(key)){\n    defineReactive(data,key,data[key]);\n  }\n}\n\nfunction defineReactive(data,key,val){\n  observe(val);//监听子属性\n\n  //循环将data 中的每一个元素都绑定上数据劫持\n  Object.defineProperty(data,key,{\n    enumerable:true,\n    //可枚举\n    configurable:false,\n    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化\n    get:function(){\n    return val;\n    },\n    set:function(){\n         console.log('值变');\n         val = newVal ;\n    }\n  })\n}\n```\n\n## 数据观测的实现\n\n### Angular\n\nAngular 的数据监测采用的是 “ 脏值检测 ”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做 watcher，一个作用域中可能有多个 watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有 watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做 digest cycle。脏值检测的劣势有两点：\n\n1. 任何数据变动都意味着当前作用域的每一个 watcher 需要被重新求值，且同一时间只允许一个 digest 运行，因此当 watcher 庞大时，应用性能就不可避免的收到影响，并且很难优化。\n2. 当数据变化时，框架并不能主动监测到变化的产生，需要手动触发 digest cycle 才能触发相应的 DOM 更新。Angular 通过在 DOM 事件处理函数中自动触发 digest cycle 部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。\n\n#### $watch 对象\n\nAngular 每一个绑定到 UI 的数据，就会有一 $watch 对象这个对象包含 3 个值\n\n```javascript\nwatch = {\n  name: '',\n  getNewValue: function($scope) {\n    //得到新值\n    return newValue\n  },\n  listener: function(newValue, oldValue) {\n    //当数据发生变化时\n  }\n}\n```\n\ngetNewValue() 可以得到当前 $scope 上的最新值，listener 函数得到新值和旧值并进行一些操作。\n\n每当我们将数据绑定到 UI 上，angular 就会想你的 watchList 上插入一个 $watch\n\n\\** 只有触发 UI 事件，ajax 请求或者 timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。\n\n### Vue\n\nvue 采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：\n\n1. 将原生的数据改造成 “ 可观察对象 ”。一个可观察对象可以被取值也可以被赋值。\n2. 在 watcher 的求值过程中，每一个被取值的可观察对象都都会将当前的 watcher 注册为自己的一个订阅者，并成为当前的 watcher 的一个依赖。\n3. 当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的 watcher 重新求值，并触发相应的更新。\n4. 依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如 Knockout, 通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。\n","slug":"如何实现双向数据绑定-mvvm","published":1,"date":"2018-03-20T03:29:41.822Z","updated":"2018-03-20T03:29:41.822Z","_id":"cjepksjo400108gv6zz7ou9rl","comments":1,"layout":"post","photos":[],"link":"","content":"<p>目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input 、 textare 等）添加了 change(input) 事件，来动态修改 model 和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。</p>\n<a id=\"more\"></a>\n<p>实现数据双向绑定的集中做法大致如下：</p>\n<ul>\n<li><p>发布者 - 订阅者模式（backbone.js ）</p>\n</li>\n<li><p>脏值检查（angular.js ）</p>\n</li>\n<li><p>数据劫持（vue.js ）</p>\n</li>\n</ul>\n<h2 id=\"数据劫持\"><a href=\"#数据劫持\" class=\"headerlink\" title=\"数据劫持 :\"></a>数据劫持 :</h2><p>vue.js 则是采用数据劫持结合发布者 - 订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter ，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<h2 id=\"1-、实现-Observer\"><a href=\"#1-、实现-Observer\" class=\"headerlink\" title=\"1 、实现 Observer\"></a>1 、实现 Observer</h2><p>ok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it</p>\n<h3 id=\"实现监听\"><a href=\"#实现监听\" class=\"headerlink\" title=\"实现监听\"></a>实现监听</h3><p>我们知道可以利用 Obeject.defineProperty() 来监听属性变动那么将需要 observe 的数据对象进行递归遍历，包括子属性的属性，都加上 set 和 get 这样的话，给这个对象的某个值赋值，就会触发 set，那么就能监听到了数据变化。。相关代码可以是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'kindeng'</span>&#125;;</span><br><span class=\"line\">observe(data);</span><br><span class=\"line\">data.name = <span class=\"string\">'dmq'</span>; <span class=\"comment\">//监听到值得变化 kindeng --&gt;dmq</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!data||<span class=\"keyword\">typeof</span> data !== <span class=\"string\">'object)&#123;</span></span><br><span class=\"line\"><span class=\"string\">    //[]、&#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    return;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  object.key(data).forEach(function(key))&#123;</span></span><br><span class=\"line\"><span class=\"string\">    defineReactive(data,key,data[key]);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function defineReactive(data,key,val)&#123;</span></span><br><span class=\"line\"><span class=\"string\">  observe(val);//监听子属性</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  //循环将data 中的每一个元素都绑定上数据劫持</span></span><br><span class=\"line\"><span class=\"string\">  Object.defineProperty(data,key,&#123;</span></span><br><span class=\"line\"><span class=\"string\">    enumerable:true,</span></span><br><span class=\"line\"><span class=\"string\">    //可枚举</span></span><br><span class=\"line\"><span class=\"string\">    configurable:false,</span></span><br><span class=\"line\"><span class=\"string\">    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化</span></span><br><span class=\"line\"><span class=\"string\">    get:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">    return val;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    set:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">         console.log('</span>值变<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\">         val = newVal ;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数据观测的实现\"><a href=\"#数据观测的实现\" class=\"headerlink\" title=\"数据观测的实现\"></a>数据观测的实现</h2><h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 的数据监测采用的是 “ 脏值检测 ”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做 watcher，一个作用域中可能有多个 watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有 watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做 digest cycle。脏值检测的劣势有两点：</p>\n<ol>\n<li>任何数据变动都意味着当前作用域的每一个 watcher 需要被重新求值，且同一时间只允许一个 digest 运行，因此当 watcher 庞大时，应用性能就不可避免的收到影响，并且很难优化。</li>\n<li>当数据变化时，框架并不能主动监测到变化的产生，需要手动触发 digest cycle 才能触发相应的 DOM 更新。Angular 通过在 DOM 事件处理函数中自动触发 digest cycle 部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。</li>\n</ol>\n<h4 id=\"watch-对象\"><a href=\"#watch-对象\" class=\"headerlink\" title=\"$watch 对象\"></a>$watch 对象</h4><p>Angular 每一个绑定到 UI 的数据，就会有一 $watch 对象这个对象包含 3 个值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">''</span>,</span><br><span class=\"line\">  getNewValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newValue</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  listener: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue, oldValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当数据发生变化时</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getNewValue() 可以得到当前 $scope 上的最新值，listener 函数得到新值和旧值并进行一些操作。</p>\n<p>每当我们将数据绑定到 UI 上，angular 就会想你的 watchList 上插入一个 $watch</p>\n<p>** 只有触发 UI 事件，ajax 请求或者 timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。</p>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>vue 采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：</p>\n<ol>\n<li>将原生的数据改造成 “ 可观察对象 ”。一个可观察对象可以被取值也可以被赋值。</li>\n<li>在 watcher 的求值过程中，每一个被取值的可观察对象都都会将当前的 watcher 注册为自己的一个订阅者，并成为当前的 watcher 的一个依赖。</li>\n<li>当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的 watcher 重新求值，并触发相应的更新。</li>\n<li>依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如 Knockout, 通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>目前几种主流的 mvc(vm) 框架都实现了单向数据绑定，而我所理解的双向数据绑定无非就是在单向绑定的基础上给可输入元素（input 、 textare 等）添加了 change(input) 事件，来动态修改 model 和 view，并没有多高深。所以无需太过介怀是实现的单向或双向绑定。</p>","more":"<p>实现数据双向绑定的集中做法大致如下：</p>\n<ul>\n<li><p>发布者 - 订阅者模式（backbone.js ）</p>\n</li>\n<li><p>脏值检查（angular.js ）</p>\n</li>\n<li><p>数据劫持（vue.js ）</p>\n</li>\n</ul>\n<h2 id=\"数据劫持\"><a href=\"#数据劫持\" class=\"headerlink\" title=\"数据劫持 :\"></a>数据劫持 :</h2><p>vue.js 则是采用数据劫持结合发布者 - 订阅者模式的方式，通过 Object.defineProperty() 来劫持各个属性的 setter，getter ，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>\n<h2 id=\"1-、实现-Observer\"><a href=\"#1-、实现-Observer\" class=\"headerlink\" title=\"1 、实现 Observer\"></a>1 、实现 Observer</h2><p>ok, 思路已经整理完毕，也已经比较明确相关逻辑和模块功能了，let’s do it</p>\n<h3 id=\"实现监听\"><a href=\"#实现监听\" class=\"headerlink\" title=\"实现监听\"></a>实现监听</h3><p>我们知道可以利用 Obeject.defineProperty() 来监听属性变动那么将需要 observe 的数据对象进行递归遍历，包括子属性的属性，都加上 set 和 get 这样的话，给这个对象的某个值赋值，就会触发 set，那么就能监听到了数据变化。。相关代码可以是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;<span class=\"attr\">name</span>:<span class=\"string\">'kindeng'</span>&#125;;</span><br><span class=\"line\">observe(data);</span><br><span class=\"line\">data.name = <span class=\"string\">'dmq'</span>; <span class=\"comment\">//监听到值得变化 kindeng --&gt;dmq</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observe</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!data||<span class=\"keyword\">typeof</span> data !== <span class=\"string\">'object)&#123;</span></span><br><span class=\"line\"><span class=\"string\">    //[]、&#123;&#125;</span></span><br><span class=\"line\"><span class=\"string\">    return;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">  object.key(data).forEach(function(key))&#123;</span></span><br><span class=\"line\"><span class=\"string\">    defineReactive(data,key,data[key]);</span></span><br><span class=\"line\"><span class=\"string\">  &#125;</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">function defineReactive(data,key,val)&#123;</span></span><br><span class=\"line\"><span class=\"string\">  observe(val);//监听子属性</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">  //循环将data 中的每一个元素都绑定上数据劫持</span></span><br><span class=\"line\"><span class=\"string\">  Object.defineProperty(data,key,&#123;</span></span><br><span class=\"line\"><span class=\"string\">    enumerable:true,</span></span><br><span class=\"line\"><span class=\"string\">    //可枚举</span></span><br><span class=\"line\"><span class=\"string\">    configurable:false,</span></span><br><span class=\"line\"><span class=\"string\">    //如果为false，则任何尝试删除目标属性或修改属性以下特性（writable, configurable, enumerable）的行为将被无效化</span></span><br><span class=\"line\"><span class=\"string\">    get:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">    return val;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;,</span></span><br><span class=\"line\"><span class=\"string\">    set:function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">         console.log('</span>值变<span class=\"string\">');</span></span><br><span class=\"line\"><span class=\"string\">         val = newVal ;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br><span class=\"line\"><span class=\"string\">  &#125;)</span></span><br><span class=\"line\"><span class=\"string\">&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"数据观测的实现\"><a href=\"#数据观测的实现\" class=\"headerlink\" title=\"数据观测的实现\"></a>数据观测的实现</h2><h3 id=\"Angular\"><a href=\"#Angular\" class=\"headerlink\" title=\"Angular\"></a>Angular</h3><p>Angular 的数据监测采用的是 “ 脏值检测 ”，每一个指令都会有一个对应的的用来观察到对象的变化，这个应用叫做叫做 watcher，一个作用域中可能有多个 watcher，当数据发生改变，页面更新，Angular 会遍历当前页面中的所有 watcher，对他们一一求值，与之前的值进行对比，如果求值的结果变化了，就会触发对应的更新，这个过程叫做 digest cycle。脏值检测的劣势有两点：</p>\n<ol>\n<li>任何数据变动都意味着当前作用域的每一个 watcher 需要被重新求值，且同一时间只允许一个 digest 运行，因此当 watcher 庞大时，应用性能就不可避免的收到影响，并且很难优化。</li>\n<li>当数据变化时，框架并不能主动监测到变化的产生，需要手动触发 digest cycle 才能触发相应的 DOM 更新。Angular 通过在 DOM 事件处理函数中自动触发 digest cycle 部分避免了这个问题，但还是有很多情况下需要用户手动进行触发。</li>\n</ol>\n<h4 id=\"watch-对象\"><a href=\"#watch-对象\" class=\"headerlink\" title=\"$watch 对象\"></a>$watch 对象</h4><p>Angular 每一个绑定到 UI 的数据，就会有一 $watch 对象这个对象包含 3 个值</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">watch = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">''</span>,</span><br><span class=\"line\">  getNewValue: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">$scope</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//得到新值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> newValue</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  listener: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newValue, oldValue</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//当数据发生变化时</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>getNewValue() 可以得到当前 $scope 上的最新值，listener 函数得到新值和旧值并进行一些操作。</p>\n<p>每当我们将数据绑定到 UI 上，angular 就会想你的 watchList 上插入一个 $watch</p>\n<p>** 只有触发 UI 事件，ajax 请求或者 timeout 等回调操作，而数据到界面的呈现则是由脏检查来做。</p>\n<h3 id=\"Vue\"><a href=\"#Vue\" class=\"headerlink\" title=\"Vue\"></a>Vue</h3><p>vue 采用的则是基于依赖收集的观测机制，也就是数据劫持，它的基本原理是：</p>\n<ol>\n<li>将原生的数据改造成 “ 可观察对象 ”。一个可观察对象可以被取值也可以被赋值。</li>\n<li>在 watcher 的求值过程中，每一个被取值的可观察对象都都会将当前的 watcher 注册为自己的一个订阅者，并成为当前的 watcher 的一个依赖。</li>\n<li>当一个被依赖的可观察对象被赋值时，它会通知所有订阅自己的 watcher 重新求值，并触发相应的更新。</li>\n<li>依赖收集的有点在于可以精准、主动地追踪数据的变化，不存在上述提到的脏检查的两个问题。但传统的依赖收集实现，比如 Knockout, 通常需要包裹原生数据来制造可观察对象，在取值和赋值时需要采用函数的调用形式，在进行数据操作时写法繁琐，不够直观，对复杂嵌套结构的对象支持也不理想。</li>\n</ol>"},{"title":"字符串操作方法","date":"2018-01-15T10:02:34.000Z","_content":"\n字符串常见操作方法总结\n\n<!--more-->","source":"_posts/字符串操作方法.md","raw":"---\ntitle: 字符串操作方法\ndate: 2018-01-15 18:02:34\ncategories: 原生JS\n---\n\n字符串常见操作方法总结\n\n<!--more-->","slug":"字符串操作方法","published":1,"updated":"2018-03-20T03:29:41.822Z","_id":"cjepksjo600118gv6cvxfw3y5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>字符串常见操作方法总结</p>\n<a id=\"more\"></a>","site":{"data":{}},"excerpt":"<p>字符串常见操作方法总结</p>","more":""},{"title":"尤玉溪-Live","date":"2018-03-07T11:22:24.000Z","_content":"\n分析现代前端框架涉及的各个问题领域，各领域目前的主流解决方案，以及未来可能的趋势。\n\n<!--more-->\n\n## 组件的理解和分类\n\n一个应用是一个大函数，一个函数可以调用其他函数，一个组件是一个函数。在 react 中一个组件可以是一个函数，它可以返回一个抽象的数据结构。在实际的应用中，组件是有分类的:\n\n1. 纯展示型组件：数据进 dom 出 。\n2. 接入型组件：container component，它会跟数据层的 serves 打交道 ，它会去包含一些跟服务器端或者是数据源打交道的逻辑。container 会将数据传给展示型组件。\n3. 交互型组件：比如各类加强版的表单组件，通常强调复用。element UI 以及各种 react 各类组件。\n4. 功能型组件： 比如`<router-view>`,`<transition>`,作为一种扩展，抽象机制存在。\n\n## 变化侦测和\n\n### 渲染机制\n\n最重要的是“声明”。\n** view = render(state)** 输入是 state 输出是 view。具体的实现可以是 Virtual DOM 和细密度的绑定他们本质是一样的，他们的区别只在于不同场景的更新效率不一样。\n\n### 变化侦测\n\n属性值变化则更改视图\n\nhtml 中的内联 JS `onclick = clickHandler` 的写法中 clickHandler 的作用域的问题是全局的，在 vue 里面可以这样写的原因是因为我们的在组件里面 JS 的逻辑跟模板或者是 jsx 是一起的。\n\n变化侦测 主要分为 push 、pull 两种：\n\n* push\n  vue 的响应式数据和 RX 的 observable 的数据机制使得我们立刻能知道是什么数据改变，就可以实现细腻度的更新。力度太细，那么每一个绑定都会有一个 observable 或者一个 watcher,就会带来一个内存的开销和依赖追踪的开销。所以在 vue2 里面是在组件级别是一个 push，每一个组件是一个响应式的 watcher，在每个组件内部是一个 Virtual DOM。\n* pull:\n  react 的 subsate 和 angular1 和 2 的脏检查，是属于 pull。是由于不知道什么数据改变了所以需要暴力的遍历比对来查出到底是什么改变了。\n\n## 状态和数据流管理\n\n### 状态管理\n\nvueX 受 reduX 影响。状态管理的本质是相通的。状态管理的本质是从源事件映射到状态的迁移然后再映射到 UI 的变化。所以状态管理这些库就是如何管理将事件源映射到状态变化的这样一个过程，如何将这个映射的过程从视图组件中玻璃出来，提高可维护性，是状态管理需要解决的问题。\n\n* redux 强调的是数据不可变。\n* 在 vue 里面数据是可变的，数据是响应式的。\n\n如果是有服务端推送、实时、多个同时发布的话，就可以使用 RX.js 来解决异步请求的问题。\n\n共同的问题 1：是组件的全局状态和局部状态如何区分。一些要共用的状态就提升到全局进行管理:2：全局状态和服务端的数据之间。现在通用的是将服务端的数据抓到全局的 store 里面。\n\n### RX.js\n\n跳过显示状态的改变的过程。直接从事件源映射到结果。一切都有 RX.js 的流来表示。\n\n### 路由\n\n由 url 路径映射到组件。路由的存在的问题：hash 模式 和 history 模式如何兼容如何 forback。\n\n#### web 路由与 app 路由的区别。\n\nweb 与 app 的浏览方式是有区别的。\n\n## CSS 管理方案\n\n1. 与 JS 完全解耦，使用预处理器，BEM 这样的编码规范保持可维护性,偏传统。\n2. css Modules ， 依然是 css,但是通过编译来避免 CSS 类名的全局冲突。将一个 CSS 文件里面的类名随机化。\n3. 各类 css-in-JS 方案，react 社区为代表，比较激进。\n4. Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面）\n\n传统 css 的问题：\n\n1. 作用域\n2. Critical CSS (首屏 CSS)，如果 css 没有在 HTML 之前加载的话就会出现问题。要能侦测到首页所需要的 CSS。（css-in-JS）或者在 vue2.3 里面，在编译过程将 css 的插入和组件的生命周期挂钩。\n3. Atomic CSS，整个 css 可以变的更小，css-in-JS 自带 css 优化。\n4. 分发复用\n5. 跨平台复用\n\n## 构建工具链\n\n## 同构/服务端渲染\n\n## 跨平台渲染\n\n## 类型系统\n\n## 构建时优化\n\n## 运行时优化\n\n## Web Components 和框架的关系\n\n## Web Assembly 和框架的关系\n","source":"_posts/尤玉溪-Live.md","raw":"---\ntitle: 尤玉溪-Live\ndate: 2018-03-07 19:22:24\ntags:\n---\n\n分析现代前端框架涉及的各个问题领域，各领域目前的主流解决方案，以及未来可能的趋势。\n\n<!--more-->\n\n## 组件的理解和分类\n\n一个应用是一个大函数，一个函数可以调用其他函数，一个组件是一个函数。在 react 中一个组件可以是一个函数，它可以返回一个抽象的数据结构。在实际的应用中，组件是有分类的:\n\n1. 纯展示型组件：数据进 dom 出 。\n2. 接入型组件：container component，它会跟数据层的 serves 打交道 ，它会去包含一些跟服务器端或者是数据源打交道的逻辑。container 会将数据传给展示型组件。\n3. 交互型组件：比如各类加强版的表单组件，通常强调复用。element UI 以及各种 react 各类组件。\n4. 功能型组件： 比如`<router-view>`,`<transition>`,作为一种扩展，抽象机制存在。\n\n## 变化侦测和\n\n### 渲染机制\n\n最重要的是“声明”。\n** view = render(state)** 输入是 state 输出是 view。具体的实现可以是 Virtual DOM 和细密度的绑定他们本质是一样的，他们的区别只在于不同场景的更新效率不一样。\n\n### 变化侦测\n\n属性值变化则更改视图\n\nhtml 中的内联 JS `onclick = clickHandler` 的写法中 clickHandler 的作用域的问题是全局的，在 vue 里面可以这样写的原因是因为我们的在组件里面 JS 的逻辑跟模板或者是 jsx 是一起的。\n\n变化侦测 主要分为 push 、pull 两种：\n\n* push\n  vue 的响应式数据和 RX 的 observable 的数据机制使得我们立刻能知道是什么数据改变，就可以实现细腻度的更新。力度太细，那么每一个绑定都会有一个 observable 或者一个 watcher,就会带来一个内存的开销和依赖追踪的开销。所以在 vue2 里面是在组件级别是一个 push，每一个组件是一个响应式的 watcher，在每个组件内部是一个 Virtual DOM。\n* pull:\n  react 的 subsate 和 angular1 和 2 的脏检查，是属于 pull。是由于不知道什么数据改变了所以需要暴力的遍历比对来查出到底是什么改变了。\n\n## 状态和数据流管理\n\n### 状态管理\n\nvueX 受 reduX 影响。状态管理的本质是相通的。状态管理的本质是从源事件映射到状态的迁移然后再映射到 UI 的变化。所以状态管理这些库就是如何管理将事件源映射到状态变化的这样一个过程，如何将这个映射的过程从视图组件中玻璃出来，提高可维护性，是状态管理需要解决的问题。\n\n* redux 强调的是数据不可变。\n* 在 vue 里面数据是可变的，数据是响应式的。\n\n如果是有服务端推送、实时、多个同时发布的话，就可以使用 RX.js 来解决异步请求的问题。\n\n共同的问题 1：是组件的全局状态和局部状态如何区分。一些要共用的状态就提升到全局进行管理:2：全局状态和服务端的数据之间。现在通用的是将服务端的数据抓到全局的 store 里面。\n\n### RX.js\n\n跳过显示状态的改变的过程。直接从事件源映射到结果。一切都有 RX.js 的流来表示。\n\n### 路由\n\n由 url 路径映射到组件。路由的存在的问题：hash 模式 和 history 模式如何兼容如何 forback。\n\n#### web 路由与 app 路由的区别。\n\nweb 与 app 的浏览方式是有区别的。\n\n## CSS 管理方案\n\n1. 与 JS 完全解耦，使用预处理器，BEM 这样的编码规范保持可维护性,偏传统。\n2. css Modules ， 依然是 css,但是通过编译来避免 CSS 类名的全局冲突。将一个 CSS 文件里面的类名随机化。\n3. 各类 css-in-JS 方案，react 社区为代表，比较激进。\n4. Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面）\n\n传统 css 的问题：\n\n1. 作用域\n2. Critical CSS (首屏 CSS)，如果 css 没有在 HTML 之前加载的话就会出现问题。要能侦测到首页所需要的 CSS。（css-in-JS）或者在 vue2.3 里面，在编译过程将 css 的插入和组件的生命周期挂钩。\n3. Atomic CSS，整个 css 可以变的更小，css-in-JS 自带 css 优化。\n4. 分发复用\n5. 跨平台复用\n\n## 构建工具链\n\n## 同构/服务端渲染\n\n## 跨平台渲染\n\n## 类型系统\n\n## 构建时优化\n\n## 运行时优化\n\n## Web Components 和框架的关系\n\n## Web Assembly 和框架的关系\n","slug":"尤玉溪-Live","published":1,"updated":"2018-03-20T03:29:41.823Z","_id":"cjepksjo800148gv6ocoifnmj","comments":1,"layout":"post","photos":[],"link":"","content":"<p>分析现代前端框架涉及的各个问题领域，各领域目前的主流解决方案，以及未来可能的趋势。</p>\n<a id=\"more\"></a>\n<h2 id=\"组件的理解和分类\"><a href=\"#组件的理解和分类\" class=\"headerlink\" title=\"组件的理解和分类\"></a>组件的理解和分类</h2><p>一个应用是一个大函数，一个函数可以调用其他函数，一个组件是一个函数。在 react 中一个组件可以是一个函数，它可以返回一个抽象的数据结构。在实际的应用中，组件是有分类的:</p>\n<ol>\n<li>纯展示型组件：数据进 dom 出 。</li>\n<li>接入型组件：container component，它会跟数据层的 serves 打交道 ，它会去包含一些跟服务器端或者是数据源打交道的逻辑。container 会将数据传给展示型组件。</li>\n<li>交互型组件：比如各类加强版的表单组件，通常强调复用。element UI 以及各种 react 各类组件。</li>\n<li>功能型组件： 比如<code>&lt;router-view&gt;</code>,<code>&lt;transition&gt;</code>,作为一种扩展，抽象机制存在。</li>\n</ol>\n<h2 id=\"变化侦测和\"><a href=\"#变化侦测和\" class=\"headerlink\" title=\"变化侦测和\"></a>变化侦测和</h2><h3 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h3><p>最重要的是“声明”。<br><strong> view = render(state)</strong> 输入是 state 输出是 view。具体的实现可以是 Virtual DOM 和细密度的绑定他们本质是一样的，他们的区别只在于不同场景的更新效率不一样。</p>\n<h3 id=\"变化侦测\"><a href=\"#变化侦测\" class=\"headerlink\" title=\"变化侦测\"></a>变化侦测</h3><p>属性值变化则更改视图</p>\n<p>html 中的内联 JS <code>onclick = clickHandler</code> 的写法中 clickHandler 的作用域的问题是全局的，在 vue 里面可以这样写的原因是因为我们的在组件里面 JS 的逻辑跟模板或者是 jsx 是一起的。</p>\n<p>变化侦测 主要分为 push 、pull 两种：</p>\n<ul>\n<li>push<br>vue 的响应式数据和 RX 的 observable 的数据机制使得我们立刻能知道是什么数据改变，就可以实现细腻度的更新。力度太细，那么每一个绑定都会有一个 observable 或者一个 watcher,就会带来一个内存的开销和依赖追踪的开销。所以在 vue2 里面是在组件级别是一个 push，每一个组件是一个响应式的 watcher，在每个组件内部是一个 Virtual DOM。</li>\n<li>pull:<br>react 的 subsate 和 angular1 和 2 的脏检查，是属于 pull。是由于不知道什么数据改变了所以需要暴力的遍历比对来查出到底是什么改变了。</li>\n</ul>\n<h2 id=\"状态和数据流管理\"><a href=\"#状态和数据流管理\" class=\"headerlink\" title=\"状态和数据流管理\"></a>状态和数据流管理</h2><h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>vueX 受 reduX 影响。状态管理的本质是相通的。状态管理的本质是从源事件映射到状态的迁移然后再映射到 UI 的变化。所以状态管理这些库就是如何管理将事件源映射到状态变化的这样一个过程，如何将这个映射的过程从视图组件中玻璃出来，提高可维护性，是状态管理需要解决的问题。</p>\n<ul>\n<li>redux 强调的是数据不可变。</li>\n<li>在 vue 里面数据是可变的，数据是响应式的。</li>\n</ul>\n<p>如果是有服务端推送、实时、多个同时发布的话，就可以使用 RX.js 来解决异步请求的问题。</p>\n<p>共同的问题 1：是组件的全局状态和局部状态如何区分。一些要共用的状态就提升到全局进行管理:2：全局状态和服务端的数据之间。现在通用的是将服务端的数据抓到全局的 store 里面。</p>\n<h3 id=\"RX-js\"><a href=\"#RX-js\" class=\"headerlink\" title=\"RX.js\"></a>RX.js</h3><p>跳过显示状态的改变的过程。直接从事件源映射到结果。一切都有 RX.js 的流来表示。</p>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>由 url 路径映射到组件。路由的存在的问题：hash 模式 和 history 模式如何兼容如何 forback。</p>\n<h4 id=\"web-路由与-app-路由的区别。\"><a href=\"#web-路由与-app-路由的区别。\" class=\"headerlink\" title=\"web 路由与 app 路由的区别。\"></a>web 路由与 app 路由的区别。</h4><p>web 与 app 的浏览方式是有区别的。</p>\n<h2 id=\"CSS-管理方案\"><a href=\"#CSS-管理方案\" class=\"headerlink\" title=\"CSS 管理方案\"></a>CSS 管理方案</h2><ol>\n<li>与 JS 完全解耦，使用预处理器，BEM 这样的编码规范保持可维护性,偏传统。</li>\n<li>css Modules ， 依然是 css,但是通过编译来避免 CSS 类名的全局冲突。将一个 CSS 文件里面的类名随机化。</li>\n<li>各类 css-in-JS 方案，react 社区为代表，比较激进。</li>\n<li>Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面）</li>\n</ol>\n<p>传统 css 的问题：</p>\n<ol>\n<li>作用域</li>\n<li>Critical CSS (首屏 CSS)，如果 css 没有在 HTML 之前加载的话就会出现问题。要能侦测到首页所需要的 CSS。（css-in-JS）或者在 vue2.3 里面，在编译过程将 css 的插入和组件的生命周期挂钩。</li>\n<li>Atomic CSS，整个 css 可以变的更小，css-in-JS 自带 css 优化。</li>\n<li>分发复用</li>\n<li>跨平台复用</li>\n</ol>\n<h2 id=\"构建工具链\"><a href=\"#构建工具链\" class=\"headerlink\" title=\"构建工具链\"></a>构建工具链</h2><h2 id=\"同构-服务端渲染\"><a href=\"#同构-服务端渲染\" class=\"headerlink\" title=\"同构/服务端渲染\"></a>同构/服务端渲染</h2><h2 id=\"跨平台渲染\"><a href=\"#跨平台渲染\" class=\"headerlink\" title=\"跨平台渲染\"></a>跨平台渲染</h2><h2 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h2><h2 id=\"构建时优化\"><a href=\"#构建时优化\" class=\"headerlink\" title=\"构建时优化\"></a>构建时优化</h2><h2 id=\"运行时优化\"><a href=\"#运行时优化\" class=\"headerlink\" title=\"运行时优化\"></a>运行时优化</h2><h2 id=\"Web-Components-和框架的关系\"><a href=\"#Web-Components-和框架的关系\" class=\"headerlink\" title=\"Web Components 和框架的关系\"></a>Web Components 和框架的关系</h2><h2 id=\"Web-Assembly-和框架的关系\"><a href=\"#Web-Assembly-和框架的关系\" class=\"headerlink\" title=\"Web Assembly 和框架的关系\"></a>Web Assembly 和框架的关系</h2>","site":{"data":{}},"excerpt":"<p>分析现代前端框架涉及的各个问题领域，各领域目前的主流解决方案，以及未来可能的趋势。</p>","more":"<h2 id=\"组件的理解和分类\"><a href=\"#组件的理解和分类\" class=\"headerlink\" title=\"组件的理解和分类\"></a>组件的理解和分类</h2><p>一个应用是一个大函数，一个函数可以调用其他函数，一个组件是一个函数。在 react 中一个组件可以是一个函数，它可以返回一个抽象的数据结构。在实际的应用中，组件是有分类的:</p>\n<ol>\n<li>纯展示型组件：数据进 dom 出 。</li>\n<li>接入型组件：container component，它会跟数据层的 serves 打交道 ，它会去包含一些跟服务器端或者是数据源打交道的逻辑。container 会将数据传给展示型组件。</li>\n<li>交互型组件：比如各类加强版的表单组件，通常强调复用。element UI 以及各种 react 各类组件。</li>\n<li>功能型组件： 比如<code>&lt;router-view&gt;</code>,<code>&lt;transition&gt;</code>,作为一种扩展，抽象机制存在。</li>\n</ol>\n<h2 id=\"变化侦测和\"><a href=\"#变化侦测和\" class=\"headerlink\" title=\"变化侦测和\"></a>变化侦测和</h2><h3 id=\"渲染机制\"><a href=\"#渲染机制\" class=\"headerlink\" title=\"渲染机制\"></a>渲染机制</h3><p>最重要的是“声明”。<br><strong> view = render(state)</strong> 输入是 state 输出是 view。具体的实现可以是 Virtual DOM 和细密度的绑定他们本质是一样的，他们的区别只在于不同场景的更新效率不一样。</p>\n<h3 id=\"变化侦测\"><a href=\"#变化侦测\" class=\"headerlink\" title=\"变化侦测\"></a>变化侦测</h3><p>属性值变化则更改视图</p>\n<p>html 中的内联 JS <code>onclick = clickHandler</code> 的写法中 clickHandler 的作用域的问题是全局的，在 vue 里面可以这样写的原因是因为我们的在组件里面 JS 的逻辑跟模板或者是 jsx 是一起的。</p>\n<p>变化侦测 主要分为 push 、pull 两种：</p>\n<ul>\n<li>push<br>vue 的响应式数据和 RX 的 observable 的数据机制使得我们立刻能知道是什么数据改变，就可以实现细腻度的更新。力度太细，那么每一个绑定都会有一个 observable 或者一个 watcher,就会带来一个内存的开销和依赖追踪的开销。所以在 vue2 里面是在组件级别是一个 push，每一个组件是一个响应式的 watcher，在每个组件内部是一个 Virtual DOM。</li>\n<li>pull:<br>react 的 subsate 和 angular1 和 2 的脏检查，是属于 pull。是由于不知道什么数据改变了所以需要暴力的遍历比对来查出到底是什么改变了。</li>\n</ul>\n<h2 id=\"状态和数据流管理\"><a href=\"#状态和数据流管理\" class=\"headerlink\" title=\"状态和数据流管理\"></a>状态和数据流管理</h2><h3 id=\"状态管理\"><a href=\"#状态管理\" class=\"headerlink\" title=\"状态管理\"></a>状态管理</h3><p>vueX 受 reduX 影响。状态管理的本质是相通的。状态管理的本质是从源事件映射到状态的迁移然后再映射到 UI 的变化。所以状态管理这些库就是如何管理将事件源映射到状态变化的这样一个过程，如何将这个映射的过程从视图组件中玻璃出来，提高可维护性，是状态管理需要解决的问题。</p>\n<ul>\n<li>redux 强调的是数据不可变。</li>\n<li>在 vue 里面数据是可变的，数据是响应式的。</li>\n</ul>\n<p>如果是有服务端推送、实时、多个同时发布的话，就可以使用 RX.js 来解决异步请求的问题。</p>\n<p>共同的问题 1：是组件的全局状态和局部状态如何区分。一些要共用的状态就提升到全局进行管理:2：全局状态和服务端的数据之间。现在通用的是将服务端的数据抓到全局的 store 里面。</p>\n<h3 id=\"RX-js\"><a href=\"#RX-js\" class=\"headerlink\" title=\"RX.js\"></a>RX.js</h3><p>跳过显示状态的改变的过程。直接从事件源映射到结果。一切都有 RX.js 的流来表示。</p>\n<h3 id=\"路由\"><a href=\"#路由\" class=\"headerlink\" title=\"路由\"></a>路由</h3><p>由 url 路径映射到组件。路由的存在的问题：hash 模式 和 history 模式如何兼容如何 forback。</p>\n<h4 id=\"web-路由与-app-路由的区别。\"><a href=\"#web-路由与-app-路由的区别。\" class=\"headerlink\" title=\"web 路由与 app 路由的区别。\"></a>web 路由与 app 路由的区别。</h4><p>web 与 app 的浏览方式是有区别的。</p>\n<h2 id=\"CSS-管理方案\"><a href=\"#CSS-管理方案\" class=\"headerlink\" title=\"CSS 管理方案\"></a>CSS 管理方案</h2><ol>\n<li>与 JS 完全解耦，使用预处理器，BEM 这样的编码规范保持可维护性,偏传统。</li>\n<li>css Modules ， 依然是 css,但是通过编译来避免 CSS 类名的全局冲突。将一个 CSS 文件里面的类名随机化。</li>\n<li>各类 css-in-JS 方案，react 社区为代表，比较激进。</li>\n<li>Vue 的单文件组件 CSS，或是 Angular 的组件 CSS（写在装饰器里面）</li>\n</ol>\n<p>传统 css 的问题：</p>\n<ol>\n<li>作用域</li>\n<li>Critical CSS (首屏 CSS)，如果 css 没有在 HTML 之前加载的话就会出现问题。要能侦测到首页所需要的 CSS。（css-in-JS）或者在 vue2.3 里面，在编译过程将 css 的插入和组件的生命周期挂钩。</li>\n<li>Atomic CSS，整个 css 可以变的更小，css-in-JS 自带 css 优化。</li>\n<li>分发复用</li>\n<li>跨平台复用</li>\n</ol>\n<h2 id=\"构建工具链\"><a href=\"#构建工具链\" class=\"headerlink\" title=\"构建工具链\"></a>构建工具链</h2><h2 id=\"同构-服务端渲染\"><a href=\"#同构-服务端渲染\" class=\"headerlink\" title=\"同构/服务端渲染\"></a>同构/服务端渲染</h2><h2 id=\"跨平台渲染\"><a href=\"#跨平台渲染\" class=\"headerlink\" title=\"跨平台渲染\"></a>跨平台渲染</h2><h2 id=\"类型系统\"><a href=\"#类型系统\" class=\"headerlink\" title=\"类型系统\"></a>类型系统</h2><h2 id=\"构建时优化\"><a href=\"#构建时优化\" class=\"headerlink\" title=\"构建时优化\"></a>构建时优化</h2><h2 id=\"运行时优化\"><a href=\"#运行时优化\" class=\"headerlink\" title=\"运行时优化\"></a>运行时优化</h2><h2 id=\"Web-Components-和框架的关系\"><a href=\"#Web-Components-和框架的关系\" class=\"headerlink\" title=\"Web Components 和框架的关系\"></a>Web Components 和框架的关系</h2><h2 id=\"Web-Assembly-和框架的关系\"><a href=\"#Web-Assembly-和框架的关系\" class=\"headerlink\" title=\"Web Assembly 和框架的关系\"></a>Web Assembly 和框架的关系</h2>"},{"title":"数组操作方法","comments":1,"_content":"\n## 数组原形方法有以下几种 :\n\n`join()`,`push()`,`pop()`,`sort()`,`reverse()`,`concat()`,`slice()`,`splice()`,`indexOf()`,`lastIndexOf()`,`forEach()`,`map()`, `filter()`,`every()`,`some()`,`reduce()`,`reduceRigh()`\n\n<!--more-->\n\n## 1.join()，不改变原数组。\n\njoin(separator): 将数组的元素组成一个字符串，以 separator 为分隔符，省略则默认为逗号，该方法只接受一个参数。\n\n```javascript\nvar arr = [1, 2, 3]\nconsole.log(arr.join()) // 1,2,3\nconsole.log(arr.join('-')) // 1-2-3\nconsole.log(arr) // [1, 2, 3]（原数组不变）\n```\n\n## 2.push() 与 pop()，改变元素组\n\n* push(): 可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，**并返回修改后数组的长度**。\n* pop(): 数组末尾移除最后一项，减少数组的 length 的值，然后返回移除的项。\n\n```javascript\nvar arr = ['Lily', 'lucy', 'Tom']\nvar count = arr.push('Jack', 'Sean')\nconsole.log(count) // 5\nconsole.log(arr) // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop()\nconsole.log(item) // Sean\nconsole.log(arr) // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n\n## 3.shift() 和 unshift()，改变原数组\n\n* shift(): 删除原数组的第一项，并返回删除元素的值，如果为空则返回 undefined。\n* unshift(): 将参数添加到原数组开头，**并返回数组的长度**。\n\n```javascript\nvar arr = ['Lily', 'lucy', 'Tom']\nvar count = arr.unshift('Jack', 'Sean')\nconsole.log(count) // 5\nconsole.log(arr) //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift()\nconsole.log(item) // Jack\nconsole.log(arr) // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n\n## 4.sort(), 改变原数组\n\n按升序列排序数组系那个（从小到大），在排序时，sort() 方法会调用每个数组的 toString() 转型方法，**然后比较得到的字符串**，已确定如何排序。即使数组中每一个都是数值 ,sort() 方法比较的意识字符串，因此会出现以下情况：\n\n```javascript\nvar arr1 = ['a', 'd', 'c', 'b']\nconsole.log(arr1.sort()) // [\"a\", \"b\", \"c\", \"d\"]\narr2 = [13, 24, 51, 3]\nconsole.log(arr2.sort()) // [13, 24, 3, 51]\nconsole.log(arr2) // [13, 24, 3, 51](元数组被改变)\nvar scores = [1, 10, 21, 2]\nscores.sort() // [1, 10, 2, 21] 注意10在2之前  因为在 Unicode 指针顺序中\"10\"在\"2\"之前\n```\n\n为了解决上述问题，sort() 方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：\n\n```javascript\nfunction compare(value1, value2) {\n  if (value1 < value2) {\n    return -1\n  } else if (value1 > value2) {\n    return 1\n  } else {\n    return 0\n  }\n}\narr2 = [13, 24, 51, 3]\nconsole.log(arr2.sort(compare)) // [3, 13, 24, 51]\n```\n\n如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。\n\n## 5.reverse() ，改变原数组\n\nreverse(): 反转数组项的顺序\n\n```javascript\nreverse()：反转数组项的顺序。\n?\n1\n2\n3\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); //[3, 51, 24, 13]\nconsole.log(arr); //[3, 51, 24, 13](原数组改变)\n```\n\n## 6.concat()，不改变原数组\n\nconcat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，**在没有给 concat() 方法传递一个参数的情况下，它只是复制当前数组并返回副本。**\n\n```javascript\nvar arr = [1, 3, 5, 7]\nvar arrCopy = arr.concat(9, [11, 13])\nconsole.log(arrCopy) //[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr) // [1, 3, 5, 7](原数组未被修改)\n```\n\n上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，**如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？**\n\n```javascript\nvar arrCopy2 = arr.concat([9, [11, 13]])\nconsole.log(arrCopy2) //[1, 3, 5, 7, 9, Array[2]]\nconsole.log(arrCopy2[5]) //[11, 13]\n```\n\n## 7.slice() 不改变原数组\n\nslice(): 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice() 方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice() 方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项 - 但不包括结束位置的项。\n\n```javascript\nvar arr = [1, 3, 5, 7, 9, 11]\nvar arrCopy = arr.slice(1)\nvar arrCopy2 = arr.slice(1, 4)\nvar arrCopy3 = arr.slice(1, -2)\nvar arrCopy4 = arr.slice(-4, -1)\nconsole.log(arr) //[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy) //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2) //[3, 5, 7]\nconsole.log(arrCopy3) //[3, 5, 7]\nconsole.log(arrCopy4) //[5, 7, 9]\n```\n\n## 8.splice() 可以实现删除、插入和替换 改变原数组\n\n* 删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2) 会删除数组中的前两项。\n* 插入：可以向指定位置插入任意数量的项，需要 3 个参数，起始位置、0 （要删除的项数）和要插入的项，例如 splice(2,0,4,6) 会在当前数组的位置 2 开始插入 4 和 6\n* 替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要 3 个参数，只需要指定 3 个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如 splice(2,1,4,6) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。\n\n```javascript\nvar arr = [1, 3, 5, 7, 9, 11]\nvar arrRemoved = arr.splice(0, 2)\nconsole.log(arr) //[5, 7, 9, 11]\nconsole.log(arrRemoved) //[1, 3]\nvar arrRemoved2 = arr.splice(2, 0, 4, 6)\nconsole.log(arr) // [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2) // []\nvar arrRemoved3 = arr.splice(1, 1, 2, 4)\nconsole.log(arr) // [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3) //[7]\n```\n\n## 9.indexOf() 和 lastIndexOf()\n\n* indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。\n* lastIndexOf() ：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找\n\n```javascript\nvar arr = [1, 3, 5, 7, 7, 5, 3, 1]\nconsole.log(arr.indexOf(5)) //2\nconsole.log(arr.lastIndexOf(5)) //5\nconsole.log(arr.indexOf(5, 2)) //2\nconsole.log(arr.lastIndexOf(5, 4)) //2\nconsole.log(arr.indexOf('5')) //-1\n```\n\n## 10.forEach() 遍历\n\n对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是 function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\narr.forEach(function(x, index, a) {\n  console.log(x + '|' + index + '|' + (a === arr))\n})\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n```\n\n## 11.map()\n\nmap() ：指 “ 映射 ”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\nvar arr2 = arr.map(function(item) {\n  return item * item\n})\nconsole.log(arr2) //[1, 4, 9, 16, 25]\n```\n\n## 12.filter()\n\nfilter(): “ 过滤功能 ”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n\n```javasript\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\nreturn index % 3 === 0 || x >= 8;\n});\nconsole.log(arr2); //[1, 4, 7, 8, 9, 10]\n```\n\n## 13.every()\n\nevery() ，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回 true。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\nvar arr2 = arr.every(function(x) {\n  return x < 10\n})\nconsole.log(arr2) //true\nvar arr3 = arr.every(function(x) {\n  return x < 3\n})\nconsole.log(arr3) // false\n```\n\n## 14.some()\n\nsome() ：判断数组中是否存在满足条件的项，只要有一项满足，就会返回 true。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\nvar arr2 = arr.some(function(x) {\n  return x < 3\n})\nconsole.log(arr2) //true\nvar arr3 = arr.some(function(x) {\n  return x < 1\n})\nconsole.log(arr3) // false\n```\n\n## 15.reduce() 和 reduceRight()\n\n这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce() 方法从数组的第一项开始，逐个遍历到最后，然而 reduceRight() 则是从数组的最后一项开始，向前遍历到第一项。下面代码实现了数组求和：\n\n```javascript\nvar values = [1, 2, 3, 4, 5]\nvar sum = values.reduceRight(function(prev, cur, index, array) {\n  return prev + cur\n}, 10)\nconsole.log(sum) //25\n```\n\nreduce() 方法接收一个函数作为累加器。每个值（从左到右开始缩减），直到计算最后一个值。\n\nreduce() 作为空数组是不会执行回调函数的。\n\n```javascript\nvar numbers = [65, 44, 12, 4]\n\nfunction getSum(total, num) {\n  return total + num\n}\nfunction myFunction(item) {\n  document.getElementById('demo').innerHTML = numbers.reduce(getSum)\n}\n```\n","source":"_posts/数组操作方法.md","raw":"---\ntitle: 数组操作方法\ncategories: 原生JS\ncomments: true\n---\n\n## 数组原形方法有以下几种 :\n\n`join()`,`push()`,`pop()`,`sort()`,`reverse()`,`concat()`,`slice()`,`splice()`,`indexOf()`,`lastIndexOf()`,`forEach()`,`map()`, `filter()`,`every()`,`some()`,`reduce()`,`reduceRigh()`\n\n<!--more-->\n\n## 1.join()，不改变原数组。\n\njoin(separator): 将数组的元素组成一个字符串，以 separator 为分隔符，省略则默认为逗号，该方法只接受一个参数。\n\n```javascript\nvar arr = [1, 2, 3]\nconsole.log(arr.join()) // 1,2,3\nconsole.log(arr.join('-')) // 1-2-3\nconsole.log(arr) // [1, 2, 3]（原数组不变）\n```\n\n## 2.push() 与 pop()，改变元素组\n\n* push(): 可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，**并返回修改后数组的长度**。\n* pop(): 数组末尾移除最后一项，减少数组的 length 的值，然后返回移除的项。\n\n```javascript\nvar arr = ['Lily', 'lucy', 'Tom']\nvar count = arr.push('Jack', 'Sean')\nconsole.log(count) // 5\nconsole.log(arr) // [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]\nvar item = arr.pop()\nconsole.log(item) // Sean\nconsole.log(arr) // [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]\n```\n\n## 3.shift() 和 unshift()，改变原数组\n\n* shift(): 删除原数组的第一项，并返回删除元素的值，如果为空则返回 undefined。\n* unshift(): 将参数添加到原数组开头，**并返回数组的长度**。\n\n```javascript\nvar arr = ['Lily', 'lucy', 'Tom']\nvar count = arr.unshift('Jack', 'Sean')\nconsole.log(count) // 5\nconsole.log(arr) //[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]\nvar item = arr.shift()\nconsole.log(item) // Jack\nconsole.log(arr) // [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]\n```\n\n## 4.sort(), 改变原数组\n\n按升序列排序数组系那个（从小到大），在排序时，sort() 方法会调用每个数组的 toString() 转型方法，**然后比较得到的字符串**，已确定如何排序。即使数组中每一个都是数值 ,sort() 方法比较的意识字符串，因此会出现以下情况：\n\n```javascript\nvar arr1 = ['a', 'd', 'c', 'b']\nconsole.log(arr1.sort()) // [\"a\", \"b\", \"c\", \"d\"]\narr2 = [13, 24, 51, 3]\nconsole.log(arr2.sort()) // [13, 24, 3, 51]\nconsole.log(arr2) // [13, 24, 3, 51](元数组被改变)\nvar scores = [1, 10, 21, 2]\nscores.sort() // [1, 10, 2, 21] 注意10在2之前  因为在 Unicode 指针顺序中\"10\"在\"2\"之前\n```\n\n为了解决上述问题，sort() 方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：\n\n```javascript\nfunction compare(value1, value2) {\n  if (value1 < value2) {\n    return -1\n  } else if (value1 > value2) {\n    return 1\n  } else {\n    return 0\n  }\n}\narr2 = [13, 24, 51, 3]\nconsole.log(arr2.sort(compare)) // [3, 13, 24, 51]\n```\n\n如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。\n\n## 5.reverse() ，改变原数组\n\nreverse(): 反转数组项的顺序\n\n```javascript\nreverse()：反转数组项的顺序。\n?\n1\n2\n3\nvar arr = [13, 24, 51, 3];\nconsole.log(arr.reverse()); //[3, 51, 24, 13]\nconsole.log(arr); //[3, 51, 24, 13](原数组改变)\n```\n\n## 6.concat()，不改变原数组\n\nconcat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，**在没有给 concat() 方法传递一个参数的情况下，它只是复制当前数组并返回副本。**\n\n```javascript\nvar arr = [1, 3, 5, 7]\nvar arrCopy = arr.concat(9, [11, 13])\nconsole.log(arrCopy) //[1, 3, 5, 7, 9, 11, 13]\nconsole.log(arr) // [1, 3, 5, 7](原数组未被修改)\n```\n\n上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，**如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？**\n\n```javascript\nvar arrCopy2 = arr.concat([9, [11, 13]])\nconsole.log(arrCopy2) //[1, 3, 5, 7, 9, Array[2]]\nconsole.log(arrCopy2[5]) //[11, 13]\n```\n\n## 7.slice() 不改变原数组\n\nslice(): 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice() 方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice() 方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项 - 但不包括结束位置的项。\n\n```javascript\nvar arr = [1, 3, 5, 7, 9, 11]\nvar arrCopy = arr.slice(1)\nvar arrCopy2 = arr.slice(1, 4)\nvar arrCopy3 = arr.slice(1, -2)\nvar arrCopy4 = arr.slice(-4, -1)\nconsole.log(arr) //[1, 3, 5, 7, 9, 11](原数组没变)\nconsole.log(arrCopy) //[3, 5, 7, 9, 11]\nconsole.log(arrCopy2) //[3, 5, 7]\nconsole.log(arrCopy3) //[3, 5, 7]\nconsole.log(arrCopy4) //[5, 7, 9]\n```\n\n## 8.splice() 可以实现删除、插入和替换 改变原数组\n\n* 删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2) 会删除数组中的前两项。\n* 插入：可以向指定位置插入任意数量的项，需要 3 个参数，起始位置、0 （要删除的项数）和要插入的项，例如 splice(2,0,4,6) 会在当前数组的位置 2 开始插入 4 和 6\n* 替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要 3 个参数，只需要指定 3 个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如 splice(2,1,4,6) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。\n\n```javascript\nvar arr = [1, 3, 5, 7, 9, 11]\nvar arrRemoved = arr.splice(0, 2)\nconsole.log(arr) //[5, 7, 9, 11]\nconsole.log(arrRemoved) //[1, 3]\nvar arrRemoved2 = arr.splice(2, 0, 4, 6)\nconsole.log(arr) // [5, 7, 4, 6, 9, 11]\nconsole.log(arrRemoved2) // []\nvar arrRemoved3 = arr.splice(1, 1, 2, 4)\nconsole.log(arr) // [5, 2, 4, 4, 6, 9, 11]\nconsole.log(arrRemoved3) //[7]\n```\n\n## 9.indexOf() 和 lastIndexOf()\n\n* indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。\n* lastIndexOf() ：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找\n\n```javascript\nvar arr = [1, 3, 5, 7, 7, 5, 3, 1]\nconsole.log(arr.indexOf(5)) //2\nconsole.log(arr.lastIndexOf(5)) //5\nconsole.log(arr.indexOf(5, 2)) //2\nconsole.log(arr.lastIndexOf(5, 4)) //2\nconsole.log(arr.indexOf('5')) //-1\n```\n\n## 10.forEach() 遍历\n\n对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是 function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\narr.forEach(function(x, index, a) {\n  console.log(x + '|' + index + '|' + (a === arr))\n})\n// 输出为：\n// 1|0|true\n// 2|1|true\n// 3|2|true\n// 4|3|true\n// 5|4|true\n```\n\n## 11.map()\n\nmap() ：指 “ 映射 ”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\nvar arr2 = arr.map(function(item) {\n  return item * item\n})\nconsole.log(arr2) //[1, 4, 9, 16, 25]\n```\n\n## 12.filter()\n\nfilter(): “ 过滤功能 ”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。\n\n```javasript\nvar arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nvar arr2 = arr.filter(function(x, index) {\nreturn index % 3 === 0 || x >= 8;\n});\nconsole.log(arr2); //[1, 4, 7, 8, 9, 10]\n```\n\n## 13.every()\n\nevery() ，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回 true。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\nvar arr2 = arr.every(function(x) {\n  return x < 10\n})\nconsole.log(arr2) //true\nvar arr3 = arr.every(function(x) {\n  return x < 3\n})\nconsole.log(arr3) // false\n```\n\n## 14.some()\n\nsome() ：判断数组中是否存在满足条件的项，只要有一项满足，就会返回 true。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5]\nvar arr2 = arr.some(function(x) {\n  return x < 3\n})\nconsole.log(arr2) //true\nvar arr3 = arr.some(function(x) {\n  return x < 1\n})\nconsole.log(arr3) // false\n```\n\n## 15.reduce() 和 reduceRight()\n\n这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce() 方法从数组的第一项开始，逐个遍历到最后，然而 reduceRight() 则是从数组的最后一项开始，向前遍历到第一项。下面代码实现了数组求和：\n\n```javascript\nvar values = [1, 2, 3, 4, 5]\nvar sum = values.reduceRight(function(prev, cur, index, array) {\n  return prev + cur\n}, 10)\nconsole.log(sum) //25\n```\n\nreduce() 方法接收一个函数作为累加器。每个值（从左到右开始缩减），直到计算最后一个值。\n\nreduce() 作为空数组是不会执行回调函数的。\n\n```javascript\nvar numbers = [65, 44, 12, 4]\n\nfunction getSum(total, num) {\n  return total + num\n}\nfunction myFunction(item) {\n  document.getElementById('demo').innerHTML = numbers.reduce(getSum)\n}\n```\n","slug":"数组操作方法","published":1,"date":"2018-03-20T03:29:41.823Z","updated":"2018-03-20T03:29:41.823Z","_id":"cjepksjo900168gv6vyfnnkkd","layout":"post","photos":[],"link":"","content":"<h2 id=\"数组原形方法有以下几种\"><a href=\"#数组原形方法有以下几种\" class=\"headerlink\" title=\"数组原形方法有以下几种 :\"></a>数组原形方法有以下几种 :</h2><p><code>join()</code>,<code>push()</code>,<code>pop()</code>,<code>sort()</code>,<code>reverse()</code>,<code>concat()</code>,<code>slice()</code>,<code>splice()</code>,<code>indexOf()</code>,<code>lastIndexOf()</code>,<code>forEach()</code>,<code>map()</code>, <code>filter()</code>,<code>every()</code>,<code>some()</code>,<code>reduce()</code>,<code>reduceRigh()</code></p>\n<a id=\"more\"></a>\n<h2 id=\"1-join-，不改变原数组。\"><a href=\"#1-join-，不改变原数组。\" class=\"headerlink\" title=\"1.join()，不改变原数组。\"></a>1.join()，不改变原数组。</h2><p>join(separator): 将数组的元素组成一个字符串，以 separator 为分隔符，省略则默认为逗号，该方法只接受一个参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join()) <span class=\"comment\">// 1,2,3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join(<span class=\"string\">'-'</span>)) <span class=\"comment\">// 1-2-3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-push-与-pop-，改变元素组\"><a href=\"#2-push-与-pop-，改变元素组\" class=\"headerlink\" title=\"2.push() 与 pop()，改变元素组\"></a>2.push() 与 pop()，改变元素组</h2><ul>\n<li>push(): 可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，<strong>并返回修改后数组的长度</strong>。</li>\n<li>pop(): 数组末尾移除最后一项，减少数组的 length 的值，然后返回移除的项。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'Lily'</span>, <span class=\"string\">'lucy'</span>, <span class=\"string\">'Tom'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.push(<span class=\"string\">'Jack'</span>, <span class=\"string\">'Sean'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.pop()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item) <span class=\"comment\">// Sean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-shift-和-unshift-，改变原数组\"><a href=\"#3-shift-和-unshift-，改变原数组\" class=\"headerlink\" title=\"3.shift() 和 unshift()，改变原数组\"></a>3.shift() 和 unshift()，改变原数组</h2><ul>\n<li>shift(): 删除原数组的第一项，并返回删除元素的值，如果为空则返回 undefined。</li>\n<li>unshift(): 将参数添加到原数组开头，<strong>并返回数组的长度</strong>。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'Lily'</span>, <span class=\"string\">'lucy'</span>, <span class=\"string\">'Tom'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.unshift(<span class=\"string\">'Jack'</span>, <span class=\"string\">'Sean'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">//[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.shift()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item) <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-sort-改变原数组\"><a href=\"#4-sort-改变原数组\" class=\"headerlink\" title=\"4.sort(), 改变原数组\"></a>4.sort(), 改变原数组</h2><p>按升序列排序数组系那个（从小到大），在排序时，sort() 方法会调用每个数组的 toString() 转型方法，<strong>然后比较得到的字符串</strong>，已确定如何排序。即使数组中每一个都是数值 ,sort() 方法比较的意识字符串，因此会出现以下情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'b'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.sort()) <span class=\"comment\">// [\"a\", \"b\", \"c\", \"d\"]</span></span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort()) <span class=\"comment\">// [13, 24, 3, 51]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">// [13, 24, 3, 51](元数组被改变)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> scores = [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">scores.sort() <span class=\"comment\">// [1, 10, 2, 21] 注意10在2之前  因为在 Unicode 指针顺序中\"10\"在\"2\"之前</span></span><br></pre></td></tr></table></figure>\n<p>为了解决上述问题，sort() 方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort(compare)) <span class=\"comment\">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure>\n<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。</p>\n<h2 id=\"5-reverse-，改变原数组\"><a href=\"#5-reverse-，改变原数组\" class=\"headerlink\" title=\"5.reverse() ，改变原数组\"></a>5.reverse() ，改变原数组</h2><p>reverse(): 反转数组项的顺序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reverse()：反转数组项的顺序。</span><br><span class=\"line\">?</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.reverse()); <span class=\"comment\">//[3, 51, 24, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-concat-，不改变原数组\"><a href=\"#6-concat-，不改变原数组\" class=\"headerlink\" title=\"6.concat()，不改变原数组\"></a>6.concat()，不改变原数组</h2><p>concat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，<strong>在没有给 concat() 方法传递一个参数的情况下，它只是复制当前数组并返回副本。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.concat(<span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">13</span>])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy) <span class=\"comment\">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure>\n<p>上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，<strong>如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.concat([<span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">13</span>]])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2) <span class=\"comment\">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2[<span class=\"number\">5</span>]) <span class=\"comment\">//[11, 13]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-slice-不改变原数组\"><a href=\"#7-slice-不改变原数组\" class=\"headerlink\" title=\"7.slice() 不改变原数组\"></a>7.slice() 不改变原数组</h2><p>slice(): 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice() 方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice() 方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项 - 但不包括结束位置的项。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.slice(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy3 = arr.slice(<span class=\"number\">1</span>, <span class=\"number\">-2</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy4 = arr.slice(<span class=\"number\">-4</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy) <span class=\"comment\">//[3, 5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2) <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy3) <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy4) <span class=\"comment\">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8-splice-可以实现删除、插入和替换-改变原数组\"><a href=\"#8-splice-可以实现删除、插入和替换-改变原数组\" class=\"headerlink\" title=\"8.splice() 可以实现删除、插入和替换 改变原数组\"></a>8.splice() 可以实现删除、插入和替换 改变原数组</h2><ul>\n<li>删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2) 会删除数组中的前两项。</li>\n<li>插入：可以向指定位置插入任意数量的项，需要 3 个参数，起始位置、0 （要删除的项数）和要插入的项，例如 splice(2,0,4,6) 会在当前数组的位置 2 开始插入 4 和 6</li>\n<li>替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要 3 个参数，只需要指定 3 个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如 splice(2,1,4,6) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved = arr.splice(<span class=\"number\">0</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">//[5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved) <span class=\"comment\">//[1, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved2 = arr.splice(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [5, 7, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved2) <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved3 = arr.splice(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved3) <span class=\"comment\">//[7]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"9-indexOf-和-lastIndexOf\"><a href=\"#9-indexOf-和-lastIndexOf\" class=\"headerlink\" title=\"9.indexOf() 和 lastIndexOf()\"></a>9.indexOf() 和 lastIndexOf()</h2><ul>\n<li>indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。</li>\n<li>lastIndexOf() ：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>)) <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>)) <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>, <span class=\"number\">2</span>)) <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>, <span class=\"number\">4</span>)) <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"string\">'5'</span>)) <span class=\"comment\">//-1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"10-forEach-遍历\"><a href=\"#10-forEach-遍历\" class=\"headerlink\" title=\"10.forEach() 遍历\"></a>10.forEach() 遍历</h2><p>对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是 function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, index, a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x + <span class=\"string\">'|'</span> + index + <span class=\"string\">'|'</span> + (a === arr))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">// 1|0|true</span></span><br><span class=\"line\"><span class=\"comment\">// 2|1|true</span></span><br><span class=\"line\"><span class=\"comment\">// 3|2|true</span></span><br><span class=\"line\"><span class=\"comment\">// 4|3|true</span></span><br><span class=\"line\"><span class=\"comment\">// 5|4|true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"11-map\"><a href=\"#11-map\" class=\"headerlink\" title=\"11.map()\"></a>11.map()</h2><p>map() ：指 “ 映射 ”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item * item</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"12-filter\"><a href=\"#12-filter\" class=\"headerlink\" title=\"12.filter()\"></a>12.filter()</h2><p>filter(): “ 过滤功能 ”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class=\"line\">var arr2 = arr.filter(function(x, index) &#123;</span><br><span class=\"line\">return index % 3 === 0 || x &gt;= 8;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(arr2); //[1, 4, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>\n<h2 id=\"13-every\"><a href=\"#13-every\" class=\"headerlink\" title=\"13.every()\"></a>13.every()</h2><p>every() ，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"14-some\"><a href=\"#14-some\" class=\"headerlink\" title=\"14.some()\"></a>14.some()</h2><p>some() ：判断数组中是否存在满足条件的项，只要有一项满足，就会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15-reduce-和-reduceRight\"><a href=\"#15-reduce-和-reduceRight\" class=\"headerlink\" title=\"15.reduce() 和 reduceRight()\"></a>15.reduce() 和 reduceRight()</h2><p>这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce() 方法从数组的第一项开始，逐个遍历到最后，然而 reduceRight() 则是从数组的最后一项开始，向前遍历到第一项。下面代码实现了数组求和：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = values.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + cur</span><br><span class=\"line\">&#125;, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum) <span class=\"comment\">//25</span></span><br></pre></td></tr></table></figure>\n<p>reduce() 方法接收一个函数作为累加器。每个值（从左到右开始缩减），直到计算最后一个值。</p>\n<p>reduce() 作为空数组是不会执行回调函数的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">65</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\">total, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = numbers.reduce(getSum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"数组原形方法有以下几种\"><a href=\"#数组原形方法有以下几种\" class=\"headerlink\" title=\"数组原形方法有以下几种 :\"></a>数组原形方法有以下几种 :</h2><p><code>join()</code>,<code>push()</code>,<code>pop()</code>,<code>sort()</code>,<code>reverse()</code>,<code>concat()</code>,<code>slice()</code>,<code>splice()</code>,<code>indexOf()</code>,<code>lastIndexOf()</code>,<code>forEach()</code>,<code>map()</code>, <code>filter()</code>,<code>every()</code>,<code>some()</code>,<code>reduce()</code>,<code>reduceRigh()</code></p>","more":"<h2 id=\"1-join-，不改变原数组。\"><a href=\"#1-join-，不改变原数组。\" class=\"headerlink\" title=\"1.join()，不改变原数组。\"></a>1.join()，不改变原数组。</h2><p>join(separator): 将数组的元素组成一个字符串，以 separator 为分隔符，省略则默认为逗号，该方法只接受一个参数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join()) <span class=\"comment\">// 1,2,3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.join(<span class=\"string\">'-'</span>)) <span class=\"comment\">// 1-2-3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [1, 2, 3]（原数组不变）</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-push-与-pop-，改变元素组\"><a href=\"#2-push-与-pop-，改变元素组\" class=\"headerlink\" title=\"2.push() 与 pop()，改变元素组\"></a>2.push() 与 pop()，改变元素组</h2><ul>\n<li>push(): 可以接受任意数量的数组，把它们，把他们逐个添加到数组末尾，<strong>并返回修改后数组的长度</strong>。</li>\n<li>pop(): 数组末尾移除最后一项，减少数组的 length 的值，然后返回移除的项。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'Lily'</span>, <span class=\"string\">'lucy'</span>, <span class=\"string\">'Tom'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.push(<span class=\"string\">'Jack'</span>, <span class=\"string\">'Sean'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\", \"Sean\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.pop()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item) <span class=\"comment\">// Sean</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [\"Lily\", \"lucy\", \"Tom\", \"Jack\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"3-shift-和-unshift-，改变原数组\"><a href=\"#3-shift-和-unshift-，改变原数组\" class=\"headerlink\" title=\"3.shift() 和 unshift()，改变原数组\"></a>3.shift() 和 unshift()，改变原数组</h2><ul>\n<li>shift(): 删除原数组的第一项，并返回删除元素的值，如果为空则返回 undefined。</li>\n<li>unshift(): 将参数添加到原数组开头，<strong>并返回数组的长度</strong>。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"string\">'Lily'</span>, <span class=\"string\">'lucy'</span>, <span class=\"string\">'Tom'</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> count = arr.unshift(<span class=\"string\">'Jack'</span>, <span class=\"string\">'Sean'</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(count) <span class=\"comment\">// 5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">//[\"Jack\", \"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> item = arr.shift()</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(item) <span class=\"comment\">// Jack</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [\"Sean\", \"Lily\", \"lucy\", \"Tom\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-sort-改变原数组\"><a href=\"#4-sort-改变原数组\" class=\"headerlink\" title=\"4.sort(), 改变原数组\"></a>4.sort(), 改变原数组</h2><p>按升序列排序数组系那个（从小到大），在排序时，sort() 方法会调用每个数组的 toString() 转型方法，<strong>然后比较得到的字符串</strong>，已确定如何排序。即使数组中每一个都是数值 ,sort() 方法比较的意识字符串，因此会出现以下情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr1 = [<span class=\"string\">'a'</span>, <span class=\"string\">'d'</span>, <span class=\"string\">'c'</span>, <span class=\"string\">'b'</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr1.sort()) <span class=\"comment\">// [\"a\", \"b\", \"c\", \"d\"]</span></span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort()) <span class=\"comment\">// [13, 24, 3, 51]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">// [13, 24, 3, 51](元数组被改变)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> scores = [<span class=\"number\">1</span>, <span class=\"number\">10</span>, <span class=\"number\">21</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">scores.sort() <span class=\"comment\">// [1, 10, 2, 21] 注意10在2之前  因为在 Unicode 指针顺序中\"10\"在\"2\"之前</span></span><br></pre></td></tr></table></figure>\n<p>为了解决上述问题，sort() 方法可以接受一个参数，以便指定哪个值位于哪个值前面。比较函数接受两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回 0，如果第一个参数应该位于第二个参数之后则返回一个正数。一下是比较函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compare</span>(<span class=\"params\">value1, value2</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (value1 &lt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value1 &gt; value2) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">arr2 = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2.sort(compare)) <span class=\"comment\">// [3, 13, 24, 51]</span></span><br></pre></td></tr></table></figure>\n<p>如果需要通过比较函数产生降序排序的结果，只要交换比较函数的返回值即可。</p>\n<h2 id=\"5-reverse-，改变原数组\"><a href=\"#5-reverse-，改变原数组\" class=\"headerlink\" title=\"5.reverse() ，改变原数组\"></a>5.reverse() ，改变原数组</h2><p>reverse(): 反转数组项的顺序</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reverse()：反转数组项的顺序。</span><br><span class=\"line\">?</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">24</span>, <span class=\"number\">51</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.reverse()); <span class=\"comment\">//[3, 51, 24, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr); <span class=\"comment\">//[3, 51, 24, 13](原数组改变)</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"6-concat-，不改变原数组\"><a href=\"#6-concat-，不改变原数组\" class=\"headerlink\" title=\"6.concat()，不改变原数组\"></a>6.concat()，不改变原数组</h2><p>concat()：将参数添加到元素组中，这个方法会先创建当前数组的一个副本，然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组，<strong>在没有给 concat() 方法传递一个参数的情况下，它只是复制当前数组并返回副本。</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.concat(<span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">13</span>])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy) <span class=\"comment\">//[1, 3, 5, 7, 9, 11, 13]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [1, 3, 5, 7](原数组未被修改)</span></span><br></pre></td></tr></table></figure>\n<p>上面的测试中发现，传入的不是数组，则是直接将数组添加到数组后面，<strong>如果传入的是数组，则将数组中的各个项添加到数组中，但如果是二维数组呢？</strong></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.concat([<span class=\"number\">9</span>, [<span class=\"number\">11</span>, <span class=\"number\">13</span>]])</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2) <span class=\"comment\">//[1, 3, 5, 7, 9, Array[2]]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2[<span class=\"number\">5</span>]) <span class=\"comment\">//[11, 13]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"7-slice-不改变原数组\"><a href=\"#7-slice-不改变原数组\" class=\"headerlink\" title=\"7.slice() 不改变原数组\"></a>7.slice() 不改变原数组</h2><p>slice(): 返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice() 方法可以接受一或是两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下，slice() 方法返回从该参数指定位置到当前数组末尾的所有项。如果有两个参数，就会返回起始和结束位置之前的项 - 但不包括结束位置的项。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy = arr.slice(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy2 = arr.slice(<span class=\"number\">1</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy3 = arr.slice(<span class=\"number\">1</span>, <span class=\"number\">-2</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrCopy4 = arr.slice(<span class=\"number\">-4</span>, <span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">//[1, 3, 5, 7, 9, 11](原数组没变)</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy) <span class=\"comment\">//[3, 5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy2) <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy3) <span class=\"comment\">//[3, 5, 7]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrCopy4) <span class=\"comment\">//[5, 7, 9]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"8-splice-可以实现删除、插入和替换-改变原数组\"><a href=\"#8-splice-可以实现删除、插入和替换-改变原数组\" class=\"headerlink\" title=\"8.splice() 可以实现删除、插入和替换 改变原数组\"></a>8.splice() 可以实现删除、插入和替换 改变原数组</h2><ul>\n<li>删除：可以删除任意数量的项，只需要提供两个参数，要删除的个一个项的位置和要删除的橡树。例如，splice(0,2) 会删除数组中的前两项。</li>\n<li>插入：可以向指定位置插入任意数量的项，需要 3 个参数，起始位置、0 （要删除的项数）和要插入的项，例如 splice(2,0,4,6) 会在当前数组的位置 2 开始插入 4 和 6</li>\n<li>替换：可以向指定的位置插入任意的项，同时删除任意数量的项。需要 3 个参数，只需要指定 3 个参数，起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等，例如 splice(2,1,4,6) 会删除当前数组位置 2 的项，然后再从位置 2 开始插入 4 和 6。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">11</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved = arr.splice(<span class=\"number\">0</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">//[5, 7, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved) <span class=\"comment\">//[1, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved2 = arr.splice(<span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [5, 7, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved2) <span class=\"comment\">// []</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arrRemoved3 = arr.splice(<span class=\"number\">1</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr) <span class=\"comment\">// [5, 2, 4, 4, 6, 9, 11]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrRemoved3) <span class=\"comment\">//[7]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"9-indexOf-和-lastIndexOf\"><a href=\"#9-indexOf-和-lastIndexOf\" class=\"headerlink\" title=\"9.indexOf() 和 lastIndexOf()\"></a>9.indexOf() 和 lastIndexOf()</h2><ul>\n<li>indexOf()：接受两个参数，要查找的项和（可选的）表示查找七点位置的索引。从数组的开头开始查找。</li>\n<li>lastIndexOf() ：接受两个参数：要查找的项和（可选的）表示查找起点位置的索引。从数组的末尾开始查找</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">7</span>, <span class=\"number\">5</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>)) <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>)) <span class=\"comment\">//5</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"number\">5</span>, <span class=\"number\">2</span>)) <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.lastIndexOf(<span class=\"number\">5</span>, <span class=\"number\">4</span>)) <span class=\"comment\">//2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr.indexOf(<span class=\"string\">'5'</span>)) <span class=\"comment\">//-1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"10-forEach-遍历\"><a href=\"#10-forEach-遍历\" class=\"headerlink\" title=\"10.forEach() 遍历\"></a>10.forEach() 遍历</h2><p>对数组进行遍历循环遍历，对数组的每一项运行给定函数，这个方法没有返回值，参数都是 function 类型，默认参数分别有：遍历数组内容、对应的数组索引、数组本身。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\">arr.forEach(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, index, a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(x + <span class=\"string\">'|'</span> + index + <span class=\"string\">'|'</span> + (a === arr))</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"comment\">// 输出为：</span></span><br><span class=\"line\"><span class=\"comment\">// 1|0|true</span></span><br><span class=\"line\"><span class=\"comment\">// 2|1|true</span></span><br><span class=\"line\"><span class=\"comment\">// 3|2|true</span></span><br><span class=\"line\"><span class=\"comment\">// 4|3|true</span></span><br><span class=\"line\"><span class=\"comment\">// 5|4|true</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"11-map\"><a href=\"#11-map\" class=\"headerlink\" title=\"11.map()\"></a>11.map()</h2><p>map() ：指 “ 映射 ”，对数组中的每一项运行给定函数，返回每一次函数调用的结果组成的数组。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item * item</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">//[1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"12-filter\"><a href=\"#12-filter\" class=\"headerlink\" title=\"12.filter()\"></a>12.filter()</h2><p>filter(): “ 过滤功能 ”，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];</span><br><span class=\"line\">var arr2 = arr.filter(function(x, index) &#123;</span><br><span class=\"line\">return index % 3 === 0 || x &gt;= 8;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(arr2); //[1, 4, 7, 8, 9, 10]</span><br></pre></td></tr></table></figure>\n<h2 id=\"13-every\"><a href=\"#13-every\" class=\"headerlink\" title=\"13.every()\"></a>13.every()</h2><p>every() ，判断数组中每一项都是满足条件，只有所有项都满足条件才会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.every(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"14-some\"><a href=\"#14-some\" class=\"headerlink\" title=\"14.some()\"></a>14.some()</h2><p>some() ：判断数组中是否存在满足条件的项，只要有一项满足，就会返回 true。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> arr2 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">3</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr2) <span class=\"comment\">//true</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> arr3 = arr.some(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x &lt; <span class=\"number\">1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr3) <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"15-reduce-和-reduceRight\"><a href=\"#15-reduce-和-reduceRight\" class=\"headerlink\" title=\"15.reduce() 和 reduceRight()\"></a>15.reduce() 和 reduceRight()</h2><p>这两个都会实现迭代数组所有项，然后构建一个最终返回的值。reduce() 方法从数组的第一项开始，逐个遍历到最后，然而 reduceRight() 则是从数组的最后一项开始，向前遍历到第一项。下面代码实现了数组求和：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> values = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>]</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = values.reduceRight(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">prev, cur, index, array</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> prev + cur</span><br><span class=\"line\">&#125;, <span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(sum) <span class=\"comment\">//25</span></span><br></pre></td></tr></table></figure>\n<p>reduce() 方法接收一个函数作为累加器。每个值（从左到右开始缩减），直到计算最后一个值。</p>\n<p>reduce() 作为空数组是不会执行回调函数的。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">65</span>, <span class=\"number\">44</span>, <span class=\"number\">12</span>, <span class=\"number\">4</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getSum</span>(<span class=\"params\">total, num</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> total + num</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\">item</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'demo'</span>).innerHTML = numbers.reduce(getSum)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"有趣JS题","date":"2018-03-08T07:57:30.000Z","_content":"\n一些出乎意料的题及面试题的积累\n\n<!--more-->\n\n## 变量提升\n\n```javascript\nif (!'abc' in window) {\n  var abc = 10\n}\nconsole.log(abc) //undefined\n//因为先变量声明提升 所以提升之后abc的值系统默认会赋值为undefined。 !abc为false ,in是检查对象中是否存在某个属性。很显然 false属于是一个布尔类型。不存在对象中。所以没有走if里面的变量赋值。\n\nconsole.log(a) //undefined\nif (!('a' in window)) {\n  var a = 10\n}\nconsole.log(a) //undefined\n//因为先变量声明提升 所以提升之后a的值系统默认会赋值为undefined。 变量提升会存在GO中也就是window。所以(\"a\" in window)肯定为true。!去反一下就为false。所以不走赋值。\n\nvar x = 1\nif (function f() {}) {\n  x += typeof f\n}\nconsole.log(x) //1undefined\n//因为函数题在()中会以表达式去运行。最后转换为true,不会存在函数整体声明提升。所以typeof为undefined\n```\n\n## 闭包\n\n```javascript\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\nvar a = fun(0)\na.fun(1)\na.fun(2)\na.fun(3) //输出什么 undefined 0 0 0\nvar b = fun(0)\n  .fun(1)\n  .fun(2)\n  .fun(3) //输出什么 undefined 0 1 2\nvar c = fun(0).fun(1)\nc.fun(2)\nc.fun(3) //输出什么 undefined 0 1 1\n\n//答案很显而易见。换一个形式看着道题\n\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\nvar a = fun(0)\na.fun(1)\na.fun(2)\na.fun(3) //输出什么 undefined 0 0 0\n```\n","source":"_posts/有趣JS题.md","raw":"---\ntitle: 有趣JS题\ndate: 2018-03-08 15:57:30\ntags:\n---\n\n一些出乎意料的题及面试题的积累\n\n<!--more-->\n\n## 变量提升\n\n```javascript\nif (!'abc' in window) {\n  var abc = 10\n}\nconsole.log(abc) //undefined\n//因为先变量声明提升 所以提升之后abc的值系统默认会赋值为undefined。 !abc为false ,in是检查对象中是否存在某个属性。很显然 false属于是一个布尔类型。不存在对象中。所以没有走if里面的变量赋值。\n\nconsole.log(a) //undefined\nif (!('a' in window)) {\n  var a = 10\n}\nconsole.log(a) //undefined\n//因为先变量声明提升 所以提升之后a的值系统默认会赋值为undefined。 变量提升会存在GO中也就是window。所以(\"a\" in window)肯定为true。!去反一下就为false。所以不走赋值。\n\nvar x = 1\nif (function f() {}) {\n  x += typeof f\n}\nconsole.log(x) //1undefined\n//因为函数题在()中会以表达式去运行。最后转换为true,不会存在函数整体声明提升。所以typeof为undefined\n```\n\n## 闭包\n\n```javascript\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\nvar a = fun(0)\na.fun(1)\na.fun(2)\na.fun(3) //输出什么 undefined 0 0 0\nvar b = fun(0)\n  .fun(1)\n  .fun(2)\n  .fun(3) //输出什么 undefined 0 1 2\nvar c = fun(0).fun(1)\nc.fun(2)\nc.fun(3) //输出什么 undefined 0 1 1\n\n//答案很显而易见。换一个形式看着道题\n\nfunction fun(n, o) {\n  console.log(o)\n  return {\n    fun: function(m) {\n      return fun(m, n)\n    }\n  }\n}\nvar a = fun(0)\na.fun(1)\na.fun(2)\na.fun(3) //输出什么 undefined 0 0 0\n```\n","slug":"有趣JS题","published":1,"updated":"2018-03-20T03:29:41.823Z","_id":"cjepksjob00198gv64yhn1ujm","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一些出乎意料的题及面试题的积累</p>\n<a id=\"more\"></a>\n<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"string\">'abc'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> abc = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(abc) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//因为先变量声明提升 所以提升之后abc的值系统默认会赋值为undefined。 !abc为false ,in是检查对象中是否存在某个属性。很显然 false属于是一个布尔类型。不存在对象中。所以没有走if里面的变量赋值。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(<span class=\"string\">'a'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//因为先变量声明提升 所以提升之后a的值系统默认会赋值为undefined。 变量提升会存在GO中也就是window。所以(\"a\" in window)肯定为true。!去反一下就为false。所以不走赋值。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;) &#123;</span><br><span class=\"line\">  x += <span class=\"keyword\">typeof</span> f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//1undefined</span></span><br><span class=\"line\"><span class=\"comment\">//因为函数题在()中会以表达式去运行。最后转换为true,不会存在函数整体声明提升。所以typeof为undefined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 0 0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 1 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">c.fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">c.fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 1 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案很显而易见。换一个形式看着道题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 0 0</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>一些出乎意料的题及面试题的积累</p>","more":"<h2 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (!<span class=\"string\">'abc'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> abc = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(abc) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//因为先变量声明提升 所以提升之后abc的值系统默认会赋值为undefined。 !abc为false ,in是检查对象中是否存在某个属性。很显然 false属于是一个布尔类型。不存在对象中。所以没有走if里面的变量赋值。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!(<span class=\"string\">'a'</span> <span class=\"keyword\">in</span> <span class=\"built_in\">window</span>)) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(a) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"><span class=\"comment\">//因为先变量声明提升 所以提升之后a的值系统默认会赋值为undefined。 变量提升会存在GO中也就是window。所以(\"a\" in window)肯定为true。!去反一下就为false。所以不走赋值。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;&#125;) &#123;</span><br><span class=\"line\">  x += <span class=\"keyword\">typeof</span> f</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(x) <span class=\"comment\">//1undefined</span></span><br><span class=\"line\"><span class=\"comment\">//因为函数题在()中会以表达式去运行。最后转换为true,不会存在函数整体声明提升。所以typeof为undefined</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 0 0</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> b = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">  .fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 1 2</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> c = fun(<span class=\"number\">0</span>).fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">c.fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">c.fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 1 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//答案很显而易见。换一个形式看着道题</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">n, o</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(o)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    fun: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fun(m, n)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> a = fun(<span class=\"number\">0</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">1</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">2</span>)</span><br><span class=\"line\">a.fun(<span class=\"number\">3</span>) <span class=\"comment\">//输出什么 undefined 0 0 0</span></span><br></pre></td></tr></table></figure>"},{"title":"疑难杂问整理（原生JS）","date":"2018-01-19T02:12:08.000Z","_content":"\n在学习原生的过程中的困惑与解惑的总结\n\n<!--more-->\n\n## 工厂模式\n\n```javascript\nfunction createPerson(name, age, job) {\n  var o = new Object()\n  o.name = name\n  o.age = age\n  o.job = job\n  o.sayName = function() {\n    alert(this.name)\n  }\n  return 0\n}\n\nvar person1 = createPerson('Nicholas', 29, 'Software Engineer')\nvar person2 = createPerson('Greg', 27, 'Doctor')\n\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\n```\n\n## 构造函数\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nvar person3 = new Person('Mick', 23, 'Doctor')\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\nperson2 === person3 //false\nperson1.constructor == Person //true\nPerson.prototype // {constructor: ƒ}  为原型对象\nperson1.prototype //undefined\nPerson.prototype.prototype //undefined\nperson1.constructor == Person //true\nPerson.prototype.constructor == Person //true\n```\n\n实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n  return this\n}\nvar person1 = Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = Person('Mick', 23, 'Doctor')\nperson1 // this 指向window 且被person2覆盖\nperson2 // this 指向window\n```\n\n**与工厂模式的区别**\n\n* 没有显示创建对象（new 运算符创建并实例化新对象）。\n* 直接将属性和方法赋给了 this 对象。\n* 没有 return 语句。\n* 要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象\n* 可以使用 instanceof 操作符检测对象类型。\n\n构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。\n\n## 跨域\n\n具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。\n\n** 凡是拥有 “src” 这个属性的标签都有跨域的能力**\n\n**如果是协议和端口造成的跨域问题。则前台无法解决。** 同源策略具体分为以下几类：\n\n* 不同域名\n* 相同域名不同端口号，如`https://www.oschina.net:8000`和`https://www.oschina.net:8001`\n* 同一个域名不同协议，如`http://www.oschina.net/`和`https://www.oschina.net/`\n* 域名和域名对应的的 IP，如`http://b.qq.com/`和 `http://10.198.7.85`\n* 主域和子域，如`http://www.oschina.net/`和`https://test.oschina.net`\n* 子域和子域，如`https://test1.oschina.net`和`https://test2.oschina.net` 以上情况只要出现了，那么就会产生跨域问题。那么如果解决跨域问题呢，下面的小节会总结一些解决跨域常用的方法。\n\n### JSONP 带 callback 的 json\n\n有个通俗易懂的解释 -JSONP（JSON with Padding ）是数据格式 JSON 的一种 “ 使用模式 ”，可以让网页从别的网域要数据。利用`<script>`标签没有跨域限制，来达到与第 3 方通讯的目的。\n\n** jsonp 的客户端具体实现：**\n\n1. 远程服务器 remoteserver.com 根目录下有个 remote.js 文件代码如下：\n\n```javascript\nalert('我是远程文件')\n```\n\n2. 本地服务器 localserver.com 下有个 jsonp.html 页面代码如下：\n\n```javascript\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title></title>\n    <script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"></script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n页面将会弹出一个提示窗体，显示跨域调用成功。\n\n3. 现在我们在 jsonp.html 页面定义一个函数，然后在远程 remote.js 中传入数据进行调用。\n\njsonp.html 页面代码如下：\n\n```javascript\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title></title>\n    <script type=\"text/javascript\">\n    var localHandler = function(data){\n        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);\n    };\n    </script>\n    <script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"></script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n4. remote.js 文件代码如下：\n\n```javascript\nlocalHandler({ result: '我是远程js带来的数据' })\n```\n\n**要注意的是他支持 GET 这一种 HTTP 请求类型**\n\n### 跨域资源共享（CORS-Cross Origin Resource Sharing ）\n\n跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。\n\nCORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。浏览器 CORS 请求分成两种：\n\n1. 简单请求\n2. 协商模型 / 预检请求（Preflighted Request ），即非简单请求如何区分请求具体属于哪一种呢，下面我总结了几点：\n\n   1. 请求方式：\n\n   * GET\n   * HEAD\n   * POST\n\n   2. HTTP 的头信息子段\n\n   * Accept\n   * Accept-Language\n   * Content-Language\n   * Last-Event-ID\n   * Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data 、 text/plain，其中 'text/plain' 默认支持，其他两种则需要预检请求和服务器协商。\n\n满足以上两大点的即为简单请求，否则为非简单请求。\n\n假如站点 http://foo.example 的网页应用想要访问 http://bar.other 的资源。http://foo.example 的网页中可能包含类似于下面的 JavaScript 代码：\n\n```javascript\nvar invocation = new XMLHttpRequest()\nvar url = 'http://bar.other/resources/public-data/'\n\nfunction callOtherDomain() {\n  if (invocation) {\n    invocation.open('GET', url, true)\n    invocation.onreadystatechange = handler\n    invocation.send()\n  }\n}\n```\n\n### document.domain+iframe （适用于主域名相同的情况）\n\n比如，有一个页面，它的地址是http://www.damonare.cn/a.html ， 在这个页面里面有一个 iframe，它的 src 是http://damonare.cn/b.html, 很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的：\n\n```javascript\n<script type=\"text/javascript\">\n    function test(){\n        var iframe = document.getElementById('￼ifame');\n        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的\n        var doc = win.document;//这里获取不到iframe里的document对象\n        var name = win.name;//这里同样获取不到window对象的name属性\n    }\n</script>\n<iframe id = \"iframe\" src=\"http://damonare.cn/b.html\" onload = \"test()\"><\\/iframe>\n```\n\n这时只要把http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n\n* 在页面http://www.damonare.cn/a.html 中设置 document.domain:\n\n```javascript\n<iframe id = \"iframe\" src=\"http://damonare.cn/b.html\" onload = \"test()\"></iframe>\n<script type=\"text/javascript\">\n    document.domain = 'damonare.cn';//设置成主域\n    function test(){\n        alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象\n    }\n</script>\n```\n\n* 在页面http://damonare.cn/b.html 中也设置 document.domain:\n\n```javascript\n;<script type=\"text/javascript\">\n  document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同\n</script>\n```\n\n修改 document.domain 的方法只适用于不同子域的框架间的交互。\n\n### 通过 location.hash 跨域\n\n此方法的原理就是改变 URL 的 hash 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息（由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于父窗口域名下的一个代理 iframe），并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，这样做也存在缺点，诸如数据直接暴露在了 url 中，数据容量和类型都有限等。\n\n### 通过 HTML5 的 postMessage 方法跨域\n\n这个功能主要包括接受信息的 ”message” 事件和发送消息的 ”postMessage” 方法。比如http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信\n\nA 页面通过 postMessage 方法发送消息：\n\n```javascript\nwindow.onload = function() {\n  var ifr = document.getElementById('ifr')\n  var targetOrigin = 'http://www.google.com'\n  ifr.contentWindow.postMessage('hello world!', targetOrigin)\n}\n```\n\n**postMessage 的使用方法**\n\notherWindow.postMessage(message, targetOrigin);\n\n* otherWindow: 指目标窗口，也就是给哪个 window 发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口\n* message: 是要发送的消息，类型为 String、Object (IE8 、 9 不支持 )\n* targetOrigin: 是限定消息接收范围，不限制请使用 ‘\\*\n\nB 页面通过 message 事件监听并接受消息 :\n\n```javascript\nvar onmessage = function(event) {\n  var data = event.data //消息\n  var origin = event.origin //消息来源地址\n  var source = event.source //源Window对象\n  if (origin == 'http://www.baidu.com') {\n    console.log(data) //hello world!\n  }\n}\nif (typeof window.addEventListener != 'undefined') {\n  window.addEventListener('message', onmessage, false)\n} else if (typeof window.attachEvent != 'undefined') {\n  //for ie\n  window.attachEvent('onmessage', onmessage)\n}\n```\n\n### 通过 window.name 跨域\n\n在一个窗口生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每一个页面对 window.name 都有读写的权限，window.name 是持久的存在于一个窗口载入的所有页面，并不会因为新的页面的载入而被重置。\n\n下面为 a.html 中代码\n\n```javascript\n<script>\n    window.name = '我是页面a中设置的值';\n    setInterval(function(){\n        window.location = 'b.html';\n    },2000)//两秒后把一个新页面b.html载入到当前的window中\n</script>\n```\n\nb.html 中的代码\n\n```javascript\n;<script>console.log(window.name);//读取window.name的值</script>\n```\n\n## 从输入 URL 到 页面加载发生了什么\n\n发生过程：\n\n* 查看 web 缓存\n* DNS 解析\n* TCP 连接\n* 发送 HTTP 请求\n* 服务器处理请求并返回 HTTP 报文\n* 浏览器解析渲染页面\n* 连接结束\n\n### 查看 web 缓存\n\n三级缓存原理\n\n1. 先去内存中看，如果有，直接加载。\n2. 如果内存没有，这区硬盘获取，如果有直接加载。\n3. 如果硬盘中也没有，那么就进行网络请求。\n4. 加载到的资源缓存到硬盘和内存。\n\n#### 浏览器缓存机制\n\n![img caption](/images/problem/2.png)\n\n##### 当前缓存是否过期。\n\n如果浏览器通过某些条件 ( 条件之后再说 ) 判断出来，ok 现在这个缓存没有过期可以用，那么连请求都不会发的，直接是启用之前浏览器缓存下来的那份文件 (from memory cache). 浏览器直接通过缓存读取了出来，注意这个时候是不会向浏览器请求的！ 如果过期了就会向服务器重新发起请求，但是不一定就会重新拉取文件！\n\n##### 服务器中的文件是否改动。\n\n1. 缓存过期，文件有改动：如果服务器发现这个文件改变了那么你肯定不能再用以前浏览器的缓存了，那就返回个 200 并且带上新的文件。\n\n2. 缓存过期，文件无改动：同时如果发现虽然那个缓存虽然过期了，可你在服务器端的文件没有变过，那么服务器只会给你返回一个头信息 (304)，让你继续用你那过期的缓存，这样就节省了很多传输文件的时间带宽啥的\n\n过期了的缓存需要请求一次服务器，若服务器判断说这个文件没有改变还能用，那就返回 304。浏览器认识 304，它就会去读取过期缓存。否则就真的传一份新文件到浏览器。\n\n### DNS 解析\n\n浏览器查找域名对应的 IP 地址。互联网上每一台计算机的唯一识别是它的 IP 地址，DNS 解析就是讲网址转换为 IP 地址。\n\n查找过程：\n\n1. 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）\n2. 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）\n3. 搜索操作系统的 host 文件（Windows 环境下，维护一张域名与 IP 地址的对应表）\n4. 操作系统间根域名发送至 LDNS（本地域名服务器），首先查找自己的缓存若是失败：\n   * 向根域名服务器发起请求，此处根域名服务器返回 com 域的 sing 机域名服务器地址。\n   * LDNS 向 com 域的顶级域名服务器发起请求，得到 www.baidu.com 的地址。\n   * LONS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址。\n5. LDNS 将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；\n6. 操作系统将 IP 地址返回给浏览器，同时自己也缓存起来；\n\n此时浏览器得到了域名对应的 IP 地址。\n\n### TCP 连接\n\n浏览器根据 IP 地址与服务器建立 socket 连接 。\n\n### 发送 HTTP 请求\n\n1. 浏览器根据 URL 内容生成 HTTP 请求，请求中包含文件的位置，请求文件的方式等。\n2. 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件。\n\n#### http 状态码\n\n1. 200 form memory cache 不访问服务器，直接读缓存 ，此时的缓存是缓存在内存中的，当 kill 进程之后数据就会不存在。这种方式只能缓存派生资源。\n2. 200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存。\n3. 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。200(from cache) 是速度最快的 , 因为不需要访问远程服务器 , 直接使用本地缓存 .304 的过程是 , 先请求服务器 , 然后服务器告诉我们这个资源没变 , 浏览器再使用本地缓存。\n4. 200 from dist cache 不访问服务器，直接度缓存，当进程 kill 时，数据依旧存在。只能缓存派生资源。\n\n![img caption](/images/problem/1.png)\n\n### 浏览器解析渲染页面\n\n现代浏览器渲染页面过程是：解码（字节流到字符流） ——> 分词（此法分析） ——> 解析（语法分析）——> 构建 DOM 树 ——> 构建渲染树 ——> 布局渲染树 ——> 绘制渲染树\n\n### 连接结束\n\n断开连接 --4 次挥手\n\n* 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。\n\n* 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。\n\n## session、cookie、seesionStorage、localStorage 的区别\n\ncookie 和 session 都是用来跟踪浏览器用户身份的会话方式。\n\n### cookie 机制\n\n如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。\n\ncookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。\n\n### session 机制\n\n当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。\n\n### 存储内容\n\ncookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。\n\n### 存储的大小\n\n* cookie:单个 cookie 保存的数据不能超过 4kb;\n* session:大小没有限制。\n\n### sessionStorage\n\n是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。\n\n在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage\n\n非常适合 SPA，可以方便再各业务模块进行传值\n\n### localSotrage\n\nlocalStorage 存储的数据是永久性的。\n## Javascript 的节流和防抖\n\n函数节流和函数防抖，两者都是优化高频率执行 JS 代码的一种手段。\n\n### 函数节流\n\n是指一定时间内 js 方法只跑一次。\n\n函数节流应用的实际场景，多数在监听页面元素滚动时间的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：\n\n```javascript\n//函数节流\nvar canRun = true\ndocument.getElementById('throttle').onsroll = function() {\n  if (!canRun) {\n    //判断是否空闲，如果在执行中，则直接return\n    return\n  }\n  canRun = false\n  setTimeout(function() {\n    console.log('函数节流')\n    canRun = true\n  }, 300)\n}\n```\n\n### 函数防抖\n\n函数防抖的应有场景，最常见的就是用户注册的时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，在弹出提示语。以下还是以页面元素滚动监听的例子，来解析：\n\n```javascript\n//函数防抖\nvar timer = fasle\ndocument.getElementById('document').onsrcoll = function() {\n  clearTimeout(timer).timer = setTimeout(function() {\n    //清楚未执行的代码，重置回初始状态\n    console.log('函数防抖')\n  }, 300)\n}\n```\n\n函数防抖的要点，也是需要一个 setTimeout 来辅助实现。延迟执行需要跑的代码\n\n## html 页面的渲染过程\n\n当用户请求页面时，浏览器获取 HTML 并构造 DOM。然后获取 CSS 并构造 CSSOM。然后通过匹配 DOM 和 CSSDOM 生成渲染树。如果有任何的 javascript 需要解决，浏览器将不会开始渲染页面，知道 javascript 解决完毕。\n","source":"_posts/疑难杂问整理（原生JS）.md","raw":"---\ntitle: 疑难杂问整理（原生JS）\ndate: 2018-01-19 10:12:08\ncategories: 原生JS\n---\n\n在学习原生的过程中的困惑与解惑的总结\n\n<!--more-->\n\n## 工厂模式\n\n```javascript\nfunction createPerson(name, age, job) {\n  var o = new Object()\n  o.name = name\n  o.age = age\n  o.job = job\n  o.sayName = function() {\n    alert(this.name)\n  }\n  return 0\n}\n\nvar person1 = createPerson('Nicholas', 29, 'Software Engineer')\nvar person2 = createPerson('Greg', 27, 'Doctor')\n\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\n```\n\n## 构造函数\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n}\nvar person1 = new Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = new Person('Mick', 23, 'Doctor')\nvar person3 = new Person('Mick', 23, 'Doctor')\nperson1 // Person {name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ}\nperson2 // Person {name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ}\nperson2 === person3 //false\nperson1.constructor == Person //true\nPerson.prototype // {constructor: ƒ}  为原型对象\nperson1.prototype //undefined\nPerson.prototype.prototype //undefined\nperson1.constructor == Person //true\nPerson.prototype.constructor == Person //true\n```\n\n实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性\n\n```javascript\nfunction Person(name, age, job) {\n  this.name = name\n  this.age = age\n  this.job = job\n  this.sayName = function() {\n    alert(this.name)\n  }\n  return this\n}\nvar person1 = Person('Zaxlct', 28, 'Software Engineer')\nvar person2 = Person('Mick', 23, 'Doctor')\nperson1 // this 指向window 且被person2覆盖\nperson2 // this 指向window\n```\n\n**与工厂模式的区别**\n\n* 没有显示创建对象（new 运算符创建并实例化新对象）。\n* 直接将属性和方法赋给了 this 对象。\n* 没有 return 语句。\n* 要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象\n* 可以使用 instanceof 操作符检测对象类型。\n\n构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。\n\n## 跨域\n\n具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。\n\n** 凡是拥有 “src” 这个属性的标签都有跨域的能力**\n\n**如果是协议和端口造成的跨域问题。则前台无法解决。** 同源策略具体分为以下几类：\n\n* 不同域名\n* 相同域名不同端口号，如`https://www.oschina.net:8000`和`https://www.oschina.net:8001`\n* 同一个域名不同协议，如`http://www.oschina.net/`和`https://www.oschina.net/`\n* 域名和域名对应的的 IP，如`http://b.qq.com/`和 `http://10.198.7.85`\n* 主域和子域，如`http://www.oschina.net/`和`https://test.oschina.net`\n* 子域和子域，如`https://test1.oschina.net`和`https://test2.oschina.net` 以上情况只要出现了，那么就会产生跨域问题。那么如果解决跨域问题呢，下面的小节会总结一些解决跨域常用的方法。\n\n### JSONP 带 callback 的 json\n\n有个通俗易懂的解释 -JSONP（JSON with Padding ）是数据格式 JSON 的一种 “ 使用模式 ”，可以让网页从别的网域要数据。利用`<script>`标签没有跨域限制，来达到与第 3 方通讯的目的。\n\n** jsonp 的客户端具体实现：**\n\n1. 远程服务器 remoteserver.com 根目录下有个 remote.js 文件代码如下：\n\n```javascript\nalert('我是远程文件')\n```\n\n2. 本地服务器 localserver.com 下有个 jsonp.html 页面代码如下：\n\n```javascript\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title></title>\n    <script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"></script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n页面将会弹出一个提示窗体，显示跨域调用成功。\n\n3. 现在我们在 jsonp.html 页面定义一个函数，然后在远程 remote.js 中传入数据进行调用。\n\njsonp.html 页面代码如下：\n\n```javascript\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n<head>\n    <title></title>\n    <script type=\"text/javascript\">\n    var localHandler = function(data){\n        alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result);\n    };\n    </script>\n    <script type=\"text/javascript\" src=\"http://remoteserver.com/remote.js\"></script>\n</head>\n<body>\n\n</body>\n</html>\n```\n\n4. remote.js 文件代码如下：\n\n```javascript\nlocalHandler({ result: '我是远程js带来的数据' })\n```\n\n**要注意的是他支持 GET 这一种 HTTP 请求类型**\n\n### 跨域资源共享（CORS-Cross Origin Resource Sharing ）\n\n跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。\n\nCORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。浏览器 CORS 请求分成两种：\n\n1. 简单请求\n2. 协商模型 / 预检请求（Preflighted Request ），即非简单请求如何区分请求具体属于哪一种呢，下面我总结了几点：\n\n   1. 请求方式：\n\n   * GET\n   * HEAD\n   * POST\n\n   2. HTTP 的头信息子段\n\n   * Accept\n   * Accept-Language\n   * Content-Language\n   * Last-Event-ID\n   * Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data 、 text/plain，其中 'text/plain' 默认支持，其他两种则需要预检请求和服务器协商。\n\n满足以上两大点的即为简单请求，否则为非简单请求。\n\n假如站点 http://foo.example 的网页应用想要访问 http://bar.other 的资源。http://foo.example 的网页中可能包含类似于下面的 JavaScript 代码：\n\n```javascript\nvar invocation = new XMLHttpRequest()\nvar url = 'http://bar.other/resources/public-data/'\n\nfunction callOtherDomain() {\n  if (invocation) {\n    invocation.open('GET', url, true)\n    invocation.onreadystatechange = handler\n    invocation.send()\n  }\n}\n```\n\n### document.domain+iframe （适用于主域名相同的情况）\n\n比如，有一个页面，它的地址是http://www.damonare.cn/a.html ， 在这个页面里面有一个 iframe，它的 src 是http://damonare.cn/b.html, 很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的：\n\n```javascript\n<script type=\"text/javascript\">\n    function test(){\n        var iframe = document.getElementById('￼ifame');\n        var win = iframe.contentWindow;//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的\n        var doc = win.document;//这里获取不到iframe里的document对象\n        var name = win.name;//这里同样获取不到window对象的name属性\n    }\n</script>\n<iframe id = \"iframe\" src=\"http://damonare.cn/b.html\" onload = \"test()\"><\\/iframe>\n```\n\n这时只要把http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n\n* 在页面http://www.damonare.cn/a.html 中设置 document.domain:\n\n```javascript\n<iframe id = \"iframe\" src=\"http://damonare.cn/b.html\" onload = \"test()\"></iframe>\n<script type=\"text/javascript\">\n    document.domain = 'damonare.cn';//设置成主域\n    function test(){\n        alert(document.getElementById('￼iframe').contentWindow);//contentWindow 可取得子窗口的 window 对象\n    }\n</script>\n```\n\n* 在页面http://damonare.cn/b.html 中也设置 document.domain:\n\n```javascript\n;<script type=\"text/javascript\">\n  document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同\n</script>\n```\n\n修改 document.domain 的方法只适用于不同子域的框架间的交互。\n\n### 通过 location.hash 跨域\n\n此方法的原理就是改变 URL 的 hash 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息（由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于父窗口域名下的一个代理 iframe），并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，这样做也存在缺点，诸如数据直接暴露在了 url 中，数据容量和类型都有限等。\n\n### 通过 HTML5 的 postMessage 方法跨域\n\n这个功能主要包括接受信息的 ”message” 事件和发送消息的 ”postMessage” 方法。比如http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信\n\nA 页面通过 postMessage 方法发送消息：\n\n```javascript\nwindow.onload = function() {\n  var ifr = document.getElementById('ifr')\n  var targetOrigin = 'http://www.google.com'\n  ifr.contentWindow.postMessage('hello world!', targetOrigin)\n}\n```\n\n**postMessage 的使用方法**\n\notherWindow.postMessage(message, targetOrigin);\n\n* otherWindow: 指目标窗口，也就是给哪个 window 发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口\n* message: 是要发送的消息，类型为 String、Object (IE8 、 9 不支持 )\n* targetOrigin: 是限定消息接收范围，不限制请使用 ‘\\*\n\nB 页面通过 message 事件监听并接受消息 :\n\n```javascript\nvar onmessage = function(event) {\n  var data = event.data //消息\n  var origin = event.origin //消息来源地址\n  var source = event.source //源Window对象\n  if (origin == 'http://www.baidu.com') {\n    console.log(data) //hello world!\n  }\n}\nif (typeof window.addEventListener != 'undefined') {\n  window.addEventListener('message', onmessage, false)\n} else if (typeof window.attachEvent != 'undefined') {\n  //for ie\n  window.attachEvent('onmessage', onmessage)\n}\n```\n\n### 通过 window.name 跨域\n\n在一个窗口生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每一个页面对 window.name 都有读写的权限，window.name 是持久的存在于一个窗口载入的所有页面，并不会因为新的页面的载入而被重置。\n\n下面为 a.html 中代码\n\n```javascript\n<script>\n    window.name = '我是页面a中设置的值';\n    setInterval(function(){\n        window.location = 'b.html';\n    },2000)//两秒后把一个新页面b.html载入到当前的window中\n</script>\n```\n\nb.html 中的代码\n\n```javascript\n;<script>console.log(window.name);//读取window.name的值</script>\n```\n\n## 从输入 URL 到 页面加载发生了什么\n\n发生过程：\n\n* 查看 web 缓存\n* DNS 解析\n* TCP 连接\n* 发送 HTTP 请求\n* 服务器处理请求并返回 HTTP 报文\n* 浏览器解析渲染页面\n* 连接结束\n\n### 查看 web 缓存\n\n三级缓存原理\n\n1. 先去内存中看，如果有，直接加载。\n2. 如果内存没有，这区硬盘获取，如果有直接加载。\n3. 如果硬盘中也没有，那么就进行网络请求。\n4. 加载到的资源缓存到硬盘和内存。\n\n#### 浏览器缓存机制\n\n![img caption](/images/problem/2.png)\n\n##### 当前缓存是否过期。\n\n如果浏览器通过某些条件 ( 条件之后再说 ) 判断出来，ok 现在这个缓存没有过期可以用，那么连请求都不会发的，直接是启用之前浏览器缓存下来的那份文件 (from memory cache). 浏览器直接通过缓存读取了出来，注意这个时候是不会向浏览器请求的！ 如果过期了就会向服务器重新发起请求，但是不一定就会重新拉取文件！\n\n##### 服务器中的文件是否改动。\n\n1. 缓存过期，文件有改动：如果服务器发现这个文件改变了那么你肯定不能再用以前浏览器的缓存了，那就返回个 200 并且带上新的文件。\n\n2. 缓存过期，文件无改动：同时如果发现虽然那个缓存虽然过期了，可你在服务器端的文件没有变过，那么服务器只会给你返回一个头信息 (304)，让你继续用你那过期的缓存，这样就节省了很多传输文件的时间带宽啥的\n\n过期了的缓存需要请求一次服务器，若服务器判断说这个文件没有改变还能用，那就返回 304。浏览器认识 304，它就会去读取过期缓存。否则就真的传一份新文件到浏览器。\n\n### DNS 解析\n\n浏览器查找域名对应的 IP 地址。互联网上每一台计算机的唯一识别是它的 IP 地址，DNS 解析就是讲网址转换为 IP 地址。\n\n查找过程：\n\n1. 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）\n2. 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）\n3. 搜索操作系统的 host 文件（Windows 环境下，维护一张域名与 IP 地址的对应表）\n4. 操作系统间根域名发送至 LDNS（本地域名服务器），首先查找自己的缓存若是失败：\n   * 向根域名服务器发起请求，此处根域名服务器返回 com 域的 sing 机域名服务器地址。\n   * LDNS 向 com 域的顶级域名服务器发起请求，得到 www.baidu.com 的地址。\n   * LONS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址。\n5. LDNS 将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；\n6. 操作系统将 IP 地址返回给浏览器，同时自己也缓存起来；\n\n此时浏览器得到了域名对应的 IP 地址。\n\n### TCP 连接\n\n浏览器根据 IP 地址与服务器建立 socket 连接 。\n\n### 发送 HTTP 请求\n\n1. 浏览器根据 URL 内容生成 HTTP 请求，请求中包含文件的位置，请求文件的方式等。\n2. 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件。\n\n#### http 状态码\n\n1. 200 form memory cache 不访问服务器，直接读缓存 ，此时的缓存是缓存在内存中的，当 kill 进程之后数据就会不存在。这种方式只能缓存派生资源。\n2. 200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存。\n3. 304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。200(from cache) 是速度最快的 , 因为不需要访问远程服务器 , 直接使用本地缓存 .304 的过程是 , 先请求服务器 , 然后服务器告诉我们这个资源没变 , 浏览器再使用本地缓存。\n4. 200 from dist cache 不访问服务器，直接度缓存，当进程 kill 时，数据依旧存在。只能缓存派生资源。\n\n![img caption](/images/problem/1.png)\n\n### 浏览器解析渲染页面\n\n现代浏览器渲染页面过程是：解码（字节流到字符流） ——> 分词（此法分析） ——> 解析（语法分析）——> 构建 DOM 树 ——> 构建渲染树 ——> 布局渲染树 ——> 绘制渲染树\n\n### 连接结束\n\n断开连接 --4 次挥手\n\n* 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。\n\n* 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。\n\n## session、cookie、seesionStorage、localStorage 的区别\n\ncookie 和 session 都是用来跟踪浏览器用户身份的会话方式。\n\n### cookie 机制\n\n如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。\n\ncookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。\n\n### session 机制\n\n当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。\n\n### 存储内容\n\ncookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。\n\n### 存储的大小\n\n* cookie:单个 cookie 保存的数据不能超过 4kb;\n* session:大小没有限制。\n\n### sessionStorage\n\n是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。\n\n在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage\n\n非常适合 SPA，可以方便再各业务模块进行传值\n\n### localSotrage\n\nlocalStorage 存储的数据是永久性的。\n## Javascript 的节流和防抖\n\n函数节流和函数防抖，两者都是优化高频率执行 JS 代码的一种手段。\n\n### 函数节流\n\n是指一定时间内 js 方法只跑一次。\n\n函数节流应用的实际场景，多数在监听页面元素滚动时间的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：\n\n```javascript\n//函数节流\nvar canRun = true\ndocument.getElementById('throttle').onsroll = function() {\n  if (!canRun) {\n    //判断是否空闲，如果在执行中，则直接return\n    return\n  }\n  canRun = false\n  setTimeout(function() {\n    console.log('函数节流')\n    canRun = true\n  }, 300)\n}\n```\n\n### 函数防抖\n\n函数防抖的应有场景，最常见的就是用户注册的时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，在弹出提示语。以下还是以页面元素滚动监听的例子，来解析：\n\n```javascript\n//函数防抖\nvar timer = fasle\ndocument.getElementById('document').onsrcoll = function() {\n  clearTimeout(timer).timer = setTimeout(function() {\n    //清楚未执行的代码，重置回初始状态\n    console.log('函数防抖')\n  }, 300)\n}\n```\n\n函数防抖的要点，也是需要一个 setTimeout 来辅助实现。延迟执行需要跑的代码\n\n## html 页面的渲染过程\n\n当用户请求页面时，浏览器获取 HTML 并构造 DOM。然后获取 CSS 并构造 CSSOM。然后通过匹配 DOM 和 CSSDOM 生成渲染树。如果有任何的 javascript 需要解决，浏览器将不会开始渲染页面，知道 javascript 解决完毕。\n","slug":"疑难杂问整理（原生JS）","published":1,"updated":"2018-03-12T15:29:22.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjepksjoe001b8gv6hvw344oy","content":"<p>在学习原生的过程中的困惑与解惑的总结</p>\n<a id=\"more\"></a>\n<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">  o.name = name</span><br><span class=\"line\">  o.age = age</span><br><span class=\"line\">  o.job = job</span><br><span class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">'Nicholas'</span>, <span class=\"number\">29</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">'Greg'</span>, <span class=\"number\">27</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 === person3 <span class=\"comment\">//false</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype <span class=\"comment\">// &#123;constructor: ƒ&#125;  为原型对象</span></span><br><span class=\"line\">person1.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">Person.prototype.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype.constructor == Person <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// this 指向window 且被person2覆盖</span></span><br><span class=\"line\">person2 <span class=\"comment\">// this 指向window</span></span><br></pre></td></tr></table></figure>\n<p><strong>与工厂模式的区别</strong></p>\n<ul>\n<li>没有显示创建对象（new 运算符创建并实例化新对象）。</li>\n<li>直接将属性和方法赋给了 this 对象。</li>\n<li>没有 return 语句。</li>\n<li>要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象</li>\n<li>可以使用 instanceof 操作符检测对象类型。</li>\n</ul>\n<p>构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>\n<p><strong> 凡是拥有 “src” 这个属性的标签都有跨域的能力</strong></p>\n<p><strong>如果是协议和端口造成的跨域问题。则前台无法解决。</strong> 同源策略具体分为以下几类：</p>\n<ul>\n<li>不同域名</li>\n<li>相同域名不同端口号，如<code>https://www.oschina.net:8000</code>和<code>https://www.oschina.net:8001</code></li>\n<li>同一个域名不同协议，如<code>http://www.oschina.net/</code>和<code>https://www.oschina.net/</code></li>\n<li>域名和域名对应的的 IP，如<code>http://b.qq.com/</code>和 <code>http://10.198.7.85</code></li>\n<li>主域和子域，如<code>http://www.oschina.net/</code>和<code>https://test.oschina.net</code></li>\n<li>子域和子域，如<code>https://test1.oschina.net</code>和<code>https://test2.oschina.net</code> 以上情况只要出现了，那么就会产生跨域问题。那么如果解决跨域问题呢，下面的小节会总结一些解决跨域常用的方法。</li>\n</ul>\n<h3 id=\"JSONP-带-callback-的-json\"><a href=\"#JSONP-带-callback-的-json\" class=\"headerlink\" title=\"JSONP 带 callback 的 json\"></a>JSONP 带 callback 的 json</h3><p>有个通俗易懂的解释 -JSONP（JSON with Padding ）是数据格式 JSON 的一种 “ 使用模式 ”，可以让网页从别的网域要数据。利用<code>&lt;script&gt;</code>标签没有跨域限制，来达到与第 3 方通讯的目的。</p>\n<p><strong> jsonp 的客户端具体实现：</strong></p>\n<ol>\n<li>远程服务器 remoteserver.com 根目录下有个 remote.js 文件代码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"string\">'我是远程文件'</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>本地服务器 localserver.com 下有个 jsonp.html 页面代码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html PUBLIC <span class=\"string\">\"-//W3C//DTD XHTML 1.0 Transitional//EN\"</span> <span class=\"string\">\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;html xmlns=<span class=\"string\">\"http://www.w3.org/1999/xhtml\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\">    &lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"http://remoteserver.com/remote.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n<p>页面将会弹出一个提示窗体，显示跨域调用成功。</p>\n<ol>\n<li>现在我们在 jsonp.html 页面定义一个函数，然后在远程 remote.js 中传入数据进行调用。</li>\n</ol>\n<p>jsonp.html 页面代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html PUBLIC <span class=\"string\">\"-//W3C//DTD XHTML 1.0 Transitional//EN\"</span> <span class=\"string\">\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;html xmlns=<span class=\"string\">\"http://www.w3.org/1999/xhtml\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\">    &lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> localHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">'我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：'</span> + data.result);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;script type=\"text/</span>javascript<span class=\"string\">\" src=\"</span>http:<span class=\"comment\">//remoteserver.com/remote.js\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>remote.js 文件代码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localHandler(&#123; <span class=\"attr\">result</span>: <span class=\"string\">'我是远程js带来的数据'</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>要注意的是他支持 GET 这一种 HTTP 请求类型</strong></p>\n<h3 id=\"跨域资源共享（CORS-Cross-Origin-Resource-Sharing-）\"><a href=\"#跨域资源共享（CORS-Cross-Origin-Resource-Sharing-）\" class=\"headerlink\" title=\"跨域资源共享（CORS-Cross Origin Resource Sharing ）\"></a>跨域资源共享（CORS-Cross Origin Resource Sharing ）</h3><p>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。浏览器 CORS 请求分成两种：</p>\n<ol>\n<li>简单请求</li>\n<li><p>协商模型 / 预检请求（Preflighted Request ），即非简单请求如何区分请求具体属于哪一种呢，下面我总结了几点：</p>\n<ol>\n<li>请求方式：</li>\n</ol>\n<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n<ol>\n<li>HTTP 的头信息子段</li>\n</ol>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data 、 text/plain，其中 ‘text/plain’ 默认支持，其他两种则需要预检请求和服务器协商。</li>\n</ul>\n</li>\n</ol>\n<p>满足以上两大点的即为简单请求，否则为非简单请求。</p>\n<p>假如站点 <a href=\"http://foo.example\" target=\"_blank\" rel=\"noopener\">http://foo.example</a> 的网页应用想要访问 <a href=\"http://bar.other\" target=\"_blank\" rel=\"noopener\">http://bar.other</a> 的资源。<a href=\"http://foo.example\" target=\"_blank\" rel=\"noopener\">http://foo.example</a> 的网页中可能包含类似于下面的 JavaScript 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> invocation = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://bar.other/resources/public-data/'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callOtherDomain</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (invocation) &#123;</span><br><span class=\"line\">    invocation.open(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    invocation.onreadystatechange = handler</span><br><span class=\"line\">    invocation.send()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"document-domain-iframe-（适用于主域名相同的情况）\"><a href=\"#document-domain-iframe-（适用于主域名相同的情况）\" class=\"headerlink\" title=\"document.domain+iframe （适用于主域名相同的情况）\"></a>document.domain+iframe （适用于主域名相同的情况）</h3><p>比如，有一个页面，它的地址是<a href=\"http://www.damonare.cn/a.html\" target=\"_blank\" rel=\"noopener\">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个 iframe，它的 src 是<a href=\"http://damonare.cn/b.html\" target=\"_blank\" rel=\"noopener\">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'￼ifame'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> win = iframe.contentWindow;<span class=\"comment\">//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> doc = win.document;<span class=\"comment\">//这里获取不到iframe里的document对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = win.name;<span class=\"comment\">//这里同样获取不到window对象的name属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;iframe id = \"iframe\" src=\"http:/</span><span class=\"regexp\">/damonare.cn/</span>b.html<span class=\"string\">\" onload = \"</span>test()<span class=\"string\">\"&gt;&lt;\\/iframe&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这时只要把<a href=\"http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\" target=\"_blank\" rel=\"noopener\">http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>\n<ul>\n<li>在页面<a href=\"http://www.damonare.cn/a.html\" target=\"_blank\" rel=\"noopener\">http://www.damonare.cn/a.html</a> 中设置 document.domain:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe id = <span class=\"string\">\"iframe\"</span> src=<span class=\"string\">\"http://damonare.cn/b.html\"</span> onload = <span class=\"string\">\"test()\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.domain = <span class=\"string\">'damonare.cn'</span>;<span class=\"comment\">//设置成主域</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'￼iframe'</span>).contentWindow);<span class=\"comment\">//contentWindow 可取得子窗口的 window 对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在页面<a href=\"http://damonare.cn/b.html\" target=\"_blank\" rel=\"noopener\">http://damonare.cn/b.html</a> 中也设置 document.domain:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"xml\">  document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>修改 document.domain 的方法只适用于不同子域的框架间的交互。</p>\n<h3 id=\"通过-location-hash-跨域\"><a href=\"#通过-location-hash-跨域\" class=\"headerlink\" title=\"通过 location.hash 跨域\"></a>通过 location.hash 跨域</h3><p>此方法的原理就是改变 URL 的 hash 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息（由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于父窗口域名下的一个代理 iframe），并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，这样做也存在缺点，诸如数据直接暴露在了 url 中，数据容量和类型都有限等。</p>\n<h3 id=\"通过-HTML5-的-postMessage-方法跨域\"><a href=\"#通过-HTML5-的-postMessage-方法跨域\" class=\"headerlink\" title=\"通过 HTML5 的 postMessage 方法跨域\"></a>通过 HTML5 的 postMessage 方法跨域</h3><p>这个功能主要包括接受信息的 ”message” 事件和发送消息的 ”postMessage” 方法。比如<a href=\"http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信\" target=\"_blank\" rel=\"noopener\">http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信</a></p>\n<p>A 页面通过 postMessage 方法发送消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ifr = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'ifr'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> targetOrigin = <span class=\"string\">'http://www.google.com'</span></span><br><span class=\"line\">  ifr.contentWindow.postMessage(<span class=\"string\">'hello world!'</span>, targetOrigin)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>postMessage 的使用方法</strong></p>\n<p>otherWindow.postMessage(message, targetOrigin);</p>\n<ul>\n<li>otherWindow: 指目标窗口，也就是给哪个 window 发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>\n<li>message: 是要发送的消息，类型为 String、Object (IE8 、 9 不支持 )</li>\n<li>targetOrigin: 是限定消息接收范围，不限制请使用 ‘*</li>\n</ul>\n<p>B 页面通过 message 事件监听并接受消息 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = event.data <span class=\"comment\">//消息</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin = event.origin <span class=\"comment\">//消息来源地址</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> source = event.source <span class=\"comment\">//源Window对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (origin == <span class=\"string\">'http://www.baidu.com'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data) <span class=\"comment\">//hello world!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.addEventListener != <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, onmessage, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.attachEvent != <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//for ie</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.attachEvent(<span class=\"string\">'onmessage'</span>, onmessage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-window-name-跨域\"><a href=\"#通过-window-name-跨域\" class=\"headerlink\" title=\"通过 window.name 跨域\"></a>通过 window.name 跨域</h3><p>在一个窗口生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每一个页面对 window.name 都有读写的权限，window.name 是持久的存在于一个窗口载入的所有页面，并不会因为新的页面的载入而被重置。</p>\n<p>下面为 a.html 中代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.name = <span class=\"string\">'我是页面a中设置的值'</span>;</span><br><span class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.location = <span class=\"string\">'b.html'</span>;</span><br><span class=\"line\">    &#125;,<span class=\"number\">2000</span>)<span class=\"comment\">//两秒后把一个新页面b.html载入到当前的window中</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>b.html 中的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.name);<span class=\"comment\">//读取window.name的值</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从输入-URL-到-页面加载发生了什么\"><a href=\"#从输入-URL-到-页面加载发生了什么\" class=\"headerlink\" title=\"从输入 URL 到 页面加载发生了什么\"></a>从输入 URL 到 页面加载发生了什么</h2><p>发生过程：</p>\n<ul>\n<li>查看 web 缓存</li>\n<li>DNS 解析</li>\n<li>TCP 连接</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束</li>\n</ul>\n<h3 id=\"查看-web-缓存\"><a href=\"#查看-web-缓存\" class=\"headerlink\" title=\"查看 web 缓存\"></a>查看 web 缓存</h3><p>三级缓存原理</p>\n<ol>\n<li>先去内存中看，如果有，直接加载。</li>\n<li>如果内存没有，这区硬盘获取，如果有直接加载。</li>\n<li>如果硬盘中也没有，那么就进行网络请求。</li>\n<li>加载到的资源缓存到硬盘和内存。</li>\n</ol>\n<h4 id=\"浏览器缓存机制\"><a href=\"#浏览器缓存机制\" class=\"headerlink\" title=\"浏览器缓存机制\"></a>浏览器缓存机制</h4><p><img src=\"/images/problem/2.png\" alt=\"img caption\"></p>\n<h5 id=\"当前缓存是否过期。\"><a href=\"#当前缓存是否过期。\" class=\"headerlink\" title=\"当前缓存是否过期。\"></a>当前缓存是否过期。</h5><p>如果浏览器通过某些条件 ( 条件之后再说 ) 判断出来，ok 现在这个缓存没有过期可以用，那么连请求都不会发的，直接是启用之前浏览器缓存下来的那份文件 (from memory cache). 浏览器直接通过缓存读取了出来，注意这个时候是不会向浏览器请求的！ 如果过期了就会向服务器重新发起请求，但是不一定就会重新拉取文件！</p>\n<h5 id=\"服务器中的文件是否改动。\"><a href=\"#服务器中的文件是否改动。\" class=\"headerlink\" title=\"服务器中的文件是否改动。\"></a>服务器中的文件是否改动。</h5><ol>\n<li><p>缓存过期，文件有改动：如果服务器发现这个文件改变了那么你肯定不能再用以前浏览器的缓存了，那就返回个 200 并且带上新的文件。</p>\n</li>\n<li><p>缓存过期，文件无改动：同时如果发现虽然那个缓存虽然过期了，可你在服务器端的文件没有变过，那么服务器只会给你返回一个头信息 (304)，让你继续用你那过期的缓存，这样就节省了很多传输文件的时间带宽啥的</p>\n</li>\n</ol>\n<p>过期了的缓存需要请求一次服务器，若服务器判断说这个文件没有改变还能用，那就返回 304。浏览器认识 304，它就会去读取过期缓存。否则就真的传一份新文件到浏览器。</p>\n<h3 id=\"DNS-解析\"><a href=\"#DNS-解析\" class=\"headerlink\" title=\"DNS 解析\"></a>DNS 解析</h3><p>浏览器查找域名对应的 IP 地址。互联网上每一台计算机的唯一识别是它的 IP 地址，DNS 解析就是讲网址转换为 IP 地址。</p>\n<p>查找过程：</p>\n<ol>\n<li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）</li>\n<li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）</li>\n<li>搜索操作系统的 host 文件（Windows 环境下，维护一张域名与 IP 地址的对应表）</li>\n<li>操作系统间根域名发送至 LDNS（本地域名服务器），首先查找自己的缓存若是失败：<ul>\n<li>向根域名服务器发起请求，此处根域名服务器返回 com 域的 sing 机域名服务器地址。</li>\n<li>LDNS 向 com 域的顶级域名服务器发起请求，得到 www.baidu.com 的地址。</li>\n<li>LONS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址。</li>\n</ul>\n</li>\n<li>LDNS 将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；</li>\n<li>操作系统将 IP 地址返回给浏览器，同时自己也缓存起来；</li>\n</ol>\n<p>此时浏览器得到了域名对应的 IP 地址。</p>\n<h3 id=\"TCP-连接\"><a href=\"#TCP-连接\" class=\"headerlink\" title=\"TCP 连接\"></a>TCP 连接</h3><p>浏览器根据 IP 地址与服务器建立 socket 连接 。</p>\n<h3 id=\"发送-HTTP-请求\"><a href=\"#发送-HTTP-请求\" class=\"headerlink\" title=\"发送 HTTP 请求\"></a>发送 HTTP 请求</h3><ol>\n<li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含文件的位置，请求文件的方式等。</li>\n<li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件。</li>\n</ol>\n<h4 id=\"http-状态码\"><a href=\"#http-状态码\" class=\"headerlink\" title=\"http 状态码\"></a>http 状态码</h4><ol>\n<li>200 form memory cache 不访问服务器，直接读缓存 ，此时的缓存是缓存在内存中的，当 kill 进程之后数据就会不存在。这种方式只能缓存派生资源。</li>\n<li>200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存。</li>\n<li>304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。200(from cache) 是速度最快的 , 因为不需要访问远程服务器 , 直接使用本地缓存 .304 的过程是 , 先请求服务器 , 然后服务器告诉我们这个资源没变 , 浏览器再使用本地缓存。</li>\n<li>200 from dist cache 不访问服务器，直接度缓存，当进程 kill 时，数据依旧存在。只能缓存派生资源。</li>\n</ol>\n<p><img src=\"/images/problem/1.png\" alt=\"img caption\"></p>\n<h3 id=\"浏览器解析渲染页面\"><a href=\"#浏览器解析渲染页面\" class=\"headerlink\" title=\"浏览器解析渲染页面\"></a>浏览器解析渲染页面</h3><p>现代浏览器渲染页面过程是：解码（字节流到字符流） ——&gt; 分词（此法分析） ——&gt; 解析（语法分析）——&gt; 构建 DOM 树 ——&gt; 构建渲染树 ——&gt; 布局渲染树 ——&gt; 绘制渲染树</p>\n<h3 id=\"连接结束\"><a href=\"#连接结束\" class=\"headerlink\" title=\"连接结束\"></a>连接结束</h3><p>断开连接 –4 次挥手</p>\n<ul>\n<li><p>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。</p>\n</li>\n<li><p>第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。</p>\n</li>\n</ul>\n<h2 id=\"session、cookie、seesionStorage、localStorage-的区别\"><a href=\"#session、cookie、seesionStorage、localStorage-的区别\" class=\"headerlink\" title=\"session、cookie、seesionStorage、localStorage 的区别\"></a>session、cookie、seesionStorage、localStorage 的区别</h2><p>cookie 和 session 都是用来跟踪浏览器用户身份的会话方式。</p>\n<h3 id=\"cookie-机制\"><a href=\"#cookie-机制\" class=\"headerlink\" title=\"cookie 机制\"></a>cookie 机制</h3><p>如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。</p>\n<p>cookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。</p>\n<h3 id=\"session-机制\"><a href=\"#session-机制\" class=\"headerlink\" title=\"session 机制\"></a>session 机制</h3><p>当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。</p>\n<h3 id=\"存储内容\"><a href=\"#存储内容\" class=\"headerlink\" title=\"存储内容\"></a>存储内容</h3><p>cookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。</p>\n<h3 id=\"存储的大小\"><a href=\"#存储的大小\" class=\"headerlink\" title=\"存储的大小\"></a>存储的大小</h3><ul>\n<li>cookie:单个 cookie 保存的数据不能超过 4kb;</li>\n<li>session:大小没有限制。</li>\n</ul>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。</p>\n<p>在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage</p>\n<p>非常适合 SPA，可以方便再各业务模块进行传值</p>\n<h3 id=\"localSotrage\"><a href=\"#localSotrage\" class=\"headerlink\" title=\"localSotrage\"></a>localSotrage</h3><p>localStorage 存储的数据是永久性的。</p>\n<h2 id=\"Javascript-的节流和防抖\"><a href=\"#Javascript-的节流和防抖\" class=\"headerlink\" title=\"Javascript 的节流和防抖\"></a>Javascript 的节流和防抖</h2><p>函数节流和函数防抖，两者都是优化高频率执行 JS 代码的一种手段。</p>\n<h3 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h3><p>是指一定时间内 js 方法只跑一次。</p>\n<p>函数节流应用的实际场景，多数在监听页面元素滚动时间的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数节流</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'throttle'</span>).onsroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!canRun) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否空闲，如果在执行中，则直接return</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  canRun = <span class=\"literal\">false</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'函数节流'</span>)</span><br><span class=\"line\">    canRun = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">300</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h3><p>函数防抖的应有场景，最常见的就是用户注册的时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，在弹出提示语。以下还是以页面元素滚动监听的例子，来解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数防抖</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> timer = fasle</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'document'</span>).onsrcoll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  clearTimeout(timer).timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//清楚未执行的代码，重置回初始状态</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'函数防抖'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">300</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数防抖的要点，也是需要一个 setTimeout 来辅助实现。延迟执行需要跑的代码</p>\n<h2 id=\"html-页面的渲染过程\"><a href=\"#html-页面的渲染过程\" class=\"headerlink\" title=\"html 页面的渲染过程\"></a>html 页面的渲染过程</h2><p>当用户请求页面时，浏览器获取 HTML 并构造 DOM。然后获取 CSS 并构造 CSSOM。然后通过匹配 DOM 和 CSSDOM 生成渲染树。如果有任何的 javascript 需要解决，浏览器将不会开始渲染页面，知道 javascript 解决完毕。</p>\n","site":{"data":{}},"excerpt":"<p>在学习原生的过程中的困惑与解惑的总结</p>","more":"<h2 id=\"工厂模式\"><a href=\"#工厂模式\" class=\"headerlink\" title=\"工厂模式\"></a>工厂模式</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createPerson</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> o = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>()</span><br><span class=\"line\">  o.name = name</span><br><span class=\"line\">  o.age = age</span><br><span class=\"line\">  o.job = job</span><br><span class=\"line\">  o.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = createPerson(<span class=\"string\">'Nicholas'</span>, <span class=\"number\">29</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = createPerson(<span class=\"string\">'Greg'</span>, <span class=\"number\">27</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person3 = <span class=\"keyword\">new</span> Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// Person &#123;name: \"Zaxlct\", age: 28, job: \"Software Engineer\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 <span class=\"comment\">// Person &#123;name: \"Mick\", age: 23, job: \"Doctor\", sayName: ƒ&#125;</span></span><br><span class=\"line\">person2 === person3 <span class=\"comment\">//false</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype <span class=\"comment\">// &#123;constructor: ƒ&#125;  为原型对象</span></span><br><span class=\"line\">person1.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">Person.prototype.prototype <span class=\"comment\">//undefined</span></span><br><span class=\"line\">person1.constructor == Person <span class=\"comment\">//true</span></span><br><span class=\"line\">Person.prototype.constructor == Person <span class=\"comment\">//true</span></span><br></pre></td></tr></table></figure>\n<p>实例的构造函数属性（constructor ）指向构造函数。所有的原型对象都会自动获得一个 constructor （构造函数属性）属性</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\">name, age, job</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.job = job</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.sayName = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    alert(<span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> person1 = Person(<span class=\"string\">'Zaxlct'</span>, <span class=\"number\">28</span>, <span class=\"string\">'Software Engineer'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> person2 = Person(<span class=\"string\">'Mick'</span>, <span class=\"number\">23</span>, <span class=\"string\">'Doctor'</span>)</span><br><span class=\"line\">person1 <span class=\"comment\">// this 指向window 且被person2覆盖</span></span><br><span class=\"line\">person2 <span class=\"comment\">// this 指向window</span></span><br></pre></td></tr></table></figure>\n<p><strong>与工厂模式的区别</strong></p>\n<ul>\n<li>没有显示创建对象（new 运算符创建并实例化新对象）。</li>\n<li>直接将属性和方法赋给了 this 对象。</li>\n<li>没有 return 语句。</li>\n<li>要创建新实例必须要使用 new 运算符，否者属性和方法将会被添加到 window 对象</li>\n<li>可以使用 instanceof 操作符检测对象类型。</li>\n</ul>\n<p>构造函数的问题：构造函数的内部方法会被重复构建，不同实例内的同名函数是不相等的。</p>\n<h2 id=\"跨域\"><a href=\"#跨域\" class=\"headerlink\" title=\"跨域\"></a>跨域</h2><p>具体概念如下：只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p>\n<p><strong> 凡是拥有 “src” 这个属性的标签都有跨域的能力</strong></p>\n<p><strong>如果是协议和端口造成的跨域问题。则前台无法解决。</strong> 同源策略具体分为以下几类：</p>\n<ul>\n<li>不同域名</li>\n<li>相同域名不同端口号，如<code>https://www.oschina.net:8000</code>和<code>https://www.oschina.net:8001</code></li>\n<li>同一个域名不同协议，如<code>http://www.oschina.net/</code>和<code>https://www.oschina.net/</code></li>\n<li>域名和域名对应的的 IP，如<code>http://b.qq.com/</code>和 <code>http://10.198.7.85</code></li>\n<li>主域和子域，如<code>http://www.oschina.net/</code>和<code>https://test.oschina.net</code></li>\n<li>子域和子域，如<code>https://test1.oschina.net</code>和<code>https://test2.oschina.net</code> 以上情况只要出现了，那么就会产生跨域问题。那么如果解决跨域问题呢，下面的小节会总结一些解决跨域常用的方法。</li>\n</ul>\n<h3 id=\"JSONP-带-callback-的-json\"><a href=\"#JSONP-带-callback-的-json\" class=\"headerlink\" title=\"JSONP 带 callback 的 json\"></a>JSONP 带 callback 的 json</h3><p>有个通俗易懂的解释 -JSONP（JSON with Padding ）是数据格式 JSON 的一种 “ 使用模式 ”，可以让网页从别的网域要数据。利用<code>&lt;script&gt;</code>标签没有跨域限制，来达到与第 3 方通讯的目的。</p>\n<p><strong> jsonp 的客户端具体实现：</strong></p>\n<ol>\n<li>远程服务器 remoteserver.com 根目录下有个 remote.js 文件代码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">alert(<span class=\"string\">'我是远程文件'</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>本地服务器 localserver.com 下有个 jsonp.html 页面代码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html PUBLIC <span class=\"string\">\"-//W3C//DTD XHTML 1.0 Transitional//EN\"</span> <span class=\"string\">\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;html xmlns=<span class=\"string\">\"http://www.w3.org/1999/xhtml\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\">    &lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">\"http://remoteserver.com/remote.js\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n<p>页面将会弹出一个提示窗体，显示跨域调用成功。</p>\n<ol>\n<li>现在我们在 jsonp.html 页面定义一个函数，然后在远程 remote.js 中传入数据进行调用。</li>\n</ol>\n<p>jsonp.html 页面代码如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html PUBLIC <span class=\"string\">\"-//W3C//DTD XHTML 1.0 Transitional//EN\"</span> <span class=\"string\">\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"</span>&gt;</span><br><span class=\"line\">&lt;html xmlns=<span class=\"string\">\"http://www.w3.org/1999/xhtml\"</span>&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">    &lt;title&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span></span><br><span class=\"line\">    &lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> localHandler = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"string\">'我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：'</span> + data.result);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    &lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">    &lt;script type=\"text/</span>javascript<span class=\"string\">\" src=\"</span>http:<span class=\"comment\">//remoteserver.com/remote.js\"&gt;&lt;/script&gt;</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/head&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;body&gt;</span></span><br><span class=\"line\"><span class=\"regexp\"></span></span><br><span class=\"line\"><span class=\"regexp\">&lt;/</span>body&gt;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/html&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>remote.js 文件代码如下：</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">localHandler(&#123; <span class=\"attr\">result</span>: <span class=\"string\">'我是远程js带来的数据'</span> &#125;)</span><br></pre></td></tr></table></figure>\n<p><strong>要注意的是他支持 GET 这一种 HTTP 请求类型</strong></p>\n<h3 id=\"跨域资源共享（CORS-Cross-Origin-Resource-Sharing-）\"><a href=\"#跨域资源共享（CORS-Cross-Origin-Resource-Sharing-）\" class=\"headerlink\" title=\"跨域资源共享（CORS-Cross Origin Resource Sharing ）\"></a>跨域资源共享（CORS-Cross Origin Resource Sharing ）</h3><p>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。</p>\n<p>CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。浏览器 CORS 请求分成两种：</p>\n<ol>\n<li>简单请求</li>\n<li><p>协商模型 / 预检请求（Preflighted Request ），即非简单请求如何区分请求具体属于哪一种呢，下面我总结了几点：</p>\n<ol>\n<li>请求方式：</li>\n</ol>\n<ul>\n<li>GET</li>\n<li>HEAD</li>\n<li>POST</li>\n</ul>\n<ol>\n<li>HTTP 的头信息子段</li>\n</ol>\n<ul>\n<li>Accept</li>\n<li>Accept-Language</li>\n<li>Content-Language</li>\n<li>Last-Event-ID</li>\n<li>Content-Type：只限于三个值 application/x-www-form-urlencoded、multipart/form-data 、 text/plain，其中 ‘text/plain’ 默认支持，其他两种则需要预检请求和服务器协商。</li>\n</ul>\n</li>\n</ol>\n<p>满足以上两大点的即为简单请求，否则为非简单请求。</p>\n<p>假如站点 <a href=\"http://foo.example\" target=\"_blank\" rel=\"noopener\">http://foo.example</a> 的网页应用想要访问 <a href=\"http://bar.other\" target=\"_blank\" rel=\"noopener\">http://bar.other</a> 的资源。<a href=\"http://foo.example\" target=\"_blank\" rel=\"noopener\">http://foo.example</a> 的网页中可能包含类似于下面的 JavaScript 代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> invocation = <span class=\"keyword\">new</span> XMLHttpRequest()</span><br><span class=\"line\"><span class=\"keyword\">var</span> url = <span class=\"string\">'http://bar.other/resources/public-data/'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">callOtherDomain</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (invocation) &#123;</span><br><span class=\"line\">    invocation.open(<span class=\"string\">'GET'</span>, url, <span class=\"literal\">true</span>)</span><br><span class=\"line\">    invocation.onreadystatechange = handler</span><br><span class=\"line\">    invocation.send()</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"document-domain-iframe-（适用于主域名相同的情况）\"><a href=\"#document-domain-iframe-（适用于主域名相同的情况）\" class=\"headerlink\" title=\"document.domain+iframe （适用于主域名相同的情况）\"></a>document.domain+iframe （适用于主域名相同的情况）</h3><p>比如，有一个页面，它的地址是<a href=\"http://www.damonare.cn/a.html\" target=\"_blank\" rel=\"noopener\">http://www.damonare.cn/a.html</a> ， 在这个页面里面有一个 iframe，它的 src 是<a href=\"http://damonare.cn/b.html\" target=\"_blank\" rel=\"noopener\">http://damonare.cn/b.html</a>, 很显然，这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> iframe = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'￼ifame'</span>);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> win = iframe.contentWindow;<span class=\"comment\">//可以获取到iframe里的window对象，但该window对象的属性和方法几乎是不可用的</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> doc = win.document;<span class=\"comment\">//这里获取不到iframe里的document对象</span></span><br><span class=\"line\">        <span class=\"keyword\">var</span> name = win.name;<span class=\"comment\">//这里同样获取不到window对象的name属性</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br><span class=\"line\"><span class=\"regexp\">&lt;iframe id = \"iframe\" src=\"http:/</span><span class=\"regexp\">/damonare.cn/</span>b.html<span class=\"string\">\" onload = \"</span>test()<span class=\"string\">\"&gt;&lt;\\/iframe&gt;</span></span><br></pre></td></tr></table></figure>\n<p>这时只要把<a href=\"http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\" target=\"_blank\" rel=\"noopener\">http://www.damonare.cn/a.html和http://damonare.cn/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a></p>\n<ul>\n<li>在页面<a href=\"http://www.damonare.cn/a.html\" target=\"_blank\" rel=\"noopener\">http://www.damonare.cn/a.html</a> 中设置 document.domain:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;iframe id = <span class=\"string\">\"iframe\"</span> src=<span class=\"string\">\"http://damonare.cn/b.html\"</span> onload = <span class=\"string\">\"test()\"</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">iframe</span>&gt;</span></span></span><br><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">    <span class=\"built_in\">document</span>.domain = <span class=\"string\">'damonare.cn'</span>;<span class=\"comment\">//设置成主域</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        alert(<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'￼iframe'</span>).contentWindow);<span class=\"comment\">//contentWindow 可取得子窗口的 window 对象</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>在页面<a href=\"http://damonare.cn/b.html\" target=\"_blank\" rel=\"noopener\">http://damonare.cn/b.html</a> 中也设置 document.domain:</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/javascript\"</span>&gt;</span><span class=\"undefined\"></span></span></span><br><span class=\"line\"><span class=\"xml\">  document.domain = 'damonare.cn';//在iframe载入这个页面也设置document.domain，使之与主页面的document.domain相同</span></span><br><span class=\"line\"><span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<p>修改 document.domain 的方法只适用于不同子域的框架间的交互。</p>\n<h3 id=\"通过-location-hash-跨域\"><a href=\"#通过-location-hash-跨域\" class=\"headerlink\" title=\"通过 location.hash 跨域\"></a>通过 location.hash 跨域</h3><p>此方法的原理就是改变 URL 的 hash 部分来进行双向通信。每个 window 通过改变其他 window 的 location 来发送消息（由于两个页面不在同一个域下 IE、Chrome 不允许修改 parent.location.hash 的值，所以要借助于父窗口域名下的一个代理 iframe），并通过监听自己的 URL 的变化来接收消息。这个方式的通信会造成一些不必要的浏览器历史记录，而且有些浏览器不支持 onhashchange 事件，需要轮询来获知 URL 的改变，最后，这样做也存在缺点，诸如数据直接暴露在了 url 中，数据容量和类型都有限等。</p>\n<h3 id=\"通过-HTML5-的-postMessage-方法跨域\"><a href=\"#通过-HTML5-的-postMessage-方法跨域\" class=\"headerlink\" title=\"通过 HTML5 的 postMessage 方法跨域\"></a>通过 HTML5 的 postMessage 方法跨域</h3><p>这个功能主要包括接受信息的 ”message” 事件和发送消息的 ”postMessage” 方法。比如<a href=\"http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信\" target=\"_blank\" rel=\"noopener\">http://damonare.cn域的A页面通过iframe嵌入了一个http://google.com域的B页面，可以通过以下方法实现A和B的通信</a></p>\n<p>A 页面通过 postMessage 方法发送消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> ifr = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'ifr'</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> targetOrigin = <span class=\"string\">'http://www.google.com'</span></span><br><span class=\"line\">  ifr.contentWindow.postMessage(<span class=\"string\">'hello world!'</span>, targetOrigin)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>postMessage 的使用方法</strong></p>\n<p>otherWindow.postMessage(message, targetOrigin);</p>\n<ul>\n<li>otherWindow: 指目标窗口，也就是给哪个 window 发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口</li>\n<li>message: 是要发送的消息，类型为 String、Object (IE8 、 9 不支持 )</li>\n<li>targetOrigin: 是限定消息接收范围，不限制请使用 ‘*</li>\n</ul>\n<p>B 页面通过 message 事件监听并接受消息 :</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> onmessage = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> data = event.data <span class=\"comment\">//消息</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin = event.origin <span class=\"comment\">//消息来源地址</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> source = event.source <span class=\"comment\">//源Window对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (origin == <span class=\"string\">'http://www.baidu.com'</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(data) <span class=\"comment\">//hello world!</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.addEventListener != <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'message'</span>, onmessage, <span class=\"literal\">false</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span>.attachEvent != <span class=\"string\">'undefined'</span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">//for ie</span></span><br><span class=\"line\">  <span class=\"built_in\">window</span>.attachEvent(<span class=\"string\">'onmessage'</span>, onmessage)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"通过-window-name-跨域\"><a href=\"#通过-window-name-跨域\" class=\"headerlink\" title=\"通过 window.name 跨域\"></a>通过 window.name 跨域</h3><p>在一个窗口生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每一个页面对 window.name 都有读写的权限，window.name 是持久的存在于一个窗口载入的所有页面，并不会因为新的页面的载入而被重置。</p>\n<p>下面为 a.html 中代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.name = <span class=\"string\">'我是页面a中设置的值'</span>;</span><br><span class=\"line\">    setInterval(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.location = <span class=\"string\">'b.html'</span>;</span><br><span class=\"line\">    &#125;,<span class=\"number\">2000</span>)<span class=\"comment\">//两秒后把一个新页面b.html载入到当前的window中</span></span><br><span class=\"line\">&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>b.html 中的代码</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"javascript\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">window</span>.name);<span class=\"comment\">//读取window.name的值</span></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>\n<h2 id=\"从输入-URL-到-页面加载发生了什么\"><a href=\"#从输入-URL-到-页面加载发生了什么\" class=\"headerlink\" title=\"从输入 URL 到 页面加载发生了什么\"></a>从输入 URL 到 页面加载发生了什么</h2><p>发生过程：</p>\n<ul>\n<li>查看 web 缓存</li>\n<li>DNS 解析</li>\n<li>TCP 连接</li>\n<li>发送 HTTP 请求</li>\n<li>服务器处理请求并返回 HTTP 报文</li>\n<li>浏览器解析渲染页面</li>\n<li>连接结束</li>\n</ul>\n<h3 id=\"查看-web-缓存\"><a href=\"#查看-web-缓存\" class=\"headerlink\" title=\"查看 web 缓存\"></a>查看 web 缓存</h3><p>三级缓存原理</p>\n<ol>\n<li>先去内存中看，如果有，直接加载。</li>\n<li>如果内存没有，这区硬盘获取，如果有直接加载。</li>\n<li>如果硬盘中也没有，那么就进行网络请求。</li>\n<li>加载到的资源缓存到硬盘和内存。</li>\n</ol>\n<h4 id=\"浏览器缓存机制\"><a href=\"#浏览器缓存机制\" class=\"headerlink\" title=\"浏览器缓存机制\"></a>浏览器缓存机制</h4><p><img src=\"/images/problem/2.png\" alt=\"img caption\"></p>\n<h5 id=\"当前缓存是否过期。\"><a href=\"#当前缓存是否过期。\" class=\"headerlink\" title=\"当前缓存是否过期。\"></a>当前缓存是否过期。</h5><p>如果浏览器通过某些条件 ( 条件之后再说 ) 判断出来，ok 现在这个缓存没有过期可以用，那么连请求都不会发的，直接是启用之前浏览器缓存下来的那份文件 (from memory cache). 浏览器直接通过缓存读取了出来，注意这个时候是不会向浏览器请求的！ 如果过期了就会向服务器重新发起请求，但是不一定就会重新拉取文件！</p>\n<h5 id=\"服务器中的文件是否改动。\"><a href=\"#服务器中的文件是否改动。\" class=\"headerlink\" title=\"服务器中的文件是否改动。\"></a>服务器中的文件是否改动。</h5><ol>\n<li><p>缓存过期，文件有改动：如果服务器发现这个文件改变了那么你肯定不能再用以前浏览器的缓存了，那就返回个 200 并且带上新的文件。</p>\n</li>\n<li><p>缓存过期，文件无改动：同时如果发现虽然那个缓存虽然过期了，可你在服务器端的文件没有变过，那么服务器只会给你返回一个头信息 (304)，让你继续用你那过期的缓存，这样就节省了很多传输文件的时间带宽啥的</p>\n</li>\n</ol>\n<p>过期了的缓存需要请求一次服务器，若服务器判断说这个文件没有改变还能用，那就返回 304。浏览器认识 304，它就会去读取过期缓存。否则就真的传一份新文件到浏览器。</p>\n<h3 id=\"DNS-解析\"><a href=\"#DNS-解析\" class=\"headerlink\" title=\"DNS 解析\"></a>DNS 解析</h3><p>浏览器查找域名对应的 IP 地址。互联网上每一台计算机的唯一识别是它的 IP 地址，DNS 解析就是讲网址转换为 IP 地址。</p>\n<p>查找过程：</p>\n<ol>\n<li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）</li>\n<li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）</li>\n<li>搜索操作系统的 host 文件（Windows 环境下，维护一张域名与 IP 地址的对应表）</li>\n<li>操作系统间根域名发送至 LDNS（本地域名服务器），首先查找自己的缓存若是失败：<ul>\n<li>向根域名服务器发起请求，此处根域名服务器返回 com 域的 sing 机域名服务器地址。</li>\n<li>LDNS 向 com 域的顶级域名服务器发起请求，得到 www.baidu.com 的地址。</li>\n<li>LONS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址。</li>\n</ul>\n</li>\n<li>LDNS 将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；</li>\n<li>操作系统将 IP 地址返回给浏览器，同时自己也缓存起来；</li>\n</ol>\n<p>此时浏览器得到了域名对应的 IP 地址。</p>\n<h3 id=\"TCP-连接\"><a href=\"#TCP-连接\" class=\"headerlink\" title=\"TCP 连接\"></a>TCP 连接</h3><p>浏览器根据 IP 地址与服务器建立 socket 连接 。</p>\n<h3 id=\"发送-HTTP-请求\"><a href=\"#发送-HTTP-请求\" class=\"headerlink\" title=\"发送 HTTP 请求\"></a>发送 HTTP 请求</h3><ol>\n<li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含文件的位置，请求文件的方式等。</li>\n<li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件。</li>\n</ol>\n<h4 id=\"http-状态码\"><a href=\"#http-状态码\" class=\"headerlink\" title=\"http 状态码\"></a>http 状态码</h4><ol>\n<li>200 form memory cache 不访问服务器，直接读缓存 ，此时的缓存是缓存在内存中的，当 kill 进程之后数据就会不存在。这种方式只能缓存派生资源。</li>\n<li>200 OK (from cache) 是浏览器没有跟服务器确认，直接用了浏览器缓存。</li>\n<li>304 Not Modified 是浏览器和服务器多确认了一次缓存有效性，再用的缓存。200(from cache) 是速度最快的 , 因为不需要访问远程服务器 , 直接使用本地缓存 .304 的过程是 , 先请求服务器 , 然后服务器告诉我们这个资源没变 , 浏览器再使用本地缓存。</li>\n<li>200 from dist cache 不访问服务器，直接度缓存，当进程 kill 时，数据依旧存在。只能缓存派生资源。</li>\n</ol>\n<p><img src=\"/images/problem/1.png\" alt=\"img caption\"></p>\n<h3 id=\"浏览器解析渲染页面\"><a href=\"#浏览器解析渲染页面\" class=\"headerlink\" title=\"浏览器解析渲染页面\"></a>浏览器解析渲染页面</h3><p>现代浏览器渲染页面过程是：解码（字节流到字符流） ——&gt; 分词（此法分析） ——&gt; 解析（语法分析）——&gt; 构建 DOM 树 ——&gt; 构建渲染树 ——&gt; 布局渲染树 ——&gt; 绘制渲染树</p>\n<h3 id=\"连接结束\"><a href=\"#连接结束\" class=\"headerlink\" title=\"连接结束\"></a>连接结束</h3><p>断开连接 –4 次挥手</p>\n<ul>\n<li><p>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。</p>\n</li>\n<li><p>第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。</p>\n</li>\n</ul>\n<h2 id=\"session、cookie、seesionStorage、localStorage-的区别\"><a href=\"#session、cookie、seesionStorage、localStorage-的区别\" class=\"headerlink\" title=\"session、cookie、seesionStorage、localStorage 的区别\"></a>session、cookie、seesionStorage、localStorage 的区别</h2><p>cookie 和 session 都是用来跟踪浏览器用户身份的会话方式。</p>\n<h3 id=\"cookie-机制\"><a href=\"#cookie-机制\" class=\"headerlink\" title=\"cookie 机制\"></a>cookie 机制</h3><p>如果不子啊浏览器中设置过期时间，cookie 会被保存在内存中，生命周期谁浏览器的关闭而结束，这种 cookie 称为会话 cookie，如果设置了 cookie 过期时间会保存在硬盘中，关闭浏览器之后，cookie 数据仍然存在，直到过期时间结束才消失。</p>\n<p>cookie 是服务器发给客户端的特殊信息，cookie 是以文本的方式保存在客户端，每次请求时会带上它。</p>\n<h3 id=\"session-机制\"><a href=\"#session-机制\" class=\"headerlink\" title=\"session 机制\"></a>session 机制</h3><p>当服务器收到请求需要创建 seesion 对象时，首先会检查客户端请求是否包含 sessionId。如果有 seesionId,服务器将根据该 id 返回对象的 session 对象，如果没有 sessionid,服务器将会创建新的 session 对象，并把 sessionid 再本次响应中返回给客户端。通常使用 cookie 方式存储 sessionid 到客户端，再交互中浏览器按照规则将 sessionid 发给服务端。如果用户禁用 cookie，则要使用 URL 重写，可以通过 response.encodeURL(url)进行实现；API 对 encodeURL 的结束为，当浏览器支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 时，url 不做任何处理；当浏览器不支持 Cookie 的时候，将会重写 URL 将 seesionid 拼接到访问地址之后。</p>\n<h3 id=\"存储内容\"><a href=\"#存储内容\" class=\"headerlink\" title=\"存储内容\"></a>存储内容</h3><p>cookie 只能保存字符串，以文本的方式；session 通过类型与 Hashtable 的数据结构来保存，能支持任何类型的对象（session 中可含有多个对象）。</p>\n<h3 id=\"存储的大小\"><a href=\"#存储的大小\" class=\"headerlink\" title=\"存储的大小\"></a>存储的大小</h3><ul>\n<li>cookie:单个 cookie 保存的数据不能超过 4kb;</li>\n<li>session:大小没有限制。</li>\n</ul>\n<h3 id=\"sessionStorage\"><a href=\"#sessionStorage\" class=\"headerlink\" title=\"sessionStorage\"></a>sessionStorage</h3><p>是一个 HTML5 新增的一个会话储存对象，用于临时保存同一个窗口（或标签页）的数据，再关闭窗口或关闭标签页之后会将删除这些数据。</p>\n<p>在 JavaScript 中可以通过 window。sessionStorage 或 sessionStrorage</p>\n<p>非常适合 SPA，可以方便再各业务模块进行传值</p>\n<h3 id=\"localSotrage\"><a href=\"#localSotrage\" class=\"headerlink\" title=\"localSotrage\"></a>localSotrage</h3><p>localStorage 存储的数据是永久性的。</p>\n<h2 id=\"Javascript-的节流和防抖\"><a href=\"#Javascript-的节流和防抖\" class=\"headerlink\" title=\"Javascript 的节流和防抖\"></a>Javascript 的节流和防抖</h2><p>函数节流和函数防抖，两者都是优化高频率执行 JS 代码的一种手段。</p>\n<h3 id=\"函数节流\"><a href=\"#函数节流\" class=\"headerlink\" title=\"函数节流\"></a>函数节流</h3><p>是指一定时间内 js 方法只跑一次。</p>\n<p>函数节流应用的实际场景，多数在监听页面元素滚动时间的时候会用到。因为滚动事件，是一个高频触发的事件。以下是监听页面元素滚动的示例代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数节流</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> canRun = <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'throttle'</span>).onsroll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!canRun) &#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断是否空闲，如果在执行中，则直接return</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  canRun = <span class=\"literal\">false</span></span><br><span class=\"line\">  setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'函数节流'</span>)</span><br><span class=\"line\">    canRun = <span class=\"literal\">true</span></span><br><span class=\"line\">  &#125;, <span class=\"number\">300</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数防抖\"><a href=\"#函数防抖\" class=\"headerlink\" title=\"函数防抖\"></a>函数防抖</h3><p>函数防抖的应有场景，最常见的就是用户注册的时候的手机号码验证和邮箱验证了。只有等用户输入完毕后，前端才需要检查格式是否正确，如果不正确，在弹出提示语。以下还是以页面元素滚动监听的例子，来解析：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//函数防抖</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> timer = fasle</span><br><span class=\"line\"><span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'document'</span>).onsrcoll = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  clearTimeout(timer).timer = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//清楚未执行的代码，重置回初始状态</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'函数防抖'</span>)</span><br><span class=\"line\">  &#125;, <span class=\"number\">300</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数防抖的要点，也是需要一个 setTimeout 来辅助实现。延迟执行需要跑的代码</p>\n<h2 id=\"html-页面的渲染过程\"><a href=\"#html-页面的渲染过程\" class=\"headerlink\" title=\"html 页面的渲染过程\"></a>html 页面的渲染过程</h2><p>当用户请求页面时，浏览器获取 HTML 并构造 DOM。然后获取 CSS 并构造 CSSOM。然后通过匹配 DOM 和 CSSDOM 生成渲染树。如果有任何的 javascript 需要解决，浏览器将不会开始渲染页面，知道 javascript 解决完毕。</p>"},{"title":"面试积累","date":"2018-03-08T10:21:15.000Z","_content":"\n总结一些面试及笔试题\n\n<!--more-->\n\n## CSS 有哪些样式可以给子元素继承\n\n* 可继承的:`font-size`,`font-weight`,`line-height`,`color`,`cursor` 等 。\n* 不可继承的一般是会改变盒子模型的:`display`,`margin`、`border`、`padding`、`height` 等。\n\n## box-sizing 常用的属性有哪些? 分别有啥作用?\n\n这个 css 主要是改变盒子模型的大小。有两个值:`content-box`(标准模型),`border-box`（怪异模型）\n\n```html\n<style>\n    .test {\n      box-sizing: content-box;\n      border: 5px solid #f00;\n      padding:5px;\n      width: 100px;\n      height: 100px;\n    }\n\n  </style>\n  <div class=\"test\"></div>\n<!--\ncontent-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,\n也就是说 content + padding + border = 120px(盒子实际大小)\n\n而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者\ncontent(80px) + padding(5*2px) + border(5*2px) = 100px\n-->\n```\n\n## 说说样式权重的优先级;\n\n`!important` > `行内样式` > `id` > `class` > `tag`\n\n## 对数组 ['2018-03-05', '2013-06-12','2019-03-12','2018-03-05','2014-02-22'] 去重且排序\n\n```javascript\n//很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)\n// 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组\n// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等\n\nlet arr = [...new Set(['2018-03-05', '2013-06-12', '2019-03-12', '2018-03-05', '2014-02-22'])].sort(function(a, b) {\n  return a < b ? -1 : 1 // 这里返回的是升序的,降序改下返回值就好了.所以是相对\n})\n\n// [\"2013-06-12\", \"2014-02-22\", \"2018-03-05\", \"2019-03-12\"]\n```\n\n## 对数组[1,2,3,4,5,'6',7,'8','a','b','z']进行乱序\n\n```javascript\n// 我们依旧可以用上面的 sort 的原理实现乱序\n\nlet tempArr = [1, 2, 3, 4, 5, '6', 7, '8', 'a', 'b', 'z'].sort(function() {\n  return Math.random() > 0.5 ? -1 : 1\n})\n\n// 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个\n//[\"6\", \"z\", 3, \"b\", 5, 2, 7, \"8\", \"a\", 1, 4]\n```\n\n##　 求[1, 10, 11, -1,'-5',12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差\n\n```\n// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的\nfunction MaxMinPlus(arr) {\n  // 返回最大值与最小值之差\n  return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log('传入的不是数组亦或者未能解决的错误')\n}\n\n// 结果是 20\n\n// 若是要完善的话,要考虑传入的是非数组,\n//传入字符串的时候要判断,然后切割为数组..\n// 都要考虑进去代码量不短\n```\n\n## JS 的作用域是什么?有什么特别之处么\n\n作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些;\n\n函数声明提升优于变量声明提升..\n\n作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的);\n\n作用域会影响 this 的指向\n\n## javascript 里面的继承怎么实现，如何避免原型链上面的对象共享\n\n* ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。\n\n```javascript\nfunction ParentClass(name) {\n  this.name = name\n}\nParentClass.prototype.sayHello = function() {\n  console.log(\"I'm parent!\" + this.name)\n}\nfunction SubClass(name, age) {\n  //若是要多个参数可以用apply 结合 ...解构\n  ParentClass.call(this, name)\n  this.age = age\n}\nSubClass.prototype = Object.create(ParentClass.prototype)\nSubClass.prototype.constructor = SubClass\nSubClass.prototype.sayChildHello = function(name) {\n  console.log(\"I'm child \" + this.name)\n}\n\nlet testA = new SubClass('CRPER')\n\n// Object.create()的polyfill\n/*\n    function pureObject(o){\n        //定义了一个临时构造函数\n         function F() {}\n         //将这个临时构造函数的原型指向了传入进来的对象。\n         F.prototype = obj;\n         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。\n         //因为该实例的原型是obj对象。\n         return new F();\n    }\n    */\n```\n\n* ES6: 其实就是 ES5 的语法糖,不过可读性很强\n\n```javascript\nclass ParentClass {\n  constructor(name) {\n    this.name = name\n  }\n  sayHello() {\n    console.log(\"I'm parent!\" + this.name)\n  }\n}\n\nclass SubClass extends ParentClass {\n  constructor(name) {\n    super(name)\n  }\n  sayChildHello() {\n    console.log(\"I'm child \" + this.name)\n  }\n  // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上\n  sayHello() {\n    console.log(\"override parent method !,I'm sayHello Method\")\n  }\n}\n\nlet testA = new SubClass('CRPER')\n```\n## 谈谈你对Promise 的理解 ，和ajax 之间的关系。\n","source":"_posts/面试积累.md","raw":"---\ntitle: 面试积累\ndate: 2018-03-08 18:21:15\ntags:\n---\n\n总结一些面试及笔试题\n\n<!--more-->\n\n## CSS 有哪些样式可以给子元素继承\n\n* 可继承的:`font-size`,`font-weight`,`line-height`,`color`,`cursor` 等 。\n* 不可继承的一般是会改变盒子模型的:`display`,`margin`、`border`、`padding`、`height` 等。\n\n## box-sizing 常用的属性有哪些? 分别有啥作用?\n\n这个 css 主要是改变盒子模型的大小。有两个值:`content-box`(标准模型),`border-box`（怪异模型）\n\n```html\n<style>\n    .test {\n      box-sizing: content-box;\n      border: 5px solid #f00;\n      padding:5px;\n      width: 100px;\n      height: 100px;\n    }\n\n  </style>\n  <div class=\"test\"></div>\n<!--\ncontent-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,\n也就是说 content + padding + border = 120px(盒子实际大小)\n\n而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者\ncontent(80px) + padding(5*2px) + border(5*2px) = 100px\n-->\n```\n\n## 说说样式权重的优先级;\n\n`!important` > `行内样式` > `id` > `class` > `tag`\n\n## 对数组 ['2018-03-05', '2013-06-12','2019-03-12','2018-03-05','2014-02-22'] 去重且排序\n\n```javascript\n//很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)\n// 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组\n// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等\n\nlet arr = [...new Set(['2018-03-05', '2013-06-12', '2019-03-12', '2018-03-05', '2014-02-22'])].sort(function(a, b) {\n  return a < b ? -1 : 1 // 这里返回的是升序的,降序改下返回值就好了.所以是相对\n})\n\n// [\"2013-06-12\", \"2014-02-22\", \"2018-03-05\", \"2019-03-12\"]\n```\n\n## 对数组[1,2,3,4,5,'6',7,'8','a','b','z']进行乱序\n\n```javascript\n// 我们依旧可以用上面的 sort 的原理实现乱序\n\nlet tempArr = [1, 2, 3, 4, 5, '6', 7, '8', 'a', 'b', 'z'].sort(function() {\n  return Math.random() > 0.5 ? -1 : 1\n})\n\n// 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个\n//[\"6\", \"z\", 3, \"b\", 5, 2, 7, \"8\", \"a\", 1, 4]\n```\n\n##　 求[1, 10, 11, -1,'-5',12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差\n\n```\n// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的\nfunction MaxMinPlus(arr) {\n  // 返回最大值与最小值之差\n  return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log('传入的不是数组亦或者未能解决的错误')\n}\n\n// 结果是 20\n\n// 若是要完善的话,要考虑传入的是非数组,\n//传入字符串的时候要判断,然后切割为数组..\n// 都要考虑进去代码量不短\n```\n\n## JS 的作用域是什么?有什么特别之处么\n\n作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些;\n\n函数声明提升优于变量声明提升..\n\n作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的);\n\n作用域会影响 this 的指向\n\n## javascript 里面的继承怎么实现，如何避免原型链上面的对象共享\n\n* ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。\n\n```javascript\nfunction ParentClass(name) {\n  this.name = name\n}\nParentClass.prototype.sayHello = function() {\n  console.log(\"I'm parent!\" + this.name)\n}\nfunction SubClass(name, age) {\n  //若是要多个参数可以用apply 结合 ...解构\n  ParentClass.call(this, name)\n  this.age = age\n}\nSubClass.prototype = Object.create(ParentClass.prototype)\nSubClass.prototype.constructor = SubClass\nSubClass.prototype.sayChildHello = function(name) {\n  console.log(\"I'm child \" + this.name)\n}\n\nlet testA = new SubClass('CRPER')\n\n// Object.create()的polyfill\n/*\n    function pureObject(o){\n        //定义了一个临时构造函数\n         function F() {}\n         //将这个临时构造函数的原型指向了传入进来的对象。\n         F.prototype = obj;\n         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。\n         //因为该实例的原型是obj对象。\n         return new F();\n    }\n    */\n```\n\n* ES6: 其实就是 ES5 的语法糖,不过可读性很强\n\n```javascript\nclass ParentClass {\n  constructor(name) {\n    this.name = name\n  }\n  sayHello() {\n    console.log(\"I'm parent!\" + this.name)\n  }\n}\n\nclass SubClass extends ParentClass {\n  constructor(name) {\n    super(name)\n  }\n  sayChildHello() {\n    console.log(\"I'm child \" + this.name)\n  }\n  // 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上\n  sayHello() {\n    console.log(\"override parent method !,I'm sayHello Method\")\n  }\n}\n\nlet testA = new SubClass('CRPER')\n```\n## 谈谈你对Promise 的理解 ，和ajax 之间的关系。\n","slug":"面试积累","published":1,"updated":"2018-03-20T03:29:41.824Z","_id":"cjepksjoi001e8gv6vq9a9fxy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>总结一些面试及笔试题</p>\n<a id=\"more\"></a>\n<h2 id=\"CSS-有哪些样式可以给子元素继承\"><a href=\"#CSS-有哪些样式可以给子元素继承\" class=\"headerlink\" title=\"CSS 有哪些样式可以给子元素继承\"></a>CSS 有哪些样式可以给子元素继承</h2><ul>\n<li>可继承的:<code>font-size</code>,<code>font-weight</code>,<code>line-height</code>,<code>color</code>,<code>cursor</code> 等 。</li>\n<li>不可继承的一般是会改变盒子模型的:<code>display</code>,<code>margin</code>、<code>border</code>、<code>padding</code>、<code>height</code> 等。</li>\n</ul>\n<h2 id=\"box-sizing-常用的属性有哪些-分别有啥作用\"><a href=\"#box-sizing-常用的属性有哪些-分别有啥作用\" class=\"headerlink\" title=\"box-sizing 常用的属性有哪些? 分别有啥作用?\"></a>box-sizing 常用的属性有哪些? 分别有啥作用?</h2><p>这个 css 主要是改变盒子模型的大小。有两个值:<code>content-box</code>(标准模型),<code>border-box</code>（怪异模型）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .test &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      box-sizing: content-box;</span></span><br><span class=\"line\"><span class=\"undefined\">      border: 5px solid #f00;</span></span><br><span class=\"line\"><span class=\"undefined\">      padding:5px;</span></span><br><span class=\"line\"><span class=\"undefined\">      width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">      height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">content-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,</span></span><br><span class=\"line\"><span class=\"comment\">也就是说 content + padding + border = 120px(盒子实际大小)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者</span></span><br><span class=\"line\"><span class=\"comment\">content(80px) + padding(5*2px) + border(5*2px) = 100px</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"说说样式权重的优先级\"><a href=\"#说说样式权重的优先级\" class=\"headerlink\" title=\"说说样式权重的优先级;\"></a>说说样式权重的优先级;</h2><p><code>!important</code> &gt; <code>行内样式</code> &gt; <code>id</code> &gt; <code>class</code> &gt; <code>tag</code></p>\n<h2 id=\"对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序\"><a href=\"#对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序\" class=\"headerlink\" title=\"对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序\"></a>对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)</span></span><br><span class=\"line\"><span class=\"comment\">// 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组</span></span><br><span class=\"line\"><span class=\"comment\">// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...new <span class=\"built_in\">Set</span>([<span class=\"string\">'2018-03-05'</span>, <span class=\"string\">'2013-06-12'</span>, <span class=\"string\">'2019-03-12'</span>, <span class=\"string\">'2018-03-05'</span>, <span class=\"string\">'2014-02-22'</span>])].sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? <span class=\"number\">-1</span> : <span class=\"number\">1</span> <span class=\"comment\">// 这里返回的是升序的,降序改下返回值就好了.所以是相对</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"2013-06-12\", \"2014-02-22\", \"2018-03-05\", \"2019-03-12\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"对数组-1-2-3-4-5-’6’-7-’8’-’a’-’b’-’z’-进行乱序\"><a href=\"#对数组-1-2-3-4-5-’6’-7-’8’-’a’-’b’-’z’-进行乱序\" class=\"headerlink\" title=\"对数组[1,2,3,4,5,’6’,7,’8’,’a’,’b’,’z’]进行乱序\"></a>对数组[1,2,3,4,5,’6’,7,’8’,’a’,’b’,’z’]进行乱序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们依旧可以用上面的 sort 的原理实现乱序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"string\">'6'</span>, <span class=\"number\">7</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'z'</span>].sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">0.5</span> ? <span class=\"number\">-1</span> : <span class=\"number\">1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个</span></span><br><span class=\"line\"><span class=\"comment\">//[\"6\", \"z\", 3, \"b\", 5, 2, 7, \"8\", \"a\", 1, 4]</span></span><br></pre></td></tr></table></figure>\n<p>##　 求[1, 10, 11, -1,’-5’,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的</span><br><span class=\"line\">function MaxMinPlus(arr) &#123;</span><br><span class=\"line\">  // 返回最大值与最小值之差</span><br><span class=\"line\">  return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log(&apos;传入的不是数组亦或者未能解决的错误&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 结果是 20</span><br><span class=\"line\"></span><br><span class=\"line\">// 若是要完善的话,要考虑传入的是非数组,</span><br><span class=\"line\">//传入字符串的时候要判断,然后切割为数组..</span><br><span class=\"line\">// 都要考虑进去代码量不短</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-的作用域是什么-有什么特别之处么\"><a href=\"#JS-的作用域是什么-有什么特别之处么\" class=\"headerlink\" title=\"JS 的作用域是什么?有什么特别之处么\"></a>JS 的作用域是什么?有什么特别之处么</h2><p>作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些;</p>\n<p>函数声明提升优于变量声明提升..</p>\n<p>作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的);</p>\n<p>作用域会影响 this 的指向</p>\n<h2 id=\"javascript-里面的继承怎么实现，如何避免原型链上面的对象共享\"><a href=\"#javascript-里面的继承怎么实现，如何避免原型链上面的对象共享\" class=\"headerlink\" title=\"javascript 里面的继承怎么实现，如何避免原型链上面的对象共享\"></a>javascript 里面的继承怎么实现，如何避免原型链上面的对象共享</h2><ul>\n<li>ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ParentClass</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ParentClass.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm parent!\"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//若是要多个参数可以用apply 结合 ...解构</span></span><br><span class=\"line\">  ParentClass.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubClass.prototype = <span class=\"built_in\">Object</span>.create(ParentClass.prototype)</span><br><span class=\"line\">SubClass.prototype.constructor = SubClass</span><br><span class=\"line\">SubClass.prototype.sayChildHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm child \"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> testA = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'CRPER'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.create()的polyfill</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    function pureObject(o)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        //定义了一个临时构造函数</span></span><br><span class=\"line\"><span class=\"comment\">         function F() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">         //将这个临时构造函数的原型指向了传入进来的对象。</span></span><br><span class=\"line\"><span class=\"comment\">         F.prototype = obj;</span></span><br><span class=\"line\"><span class=\"comment\">         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。</span></span><br><span class=\"line\"><span class=\"comment\">         //因为该实例的原型是obj对象。</span></span><br><span class=\"line\"><span class=\"comment\">         return new F();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6: 其实就是 ES5 的语法糖,不过可读性很强</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHello() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm parent!\"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">ParentClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayChildHello() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm child \"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上</span></span><br><span class=\"line\">  sayHello() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"override parent method !,I'm sayHello Method\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> testA = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'CRPER'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"谈谈你对Promise-的理解-，和ajax-之间的关系。\"><a href=\"#谈谈你对Promise-的理解-，和ajax-之间的关系。\" class=\"headerlink\" title=\"谈谈你对Promise 的理解 ，和ajax 之间的关系。\"></a>谈谈你对Promise 的理解 ，和ajax 之间的关系。</h2>","site":{"data":{}},"excerpt":"<p>总结一些面试及笔试题</p>","more":"<h2 id=\"CSS-有哪些样式可以给子元素继承\"><a href=\"#CSS-有哪些样式可以给子元素继承\" class=\"headerlink\" title=\"CSS 有哪些样式可以给子元素继承\"></a>CSS 有哪些样式可以给子元素继承</h2><ul>\n<li>可继承的:<code>font-size</code>,<code>font-weight</code>,<code>line-height</code>,<code>color</code>,<code>cursor</code> 等 。</li>\n<li>不可继承的一般是会改变盒子模型的:<code>display</code>,<code>margin</code>、<code>border</code>、<code>padding</code>、<code>height</code> 等。</li>\n</ul>\n<h2 id=\"box-sizing-常用的属性有哪些-分别有啥作用\"><a href=\"#box-sizing-常用的属性有哪些-分别有啥作用\" class=\"headerlink\" title=\"box-sizing 常用的属性有哪些? 分别有啥作用?\"></a>box-sizing 常用的属性有哪些? 分别有啥作用?</h2><p>这个 css 主要是改变盒子模型的大小。有两个值:<code>content-box</code>(标准模型),<code>border-box</code>（怪异模型）</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .test &#123;</span></span><br><span class=\"line\"><span class=\"undefined\">      box-sizing: content-box;</span></span><br><span class=\"line\"><span class=\"undefined\">      border: 5px solid #f00;</span></span><br><span class=\"line\"><span class=\"undefined\">      padding:5px;</span></span><br><span class=\"line\"><span class=\"undefined\">      width: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">      height: 100px;</span></span><br><span class=\"line\"><span class=\"undefined\">    &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"test\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!--</span></span><br><span class=\"line\"><span class=\"comment\">content-box的计算公式会把宽高的定义指向 content,border和 padding 另外计算,</span></span><br><span class=\"line\"><span class=\"comment\">也就是说 content + padding + border = 120px(盒子实际大小)</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">而border-box的计算公式是总的大小涵盖这三者, content 会缩小,来让给另外两者</span></span><br><span class=\"line\"><span class=\"comment\">content(80px) + padding(5*2px) + border(5*2px) = 100px</span></span><br><span class=\"line\"><span class=\"comment\">--&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"说说样式权重的优先级\"><a href=\"#说说样式权重的优先级\" class=\"headerlink\" title=\"说说样式权重的优先级;\"></a>说说样式权重的优先级;</h2><p><code>!important</code> &gt; <code>行内样式</code> &gt; <code>id</code> &gt; <code>class</code> &gt; <code>tag</code></p>\n<h2 id=\"对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序\"><a href=\"#对数组-‘2018-03-05’-‘2013-06-12’-’2019-03-12’-’2018-03-05’-’2014-02-22’-去重且排序\" class=\"headerlink\" title=\"对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序\"></a>对数组 [‘2018-03-05’, ‘2013-06-12’,’2019-03-12’,’2018-03-05’,’2014-02-22’] 去重且排序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//很好理解, Set 具有值唯一性(但不是所有值,等会我抛出我的另外一篇文章)</span></span><br><span class=\"line\"><span class=\"comment\">// 结合...解构,可以把可迭代(比如 arguments/nodelist 等)的转为数组</span></span><br><span class=\"line\"><span class=\"comment\">// sort 里面传入 两个值比较,返回-1和1是因为1代表这个数大排后(相对),-1代表小(相对),0为相等</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> arr = [...new <span class=\"built_in\">Set</span>([<span class=\"string\">'2018-03-05'</span>, <span class=\"string\">'2013-06-12'</span>, <span class=\"string\">'2019-03-12'</span>, <span class=\"string\">'2018-03-05'</span>, <span class=\"string\">'2014-02-22'</span>])].sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? <span class=\"number\">-1</span> : <span class=\"number\">1</span> <span class=\"comment\">// 这里返回的是升序的,降序改下返回值就好了.所以是相对</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// [\"2013-06-12\", \"2014-02-22\", \"2018-03-05\", \"2019-03-12\"]</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"对数组-1-2-3-4-5-’6’-7-’8’-’a’-’b’-’z’-进行乱序\"><a href=\"#对数组-1-2-3-4-5-’6’-7-’8’-’a’-’b’-’z’-进行乱序\" class=\"headerlink\" title=\"对数组[1,2,3,4,5,’6’,7,’8’,’a’,’b’,’z’]进行乱序\"></a>对数组[1,2,3,4,5,’6’,7,’8’,’a’,’b’,’z’]进行乱序</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 我们依旧可以用上面的 sort 的原理实现乱序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> tempArr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"string\">'6'</span>, <span class=\"number\">7</span>, <span class=\"string\">'8'</span>, <span class=\"string\">'a'</span>, <span class=\"string\">'b'</span>, <span class=\"string\">'z'</span>].sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() &gt; <span class=\"number\">0.5</span> ? <span class=\"number\">-1</span> : <span class=\"number\">1</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 因为里面有随机数,所以答案没有标准答案,我这边跑了一次是输出这个</span></span><br><span class=\"line\"><span class=\"comment\">//[\"6\", \"z\", 3, \"b\", 5, 2, 7, \"8\", \"a\", 1, 4]</span></span><br></pre></td></tr></table></figure>\n<p>##　 求[1, 10, 11, -1,’-5’,12, 13, 14, 15, 2, 3, 4, 7, 8, 9]内最大值与最小值之差</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 来一个很粗糙的版本,只当传入是数组且可以隐性转为数字的</span><br><span class=\"line\">function MaxMinPlus(arr) &#123;</span><br><span class=\"line\">  // 返回最大值与最小值之差</span><br><span class=\"line\">  return Array.isArray(arr) ? Math.max.apply(Math, arr) - Math.min.apply(Math, arr) : console.log(&apos;传入的不是数组亦或者未能解决的错误&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 结果是 20</span><br><span class=\"line\"></span><br><span class=\"line\">// 若是要完善的话,要考虑传入的是非数组,</span><br><span class=\"line\">//传入字符串的时候要判断,然后切割为数组..</span><br><span class=\"line\">// 都要考虑进去代码量不短</span><br></pre></td></tr></table></figure>\n<h2 id=\"JS-的作用域是什么-有什么特别之处么\"><a href=\"#JS-的作用域是什么-有什么特别之处么\" class=\"headerlink\" title=\"JS 的作用域是什么?有什么特别之处么\"></a>JS 的作用域是什么?有什么特别之处么</h2><p>作用域就是有它自身的上下文区域(比如函数内),内部会有变量声明提升,函数声明提升这些;</p>\n<p>函数声明提升优于变量声明提升..</p>\n<p>作用域有全局作用域和块级作用域(局部,比如用 let 或者单纯花括号的);</p>\n<p>作用域会影响 this 的指向</p>\n<h2 id=\"javascript-里面的继承怎么实现，如何避免原型链上面的对象共享\"><a href=\"#javascript-里面的继承怎么实现，如何避免原型链上面的对象共享\" class=\"headerlink\" title=\"javascript 里面的继承怎么实现，如何避免原型链上面的对象共享\"></a>javascript 里面的继承怎么实现，如何避免原型链上面的对象共享</h2><ul>\n<li>ES5:寄生组合式继承:通过借用构造函数来继承属性和原型链来实现子继承父。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ParentClass</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">ParentClass.prototype.sayHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm parent!\"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">SubClass</span>(<span class=\"params\">name, age</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//若是要多个参数可以用apply 结合 ...解构</span></span><br><span class=\"line\">  ParentClass.call(<span class=\"keyword\">this</span>, name)</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.age = age</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">SubClass.prototype = <span class=\"built_in\">Object</span>.create(ParentClass.prototype)</span><br><span class=\"line\">SubClass.prototype.constructor = SubClass</span><br><span class=\"line\">SubClass.prototype.sayChildHello = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm child \"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> testA = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'CRPER'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Object.create()的polyfill</span></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">    function pureObject(o)&#123;</span></span><br><span class=\"line\"><span class=\"comment\">        //定义了一个临时构造函数</span></span><br><span class=\"line\"><span class=\"comment\">         function F() &#123;&#125;</span></span><br><span class=\"line\"><span class=\"comment\">         //将这个临时构造函数的原型指向了传入进来的对象。</span></span><br><span class=\"line\"><span class=\"comment\">         F.prototype = obj;</span></span><br><span class=\"line\"><span class=\"comment\">         //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。</span></span><br><span class=\"line\"><span class=\"comment\">         //因为该实例的原型是obj对象。</span></span><br><span class=\"line\"><span class=\"comment\">         return new F();</span></span><br><span class=\"line\"><span class=\"comment\">    &#125;</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6: 其实就是 ES5 的语法糖,不过可读性很强</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ParentClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = name</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayHello() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm parent!\"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SubClass</span> <span class=\"keyword\">extends</span> <span class=\"title\">ParentClass</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">constructor</span>(name) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">super</span>(name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  sayChildHello() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"I'm child \"</span> + <span class=\"keyword\">this</span>.name)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 重新声明父类同名方法会覆写,ES5的话就是直接操作自己的原型链上</span></span><br><span class=\"line\">  sayHello() &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"override parent method !,I'm sayHello Method\"</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> testA = <span class=\"keyword\">new</span> SubClass(<span class=\"string\">'CRPER'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"谈谈你对Promise-的理解-，和ajax-之间的关系。\"><a href=\"#谈谈你对Promise-的理解-，和ajax-之间的关系。\" class=\"headerlink\" title=\"谈谈你对Promise 的理解 ，和ajax 之间的关系。\"></a>谈谈你对Promise 的理解 ，和ajax 之间的关系。</h2>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjepksjl700008gv65nxb23d6","category_id":"cjepksjll00028gv6fa82vicb","_id":"cjepksjmb00098gv6bssr2wzq"},{"post_id":"cjepksjlp00038gv6gjxaqzn6","category_id":"cjepksjm500068gv68ayqx6s8","_id":"cjepksjmh000d8gv679h92tva"},{"post_id":"cjepksjlu00048gv6oskiz3e3","category_id":"cjepksjmb000a8gv6xtfudynx","_id":"cjepksjn4000i8gv6ahb4a3mp"},{"post_id":"cjepksjm200058gv6xafx340f","category_id":"cjepksjm500068gv68ayqx6s8","_id":"cjepksjnc000l8gv6pg3gt7bo"},{"post_id":"cjepksjm600078gv69tjpwpwc","category_id":"cjepksjn4000h8gv6cpf4r55b","_id":"cjepksjnq000p8gv644ivrwbp"},{"post_id":"cjepksjm800088gv6ifrjwfpk","category_id":"cjepksjnd000m8gv6alhseg0h","_id":"cjepksjnx000v8gv6dphn4p8t"},{"post_id":"cjepksjmc000b8gv6iv7jxqwd","category_id":"cjepksjnd000m8gv6alhseg0h","_id":"cjepksjo3000y8gv6pth552dv"},{"post_id":"cjepksjny000w8gv6dkgn9xk6","category_id":"cjepksjm500068gv68ayqx6s8","_id":"cjepksjo700128gv6u0jmzjc8"},{"post_id":"cjepksjmf000c8gv68kz728eg","category_id":"cjepksjnx000u8gv6bimdgswv","_id":"cjepksjo900158gv67392smxt"},{"post_id":"cjepksjmk000f8gv64hkeogsz","category_id":"cjepksjnx000u8gv6bimdgswv","_id":"cjepksjoa00188gv61lyihyid"},{"post_id":"cjepksjo600118gv6cvxfw3y5","category_id":"cjepksjm500068gv68ayqx6s8","_id":"cjepksjoc001a8gv6i0wsudi0"},{"post_id":"cjepksjn1000g8gv69qa91zh1","category_id":"cjepksjnx000u8gv6bimdgswv","_id":"cjepksjoi001d8gv6tjnzvrxt"},{"post_id":"cjepksjo900168gv6vyfnnkkd","category_id":"cjepksjm500068gv68ayqx6s8","_id":"cjepksjom001f8gv6j8m6sy7m"},{"post_id":"cjepksjn6000j8gv6quat0s0p","category_id":"cjepksjnx000u8gv6bimdgswv","_id":"cjepksjom001g8gv68c0yl2go"},{"post_id":"cjepksjoe001b8gv6hvw344oy","category_id":"cjepksjm500068gv68ayqx6s8","_id":"cjepksjon001i8gv6mb4ir5be"},{"post_id":"cjepksjna000k8gv6a7ikzdio","category_id":"cjepksjoi001c8gv6ahfi0l02","_id":"cjepksjon001j8gv643jo5x2r"},{"post_id":"cjepksjne000n8gv6b0czoa88","category_id":"cjepksjom001h8gv6t5hutytv","_id":"cjepksjoo001l8gv63i9p9jf4"},{"post_id":"cjepksjnq000q8gv60xhp3aqi","category_id":"cjepksjon001k8gv6bbrx64oi","_id":"cjepksjoo001n8gv6akkgw4s4"},{"post_id":"cjepksjnv000t8gv6aygceqq9","category_id":"cjepksjoo001m8gv6jqx31n4s","_id":"cjepksjor001p8gv6hmyvjy0u"},{"post_id":"cjepksjo400108gv6zz7ou9rl","category_id":"cjepksjop001o8gv6jjsz282j","_id":"cjepksjos001q8gv610zfztv9"}],"PostTag":[],"Tag":[]}}